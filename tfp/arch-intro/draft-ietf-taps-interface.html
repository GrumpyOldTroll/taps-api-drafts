<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Abstract Application Layer Interface to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 15px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 Interface Design Principles">
<link href="#rfc.section.4" rel="Chapter" title="4 API Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-Establishment Phase">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Specifying Endpoints">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Specifying Transport Properties">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Specifying Security Parameters and Callbacks">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Pre-Connection Parameters">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Connection Establishment Callbacks">
<link href="#rfc.section.6" rel="Chapter" title="6 Establishing Connections">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Active Open: Initiate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Passive Open: Listen">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Peer-to-Peer Establishment: Rendezvous">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Groups">
<link href="#rfc.section.7" rel="Chapter" title="7 Sending Data">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Basic Sending">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Send Events">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Sent">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Expired">
<link href="#rfc.section.7.2.3" rel="Chapter" title="7.2.3 SendError">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Message Context Parameters">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Lifetime">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Niceness">
<link href="#rfc.section.7.3.3" rel="Chapter" title="7.3.3 Ordered">
<link href="#rfc.section.7.3.4" rel="Chapter" title="7.3.4 Idempotent">
<link href="#rfc.section.7.3.5" rel="Chapter" title="7.3.5 Final">
<link href="#rfc.section.7.3.6" rel="Chapter" title="7.3.6 Corruption Protection Length">
<link href="#rfc.section.7.3.7" rel="Chapter" title="7.3.7 Reliable Data Transfer (Message)">
<link href="#rfc.section.7.3.8" rel="Chapter" title="7.3.8 Transmission Profile">
<link href="#rfc.section.7.3.9" rel="Chapter" title="7.3.9 Singular Transmission">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Partial Sends">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Batching Sends">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Send on Active Open: InitiateWithIdempotentSend">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Sender-side Framing">
<link href="#rfc.section.8" rel="Chapter" title="8 Receiving Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Enqueuing Receives">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Receive Events">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 Received">
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 ReceivedPartial">
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 ReceiveError">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Message Receive Context">
<link href="#rfc.section.8.3.1" rel="Chapter" title="8.3.1 ECN">
<link href="#rfc.section.8.3.2" rel="Chapter" title="8.3.2 Early Data">
<link href="#rfc.section.8.3.3" rel="Chapter" title="8.3.3 Receiving Final Messages">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Receiver-side De-framing over Stream Protocols">
<link href="#rfc.section.9" rel="Chapter" title="9 Managing Connections: Setting Properties and Obtaining Information">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Connection Properties">
<link href="#rfc.section.9.1.1" rel="Chapter" title="9.1.1 Notification of excessive retransmissions">
<link href="#rfc.section.9.1.2" rel="Chapter" title="9.1.2 Retransmission threshold before excessive retransmission notification">
<link href="#rfc.section.9.1.3" rel="Chapter" title="9.1.3 Notification of ICMP soft error message arrival">
<link href="#rfc.section.9.1.4" rel="Chapter" title="9.1.4 Required minimum coverage of the checksum for receiving">
<link href="#rfc.section.9.1.5" rel="Chapter" title="9.1.5 Niceness (Connection)">
<link href="#rfc.section.9.1.6" rel="Chapter" title="9.1.6 Timeout for aborting Connection">
<link href="#rfc.section.9.1.7" rel="Chapter" title="9.1.7 Connection group transmission scheduler">
<link href="#rfc.section.9.1.8" rel="Chapter" title="9.1.8 Maximum message size concurrent with Connection establishment">
<link href="#rfc.section.9.1.9" rel="Chapter" title="9.1.9 Maximum Message size before fragmentation or segmentation">
<link href="#rfc.section.9.1.10" rel="Chapter" title="9.1.10 Maximum Message size on send">
<link href="#rfc.section.9.1.11" rel="Chapter" title="9.1.11 Maximum Message size on receive">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Soft Errors">
<link href="#rfc.section.10" rel="Chapter" title="10 Connection Termination">
<link href="#rfc.section.11" rel="Chapter" title="11 Connection State and Ordering of Operations and Events">
<link href="#rfc.section.12" rel="Chapter" title="12 Transport Properties">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Transport Property Types">
<link href="#rfc.section.12.1.1" rel="Chapter" title="12.1.1 Boolean">
<link href="#rfc.section.12.1.2" rel="Chapter" title="12.1.2 Enumeration">
<link href="#rfc.section.12.1.3" rel="Chapter" title="12.1.3 Integer">
<link href="#rfc.section.12.1.4" rel="Chapter" title="12.1.4 Preference">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Transport Property Classification">
<link href="#rfc.section.12.2.1" rel="Chapter" title="12.2.1 Selection Properties">
<link href="#rfc.section.12.2.2" rel="Chapter" title="12.2.2 Protocol Properties">
<link href="#rfc.section.12.2.3" rel="Chapter" title="12.2.3 Message Properties">
<link href="#rfc.section.12.2.4" rel="Chapter" title="12.2.4 Intents">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Mandatory Transport Properties">
<link href="#rfc.section.12.3.1" rel="Chapter" title="12.3.1 Final">
<link href="#rfc.section.12.3.2" rel="Chapter" title="12.3.2 Reliable Data Transfer (Connection)">
<link href="#rfc.section.12.3.3" rel="Chapter" title="12.3.3 Configure per-Message reliability">
<link href="#rfc.section.12.3.4" rel="Chapter" title="12.3.4 Reliable Data Transfer (Message)">
<link href="#rfc.section.12.3.5" rel="Chapter" title="12.3.5 Preservation of data ordering">
<link href="#rfc.section.12.3.6" rel="Chapter" title="12.3.6 Ordered">
<link href="#rfc.section.12.3.7" rel="Chapter" title="12.3.7 Direction of communication">
<link href="#rfc.section.12.3.8" rel="Chapter" title="12.3.8 Use 0-RTT session establishment with an idempotent Message">
<link href="#rfc.section.12.3.9" rel="Chapter" title="12.3.9 Idempotent">
<link href="#rfc.section.12.3.10" rel="Chapter" title="12.3.10 Multistream Connections in Group">
<link href="#rfc.section.12.3.11" rel="Chapter" title="12.3.11 Notification of excessive retransmissions">
<link href="#rfc.section.12.3.12" rel="Chapter" title="12.3.12 Retransmission threshold before excessive retransmission notification">
<link href="#rfc.section.12.3.13" rel="Chapter" title="12.3.13 Notification of ICMP soft error message arrival">
<link href="#rfc.section.12.3.14" rel="Chapter" title="12.3.14 Control checksum coverage on sending or receiving">
<link href="#rfc.section.12.3.15" rel="Chapter" title="12.3.15 Corruption Protection Length">
<link href="#rfc.section.12.3.16" rel="Chapter" title="12.3.16 Required minimum coverage of the checksum for receiving">
<link href="#rfc.section.12.3.17" rel="Chapter" title="12.3.17 Interface Instance or Type">
<link href="#rfc.section.12.3.18" rel="Chapter" title="12.3.18 Provisioning Domain Instance or Type">
<link href="#rfc.section.12.3.19" rel="Chapter" title="12.3.19 Capacity Profile">
<link href="#rfc.section.12.3.20" rel="Chapter" title="12.3.20 Congestion control">
<link href="#rfc.section.12.3.21" rel="Chapter" title="12.3.21 Niceness (Connection)">
<link href="#rfc.section.12.3.22" rel="Chapter" title="12.3.22 Niceness (Message)">
<link href="#rfc.section.12.3.23" rel="Chapter" title="12.3.23 Timeout for aborting Connection">
<link href="#rfc.section.12.3.24" rel="Chapter" title="12.3.24 Connection group transmission scheduler">
<link href="#rfc.section.12.3.25" rel="Chapter" title="12.3.25 Maximum message size concurrent with Connection establishment">
<link href="#rfc.section.12.3.26" rel="Chapter" title="12.3.26 Maximum Message size before fragmentation or segmentation">
<link href="#rfc.section.12.3.27" rel="Chapter" title="12.3.27 Maximum Message size on send">
<link href="#rfc.section.12.3.28" rel="Chapter" title="12.3.28 Maximum Message size on receive">
<link href="#rfc.section.12.3.29" rel="Chapter" title="12.3.29 Lifetime">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Optional Transport Properties">
<link href="#rfc.section.12.5" rel="Chapter" title="12.5 Experimental Transport Properties">
<link href="#rfc.section.13" rel="Chapter" title="13 IANA Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Security Considerations">
<link href="#rfc.section.15" rel="Chapter" title="15 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="16 References">
<link href="#rfc.references.1" rel="Chapter" title="16.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="16.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Additional Properties">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Experimental Transport Properties">
<link href="#rfc.appendix.A.1.1" rel="Chapter" title="A.1.1 Suggest a timeout to the Remote Endpoint">
<link href="#rfc.appendix.A.1.2" rel="Chapter" title="A.1.2 Abort timeout to suggest to the Remote Endpoint">
<link href="#rfc.appendix.A.1.3" rel="Chapter" title="A.1.3 Traffic Category">
<link href="#rfc.appendix.A.1.4" rel="Chapter" title="A.1.4 Size to be Sent or Received">
<link href="#rfc.appendix.A.1.5" rel="Chapter" title="A.1.5 Duration">
<link href="#rfc.appendix.A.1.6" rel="Chapter" title="A.1.6 Send or Receive Bit-rate">
<link href="#rfc.appendix.A.1.7" rel="Chapter" title="A.1.7 Cost Preferences">
<link href="#rfc.appendix.B" rel="Chapter" title="B Sample API definition in Go">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.11.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Ed., Welzl, M., Ed., Enghardt, T., Fairhurst, G., Kuehlewind, M., Perkins, C., Tiesel, P., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-taps-interface-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-10-15" />
  <meta name="dct.abstract" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />
  <meta name="description" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">M. Welzl, Ed.</td>
</tr>
<tr>
<td class="left">Expires: April 18, 2019</td>
<td class="right">University of Oslo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 15, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Abstract Application Layer Interface to Transport Services<br />
  <span class="filename">draft-ietf-taps-interface-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 18, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">Interface Design Principles</a>
</li>
<li>4.   <a href="#rfc.section.4">API Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Pre-Establishment Phase</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Specifying Endpoints</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Specifying Transport Properties</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Specifying Security Parameters and Callbacks</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Pre-Connection Parameters</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Connection Establishment Callbacks</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Establishing Connections</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Active Open: Initiate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Passive Open: Listen</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Peer-to-Peer Establishment: Rendezvous</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Groups</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Sending Data</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Basic Sending</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Send Events</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Sent</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Expired</a>
</li>
<li>7.2.3.   <a href="#rfc.section.7.2.3">SendError</a>
</li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Message Context Parameters</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Lifetime</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Niceness</a>
</li>
<li>7.3.3.   <a href="#rfc.section.7.3.3">Ordered</a>
</li>
<li>7.3.4.   <a href="#rfc.section.7.3.4">Idempotent</a>
</li>
<li>7.3.5.   <a href="#rfc.section.7.3.5">Final</a>
</li>
<li>7.3.6.   <a href="#rfc.section.7.3.6">Corruption Protection Length</a>
</li>
<li>7.3.7.   <a href="#rfc.section.7.3.7">Reliable Data Transfer (Message)</a>
</li>
<li>7.3.8.   <a href="#rfc.section.7.3.8">Transmission Profile</a>
</li>
<li>7.3.9.   <a href="#rfc.section.7.3.9">Singular Transmission</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Partial Sends</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Batching Sends</a>
</li>
<li>7.6.   <a href="#rfc.section.7.6">Send on Active Open: InitiateWithIdempotentSend</a>
</li>
<li>7.7.   <a href="#rfc.section.7.7">Sender-side Framing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Receiving Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Enqueuing Receives</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Receive Events</a>
</li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">Received</a>
</li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">ReceivedPartial</a>
</li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">ReceiveError</a>
</li>
</ul><li>8.3.   <a href="#rfc.section.8.3">Message Receive Context</a>
</li>
<ul><li>8.3.1.   <a href="#rfc.section.8.3.1">ECN</a>
</li>
<li>8.3.2.   <a href="#rfc.section.8.3.2">Early Data</a>
</li>
<li>8.3.3.   <a href="#rfc.section.8.3.3">Receiving Final Messages</a>
</li>
</ul><li>8.4.   <a href="#rfc.section.8.4">Receiver-side De-framing over Stream Protocols</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Managing Connections: Setting Properties and Obtaining Information</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Connection Properties</a>
</li>
<ul><li>9.1.1.   <a href="#rfc.section.9.1.1">Notification of excessive retransmissions</a>
</li>
<li>9.1.2.   <a href="#rfc.section.9.1.2">Retransmission threshold before excessive retransmission notification</a>
</li>
<li>9.1.3.   <a href="#rfc.section.9.1.3">Notification of ICMP soft error message arrival</a>
</li>
<li>9.1.4.   <a href="#rfc.section.9.1.4">Required minimum coverage of the checksum for receiving</a>
</li>
<li>9.1.5.   <a href="#rfc.section.9.1.5">Niceness (Connection)</a>
</li>
<li>9.1.6.   <a href="#rfc.section.9.1.6">Timeout for aborting Connection</a>
</li>
<li>9.1.7.   <a href="#rfc.section.9.1.7">Connection group transmission scheduler</a>
</li>
<li>9.1.8.   <a href="#rfc.section.9.1.8">Maximum message size concurrent with Connection establishment</a>
</li>
<li>9.1.9.   <a href="#rfc.section.9.1.9">Maximum Message size before fragmentation or segmentation</a>
</li>
<li>9.1.10.   <a href="#rfc.section.9.1.10">Maximum Message size on send</a>
</li>
<li>9.1.11.   <a href="#rfc.section.9.1.11">Maximum Message size on receive</a>
</li>
</ul><li>9.2.   <a href="#rfc.section.9.2">Soft Errors</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Connection Termination</a>
</li>
<li>11.   <a href="#rfc.section.11">Connection State and Ordering of Operations and Events</a>
</li>
<li>12.   <a href="#rfc.section.12">Transport Properties</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Transport Property Types</a>
</li>
<ul><li>12.1.1.   <a href="#rfc.section.12.1.1">Boolean</a>
</li>
<li>12.1.2.   <a href="#rfc.section.12.1.2">Enumeration</a>
</li>
<li>12.1.3.   <a href="#rfc.section.12.1.3">Integer</a>
</li>
<li>12.1.4.   <a href="#rfc.section.12.1.4">Preference</a>
</li>
</ul><li>12.2.   <a href="#rfc.section.12.2">Transport Property Classification</a>
</li>
<ul><li>12.2.1.   <a href="#rfc.section.12.2.1">Selection Properties</a>
</li>
<li>12.2.2.   <a href="#rfc.section.12.2.2">Protocol Properties</a>
</li>
<li>12.2.3.   <a href="#rfc.section.12.2.3">Message Properties</a>
</li>
<li>12.2.4.   <a href="#rfc.section.12.2.4">Intents</a>
</li>
</ul><li>12.3.   <a href="#rfc.section.12.3">Mandatory Transport Properties</a>
</li>
<ul><li>12.3.1.   <a href="#rfc.section.12.3.1">Final</a>
</li>
<li>12.3.2.   <a href="#rfc.section.12.3.2">Reliable Data Transfer (Connection)</a>
</li>
<li>12.3.3.   <a href="#rfc.section.12.3.3">Configure per-Message reliability</a>
</li>
<li>12.3.4.   <a href="#rfc.section.12.3.4">Reliable Data Transfer (Message)</a>
</li>
<li>12.3.5.   <a href="#rfc.section.12.3.5">Preservation of data ordering</a>
</li>
<li>12.3.6.   <a href="#rfc.section.12.3.6">Ordered</a>
</li>
<li>12.3.7.   <a href="#rfc.section.12.3.7">Direction of communication</a>
</li>
<li>12.3.8.   <a href="#rfc.section.12.3.8">Use 0-RTT session establishment with an idempotent Message</a>
</li>
<li>12.3.9.   <a href="#rfc.section.12.3.9">Idempotent</a>
</li>
<li>12.3.10.   <a href="#rfc.section.12.3.10">Multistream Connections in Group</a>
</li>
<li>12.3.11.   <a href="#rfc.section.12.3.11">Notification of excessive retransmissions</a>
</li>
<li>12.3.12.   <a href="#rfc.section.12.3.12">Retransmission threshold before excessive retransmission notification</a>
</li>
<li>12.3.13.   <a href="#rfc.section.12.3.13">Notification of ICMP soft error message arrival</a>
</li>
<li>12.3.14.   <a href="#rfc.section.12.3.14">Control checksum coverage on sending or receiving</a>
</li>
<li>12.3.15.   <a href="#rfc.section.12.3.15">Corruption Protection Length</a>
</li>
<li>12.3.16.   <a href="#rfc.section.12.3.16">Required minimum coverage of the checksum for receiving</a>
</li>
<li>12.3.17.   <a href="#rfc.section.12.3.17">Interface Instance or Type</a>
</li>
<li>12.3.18.   <a href="#rfc.section.12.3.18">Provisioning Domain Instance or Type</a>
</li>
<li>12.3.19.   <a href="#rfc.section.12.3.19">Capacity Profile</a>
</li>
<li>12.3.20.   <a href="#rfc.section.12.3.20">Congestion control</a>
</li>
<li>12.3.21.   <a href="#rfc.section.12.3.21">Niceness (Connection)</a>
</li>
<li>12.3.22.   <a href="#rfc.section.12.3.22">Niceness (Message)</a>
</li>
<li>12.3.23.   <a href="#rfc.section.12.3.23">Timeout for aborting Connection</a>
</li>
<li>12.3.24.   <a href="#rfc.section.12.3.24">Connection group transmission scheduler</a>
</li>
<li>12.3.25.   <a href="#rfc.section.12.3.25">Maximum message size concurrent with Connection establishment</a>
</li>
<li>12.3.26.   <a href="#rfc.section.12.3.26">Maximum Message size before fragmentation or segmentation</a>
</li>
<li>12.3.27.   <a href="#rfc.section.12.3.27">Maximum Message size on send</a>
</li>
<li>12.3.28.   <a href="#rfc.section.12.3.28">Maximum Message size on receive</a>
</li>
<li>12.3.29.   <a href="#rfc.section.12.3.29">Lifetime</a>
</li>
</ul><li>12.4.   <a href="#rfc.section.12.4">Optional Transport Properties</a>
</li>
<li>12.5.   <a href="#rfc.section.12.5">Experimental Transport Properties</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">IANA Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Security Considerations</a>
</li>
<li>15.   <a href="#rfc.section.15">Acknowledgements</a>
</li>
<li>16.   <a href="#rfc.references">References</a>
</li>
<ul><li>16.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>16.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Additional Properties</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Experimental Transport Properties</a>
</li>
<ul><li>A.1.1.   <a href="#rfc.appendix.A.1.1">Suggest a timeout to the Remote Endpoint</a>
</li>
<li>A.1.2.   <a href="#rfc.appendix.A.1.2">Abort timeout to suggest to the Remote Endpoint</a>
</li>
<li>A.1.3.   <a href="#rfc.appendix.A.1.3">Traffic Category</a>
</li>
<li>A.1.4.   <a href="#rfc.appendix.A.1.4">Size to be Sent or Received</a>
</li>
<li>A.1.5.   <a href="#rfc.appendix.A.1.5">Duration</a>
</li>
<li>A.1.6.   <a href="#rfc.appendix.A.1.6">Send or Receive Bit-rate</a>
</li>
<li>A.1.7.   <a href="#rfc.appendix.A.1.7">Cost Preferences</a>
</li>
</ul></ul><li>Appendix B.   <a href="#rfc.appendix.B">Sample API definition in Go</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. The simplicity of this API is a key reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design principles of a new approach, which we outline in <a href="#principles" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.3">As a first step to realizing this design, <a href="#I-D.ietf-taps-arch" class="xref">[I-D.ietf-taps-arch]</a> describes a high-level architecture for transport services. This document builds a modern abstract programming interface atop this architecture, deriving specific path and protocol selection properties and supported transport features from the analysis provided in <a href="#RFC8095" class="xref">[RFC8095]</a>, <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>, and <a href="#I-D.ietf-taps-transport-security" class="xref">[I-D.ietf-taps-transport-security]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology-and-notation" id="terminology-and-notation">Terminology and Notation</a>
</h1>
<p id="rfc.section.2.p.1">This API is described in terms of Objects, which an application can interact with; Actions the application can perform on these Objects; Events, which an Object can send to an application asynchronously; and Parameters associated with these Actions and Events.</p>
<p id="rfc.section.2.p.2">The following notations, which can be combined, are used in this document:</p>
<p></p>

<ul><li>An Action creates an Object:</li></ul>
<pre>
Object := Action()
</pre>
<p></p>

<ul><li>An Action creates an array of Objects:</li></ul>
<pre>
[]Object := Action()
</pre>
<p></p>

<ul><li>An Action is performed on an Object:</li></ul>
<pre>
Object.Action()
</pre>
<p></p>

<ul><li>An Object sends an Event:</li></ul>
<pre>
Object -&gt; Event&lt;&gt;
</pre>
<p></p>

<ul><li>An Action takes a set of Parameters; an Event contains a set of Parameters:</li></ul>
<pre>
Action(parameter, parameter, ...) / Event&lt;parameter, parameter, ...&gt;
</pre>
<p id="rfc.section.2.p.8">Actions associated with no Object are Actions on the abstract interface itself; they are equivalent to Actions on a per-application global context.</p>
<p id="rfc.section.2.p.9">How these abstract concepts map into concrete implementations of this API in a given language on a given platform is largely dependent on the features of the language and the platform. Actions could be implemented as functions or method calls, for instance, and Events could be implemented via callback passing or other asynchronous calling conventions. The method for registering callbacks and handlers is left as an implementation detail, with the caveat that the interface for receiving Messages must require the application to invoke the Connection.Receive() Action once per Message to be received (see <a href="#receiving" class="xref">Section 8</a>).</p>
<p id="rfc.section.2.p.10">This specification treats Events and errors similarly. Errors, just as any other Events, may occur asynchronously in network applications. However, it is recommended that implementations of this interface also return errors immediately, according to the error handling idioms of the implementation platform, for errors which can be immediately detected, such as inconsistency in Transport Properties.</p>
<p id="rfc.section.2.p.11">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#principles" id="principles">Interface Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">The design of the interface specified in this document is based on a set of princples, themselves an elaboration on the architectural design principles defined in <a href="#I-D.ietf-taps-arch" class="xref">[I-D.ietf-taps-arch]</a>. The interface defined in this document provides:</p>
<p></p>

<ul>
<li>A single interface to a variety of transport protocols to be used in a variety of application design patterns, independent of the properties of the application and the Protocol Stacks that will be used at runtime, such that  all common specialized features of these protocol stacks are made available to the application as necessary in a transport-independent way, to enable applications written to a single API to make use of transport protocols in terms of the features they provide;</li>
<li>Explicit support for security properties as first-order transport features, and for long-term caching of cryptographic identities and parameters for associations among endpoints;</li>
<li>Asynchronous Connection establishment, transmission, and reception, allowing most application interactions with the transport layer to be Event-driven, in line with developments in modern platforms and programming languages;</li>
<li>Explicit support for multistreaming and multipath transport protocols, and the grouping of related Connections into Connection Groups through cloning of Connections, to allow applications to take full advantage of new transport protocols supporting these features; and</li>
<li>Atomic transmission of data, using application-assisted framing and deframing where the underlying transport does not provide these.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#api-summary" id="api-summary">API Summary</a>
</h1>
<p id="rfc.section.4.p.1">The Transport Services Interface is the basic common abstract application programming interface to the Transport Services Architecture defined in <a href="#I-D.ietf-taps-arch" class="xref">[I-D.ietf-taps-arch]</a>. An application primarily interacts with this interface through two Objects, Preconnections and Connections. A Preconnection represents a set of properties and constraints on the selection and configuration of paths and protocols to establish a Connection with a remote endpoint. A Connection represents a transport Protocol Stack on which data can be sent to and/or received from a remote endpoint (i.e., depending on the kind of transport, connections can be bi-directional or unidirectional). Connections can be created from Preconnections in three ways: by initiating the Preconnection (i.e., actively opening, as in a client), through listening on the Preconnection (i.e., passively opening, as in a server), or rendezvousing on the Preconnection (i.e. peer to peer establishment).</p>
<p id="rfc.section.4.p.2">Once a Connection is established, data can be sent on it in the form of Messages. The interface supports the preservation of message boundaries both via explicit Protocol Stack support, and via application support through a deframing callback which finds message boundaries in a stream. Messages are received asynchronously through a callback registered by the application.  Errors and other notifications also happen asynchronously on the Connection.</p>
<p id="rfc.section.4.p.3">In the following sections, we describe the details of application interaction with Objects through Actions and Events in each phase of a Connection, following the phases described in <a href="#I-D.ietf-taps-arch" class="xref">[I-D.ietf-taps-arch]</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#pre-establishment-phase" id="pre-establishment-phase">Pre-Establishment Phase</a>
</h1>
<p id="rfc.section.5.p.1">The pre-establishment phase allows applications to specify properties for the Connections they are about to make, or to query the API about potential connections they could make.</p>
<p id="rfc.section.5.p.2">A Preconnection Object represents a potential Connection. It has state that describes properties of a Connection that might exist in the future.  This state comprises Local Endpoint and Remote Endpoint Objects that denote the endpoints of the potential Connection (see <a href="#endpointspec" class="xref">Section 5.1</a>), the transport properties (see <a href="#transport-props" class="xref">Section 12</a>), and the security parameters (see <a href="#security-parameters" class="xref">Section 5.3</a>):</p>
<pre>
   Preconnection := NewPreconnection(LocalEndpoint,
                                     RemoteEndpoint,
                                     TransportProperties,
                                     SecurityParams)
</pre>
<p id="rfc.section.5.p.3">The Local Endpoint MUST be specified if the Preconnection is used to Listen() for incoming Connections, but is OPTIONAL if it is used to Initiate() connections. The Remote Endpoint MUST be specified if the Preconnection is used to Initiate() Connections, but is OPTIONAL if it is used to Listen() for incoming Connections.  The Local Endpoint and the Remote Endpoint MUST both be specified if a peer-to-peer Rendezvous is to occur based on the Preconnection.</p>
<p id="rfc.section.5.p.4">Framers (see <a href="#send-framing" class="xref">Section 7.7</a>) and deframers (see <a href="#receive-framing" class="xref">Section 8.4</a>), if necessary, should be bound to the Preconnection during pre-establishment.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#endpointspec" id="endpointspec">Specifying Endpoints</a>
</h1>
<p id="rfc.section.5.1.p.1">The transport services API uses the Local Endpoint and Remote Endpoint types to refer to the endpoints of a transport connection.  Subtypes of these represent various different types of endpoint identifiers, such as IP addresses, DNS names, and interface names, as well as port numbers and service names.</p>
<pre>
RemoteSpecifier := NewRemoteEndpoint()
RemoteSpecifier.WithHostname("example.com")
RemoteSpecifier.WithService("https")
</pre>
<pre>
RemoteSpecifier := NewRemoteEndpoint()
RemoteSpecifier.WithIPv6Address(2001:db8:4920:e29d:a420:7461:7073:0a)
RemoteSpecifier.WithPort(443)
</pre>
<pre>
RemoteSpecifier := NewRemoteEndpoint()
RemoteSpecifier.WithIPv4Address(192.0.2.21)
RemoteSpecifier.WithPort(443)
</pre>
<pre>
LocalSpecifier := NewLocalEndpoint()
LocalSpecifier.WithInterface("en0")
LocalSpecifier.WithPort(443)
</pre>
<pre>
LocalSpecifier := NewLocalEndpoint()
LocalSpecifier.WithStunServer(address, port, credentials)
</pre>
<p id="rfc.section.5.1.p.2">Implementations may also support additional endpoint representations and provide a single NewEndpoint() call that takes different endpoint representations.</p>
<p id="rfc.section.5.1.p.3">Multiple endpoint identifiers can be specified for each Local Endpoint and Remote Endpoint.  For example, a Local Endpoint could be configured with two interface names, or a Remote Endpoint could be specified via both IPv4 and IPv6 addresses. These multiple identifiers refer to the same transport endpoint.</p>
<p id="rfc.section.5.1.p.4">The transport services API resolves names internally, when the Initiate(), Listen(), or Rendezvous() method is called establish a Connection. The API explicitly does not require the application to resolve names, though there is a tradeoff between early and late binding of addresses to names. Early binding allows the API implementation to reduce connection setup latency, at the cost of potentially limited scope for alternate path discovery during Connection establishment, as well as potential additional information leakage about application interest when used with a resolution method (such as DNS without TLS) which does not protect query confidentiality.</p>
<p id="rfc.section.5.1.p.5">The Resolve() action on Preconnection can be used by the application to force early binding when required, for example with some Network Address Translator (NAT) traversal protocols (see <a href="#rendezvous" class="xref">Section 6.3</a>).</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#connection-props" id="connection-props">Specifying Transport Properties</a>
</h1>
<p id="rfc.section.5.2.p.1">A Preconnection Object holds properties reflecting the application&#8217;s requirements and preferences for the transport. These include Selection Properties (Protocol and Path Selection Properties), as well as Generic and Specific Protocol Properties for configuration of the detailed operation of the selected Protocol Stacks.</p>
<p id="rfc.section.5.2.p.2">The protocol(s) and path(s) selected as candidates during Connection establishment are determined by a set of properties. Since there could be paths over which some transport protocols are unable to operate, or remote endpoints that support only specific network addresses or transports, transport protocol selection is necessarily tied to path selection. This may involve choosing between multiple local interfaces that are connected to different access networks.</p>
<p id="rfc.section.5.2.p.3">Internally, the transport system will first exclude all protocols and paths that match a Prohibit, then exclude all protocols and paths that do not match a Require, then sort candidates according to Preferred properties, and then use Avoided properties as a tiebreaker. In case of conflicts between Protocol and Path Selection Properties, Path Selection Properties take precedence. For example, if an application indicates a preference for a specific path, but also a preference for a protocol not available on this path, the transport system will try the path first, so the Protocol Selection Property might not have an effect.</p>
<p id="rfc.section.5.2.p.4">All Transport Properties used in the pre-establishment phase are collected in a TransportProperties Object that is passed to the Preconnection Object.</p>
<pre>
TransportProperties := NewTransportProperties()
</pre>
<p id="rfc.section.5.2.p.5">The Individual properties are then added to the TransportProperties Object.</p>
<pre>
TransportProperties.Add(property, value)
</pre>
<p id="rfc.section.5.2.p.6">Transport Properties of Preference Type, see <a href="#transport-props-preference" class="xref">Section 12.1.4</a>, can use special calls to add a Property with a specific preference level, i.e, <samp>TransportProperties.Add('some preference', avoid)</samp> is equivalent to <samp>TransportProperties.Avoid('some preference')</samp></p>
<pre>
TransportProperties.Require(property)
TransportProperties.Prefer(property)
TransportProperties.Ignore(property)
TransportProperties.Avoid(property)
TransportProperties.Prohibit(property)
</pre>
<p id="rfc.section.5.2.p.7">For an existing Connection, the Transport Properties can be queried any time by using the following call on the Connection Object:</p>
<pre>
TransportProperties := Connection.GetTransportProperties()
</pre>
<p><a href="#transport-props" class="xref">Section 12</a> provides a list of Transport Properties.</p>
<p id="rfc.section.5.2.p.9">Note that many properties are only considered for Connection establishment and can not be changed after a Connection is established; however, they can be queried. See <a href="#introspection" class="xref">Section 9</a>.</p>
<p id="rfc.section.5.2.p.10">A Connection gets its Transport Properties either by being explicitly configured via a Preconnection, by configuration after establishment, or by inheriting them from an antecedent via cloning; see <a href="#groups" class="xref">Section 6.4</a> for more.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#security-parameters" id="security-parameters">Specifying Security Parameters and Callbacks</a>
</h1>
<p id="rfc.section.5.3.p.1">Most security parameters, e.g., TLS ciphersuites, local identity and private key, etc., may be configured statically. Others are dynamically configured during connection establishment.  Thus, we partition security parameters and callbacks based on their place in the lifetime of connection establishment. Similar to Transport Properties, both parameters and callbacks are inherited during cloning (see <a href="#groups" class="xref">Section 6.4</a>).</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#pre-connection-parameters" id="pre-connection-parameters">Pre-Connection Parameters</a>
</h1>
<p id="rfc.section.5.3.1.p.1">Common parameters such as TLS ciphersuites are known to implementations. Clients should use common safe defaults for these values whenever possible. However, as discussed in <a href="#I-D.ietf-taps-transport-security" class="xref">[I-D.ietf-taps-transport-security]</a>, many transport security protocols require specific security parameters and constraints from the client at the time of configuration and actively during a handshake. These configuration parameters are created as follows:</p>
<pre>
SecurityParameters := NewSecurityParameters()
</pre>
<p id="rfc.section.5.3.1.p.2">Security configuration parameters and sample usage follow:</p>
<p></p>

<ul><li>Local identity and private keys: Used to perform private key operations and prove one&#8217;s identity to the Remote Endpoint. (Note, if private keys are not available, e.g., since they are stored in hardware security modules (HSMs), handshake callbacks must be used. See below for details.)</li></ul>
<pre>
SecurityParameters.AddIdentity(identity)
SecurityParameters.AddPrivateKey(privateKey, publicKey)
</pre>
<p></p>

<ul><li>Supported algorithms: Used to restrict what parameters are used by underlying transport security protocols.  When not specified, these algorithms should default to known and safe defaults for the system. Parameters include: ciphersuites, supported groups, and signature algorithms.</li></ul>
<pre>
SecurityParameters.AddSupportedGroup(secp256k1)
SecurityParameters.AddCiphersuite(TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256)
SecurityParameters.AddSignatureAlgorithm(ed25519)
</pre>
<p></p>

<ul><li>Session cache management: Used to tune cache capacity, lifetime, re-use, and eviction policies, e.g., LRU or FIFO. Constants and policies for these interfaces are implementation-specific.</li></ul>
<pre>
SecurityParameters.SetSessionCacheCapacity(MAX_CACHE_ELEMENTS)
SecurityParameters.SetSessionCacheLifetime(SECONDS_PER_DAY)
SecurityParameters.SetSessionCachePolicy(CachePolicyOneTimeUse)
</pre>
<p></p>

<ul><li>Pre-Shared Key import: Used to install pre-shared keying material established out-of-band. Each pre-shared keying material is associated with some identity that typically identifies its use or has some protocol-specific meaning to the Remote Endpoint.</li></ul>
<pre>
SecurityParameters.AddPreSharedKey(key, identity)
</pre>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#connection-establishment-callbacks" id="connection-establishment-callbacks">Connection Establishment Callbacks</a>
</h1>
<p id="rfc.section.5.3.2.p.1">Security decisions, especially pertaining to trust, are not static. Once configured, parameters may also be supplied during connection establishment. These are best handled as client-provided callbacks. Security handshake callbacks that may be invoked during connection establishment include:</p>
<p></p>

<ul><li>Trust verification callback: Invoked when a Remote Endpoint&#8217;s trust must be validated before the handshake protocol can proceed.</li></ul>
<pre>
TrustCallback := NewCallback({
  // Handle trust, return the result
})
SecurityParameters.SetTrustVerificationCallback(trustCallback)
</pre>
<p></p>

<ul><li>Identity challenge callback: Invoked when a private key operation is required, e.g., when local authentication is requested by a remote.</li></ul>
<pre>
ChallengeCallback := NewCallback({
  // Handle challenge
})
SecurityParameters.SetIdentityChallengeCallback(challengeCallback)
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#establishing-connections" id="establishing-connections">Establishing Connections</a>
</h1>
<p id="rfc.section.6.p.1">Before a Connection can be used for data transfer, it must be established.  Establishment ends the pre-establishment phase; all transport properties and cryptographic parameter specification must be complete before establishment, as these will be used to select candidate Paths and Protocol Stacks for the Connection. Establishment may be active, using the Initiate() Action; passive, using the Listen() Action; or simultaneous for peer-to-peer, using the Rendezvous() Action. These Actions are described in the subsections below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#initiate" id="initiate">Active Open: Initiate</a>
</h1>
<p id="rfc.section.6.1.p.1">Active open is the Action of establishing a Connection to a Remote Endpoint presumed to be listening for incoming Connection requests. Active open is used by clients in client-server interactions. Active open is supported by this interface through the Initiate Action:</p>
<pre>
Connection := Preconnection.Initiate()
</pre>
<p id="rfc.section.6.1.p.2">Before calling Initiate, the caller must have populated a Preconnection Object with a Remote Endpoint specifier, optionally a Local Endpoint specifier (if not specified, the system will attempt to determine a suitable Local Endpoint), as well as all properties necessary for candidate selection.</p>
<p id="rfc.section.6.1.p.3">The Initiate() Action consumes the Preconnection. Once Initiate() has been called, no further properties may be added to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<p id="rfc.section.6.1.p.4">Once Initiate is called, the candidate Protocol Stack(s) may cause one or more candidate transport-layer connections to be created to the specified remote endpoint. The caller may immediately begin sending Messages on the Connection (see <a href="#sending" class="xref">Section 7</a>) after calling Initate(); note that any idempotent data sent while the Connection is being established may be sent multiple times or on multiple candidates.</p>
<p id="rfc.section.6.1.p.5">The following Events may be sent by the Connection after Initiate() is called:</p>
<pre>
Connection -&gt; Ready&lt;&gt;
</pre>
<p id="rfc.section.6.1.p.6">The Ready Event occurs after Initiate has established a transport-layer connection on at least one usable candidate Protocol Stack over at least one candidate Path. No Receive Events (see <a href="#receiving" class="xref">Section 8</a>) will occur before the Ready Event for Connections established using Initiate.</p>
<pre>
Connection -&gt; InitiateError&lt;&gt;
</pre>
<p id="rfc.section.6.1.p.7">An InitiateError occurs either when the set of transport properties and cryptographic parameters cannot be fulfilled on a Connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty) or reconciled with the local and/or remote endpoints; when the remote specifier cannot be resolved; or when no transport-layer connection can be established to the remote endpoint (e.g. because the remote endpoint is not accepting connections, or the application is prohibited from opening a Connection by the operating system).</p>
<p id="rfc.section.6.1.p.8">See also <a href="#initiate-and-send" class="xref">Section 7.6</a> to combine Connection establishment and transmission of the first message in a single action.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#listen" id="listen">Passive Open: Listen</a>
</h1>
<p id="rfc.section.6.2.p.1">Passive open is the Action of waiting for Connections from remote endpoints, commonly used by servers in client-server interactions. Passive open is supported by this interface through the Listen Action:</p>
<pre>
Preconnection.Listen()
</pre>
<p id="rfc.section.6.2.p.2">Before calling Listen, the caller must have initialized the Preconnection during the pre-establishment phase with a Local Endpoint specifier, as well as all properties necessary for Protocol Stack selection. A Remote Endpoint may optionally be specified, to constrain what Connections are accepted.  The Listen() Action consumes the Preconnection. Once Listen() has been called, no further properties may be added to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<p id="rfc.section.6.2.p.3">Listening continues until the global context shuts down, or until the Stop action is performed on the same Preconnection:</p>
<pre>
Preconnection.Stop()
</pre>
<p id="rfc.section.6.2.p.4">After Stop() is called, the preconnection can be disposed of.</p>
<pre>
Preconnection -&gt; ConnectionReceived&lt;Connection&gt;
</pre>
<p id="rfc.section.6.2.p.5">The ConnectionReceived Event occurs when a Remote Endpoint has established a transport-layer connection to this Preconnection (for Connection-oriented transport protocols), or when the first Message has been received from the Remote Endpoint (for Connectionless protocols), causing a new Connection to be created. The resulting Connection is contained within the ConnectionReceived event, and is ready to use as soon as it is passed to the application via the event.</p>
<pre>
Preconnection -&gt; ListenError&lt;&gt;
</pre>
<p id="rfc.section.6.2.p.6">A ListenError occurs either when the Preconnection cannot be fulfilled for listening, when the Local Endpoint (or Remote Endpoint, if specified) cannot be resolved, or when the application is prohibited from listening by policy.</p>
<pre>
Preconnection -&gt; Stopped&lt;&gt;
</pre>
<p id="rfc.section.6.2.p.7">A Stopped event occurs after the Preconnection has stopped listening.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#rendezvous" id="rendezvous">Peer-to-Peer Establishment: Rendezvous</a>
</h1>
<p id="rfc.section.6.3.p.1">Simultaneous peer-to-peer Connection establishment is supported by the Rendezvous() Action:</p>
<pre>
Preconnection.Rendezvous()
</pre>
<p id="rfc.section.6.3.p.2">The Preconnection Object must be specified with both a Local Endpoint and a Remote Endpoint, and also the transport properties and security parameters needed for Protocol Stack selection.</p>
<p id="rfc.section.6.3.p.3">The Rendezvous() Action causes the Preconnection to listen on the Local Endpoint for an incoming Connection from the Remote Endpoint, while simultaneously trying to establish a Connection from the Local Endpoint to the Remote Endpoint. This corresponds to a TCP simultaneous open, for example.</p>
<p id="rfc.section.6.3.p.4">The Rendezvous() Action consumes the Preconnection. Once Rendezvous() has been called, no further properties may be added to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<pre>
Preconnection -&gt; RendezvousDone&lt;Connection&gt;
</pre>
<p id="rfc.section.6.3.p.5">The RendezvousDone&lt;&gt; Event occurs when a Connection is established with the Remote Endpoint. For Connection-oriented transports, this occurs when the transport-layer connection is established; for Connectionless transports, it occurs when the first Message is received from the Remote Endpoint. The resulting Connection is contained within the RendezvousDone&lt;&gt; Event, and is ready to use as soon as it is passed to the application via the Event.</p>
<pre>
Preconnection -&gt; RendezvousError&lt;msgRef, error&gt;
</pre>
<p id="rfc.section.6.3.p.6">An RendezvousError occurs either when the Preconnection cannot be fulfilled for listening, when the Local Endpoint or Remote Endpoint cannot be resolved, when no transport-layer connection can be established to the Remote Endpoint, or when the application is prohibited from rendezvous by policy.</p>
<p id="rfc.section.6.3.p.7">When using some NAT traversal protocols, e.g., Interactive Connectivity Establishment (ICE) <a href="#RFC5245" class="xref">[RFC5245]</a>, it is expected that the Local Endpoint will be configured with some method of discovering NAT bindings, e.g., a Session Traversal Utilities for NAT (STUN) server. In this case, the Local Endpoint may resolve to a mixture of local and server reflexive addresses. The Resolve() action on the Preconnection can be used to discover these bindings:</p>
<pre>
[]Preconnection := Preconnection.Resolve()
</pre>
<p id="rfc.section.6.3.p.8">The Resolve() call returns a list of Preconnection Objects, that represent the concrete addresses, local and server reflexive, on which a Rendezvous() for the Preconnection will listen for incoming Connections. These resolved Preconnections will share all other Properties with the Preconnection from which they are derived, though some Properties may be made more-specific by the resolution process. This list can be passed to a peer via a signalling protocol, such as SIP <a href="#RFC3261" class="xref">[RFC3261]</a> or WebRTC <a href="#RFC7478" class="xref">[RFC7478]</a>, to configure the remote.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#groups" id="groups">Connection Groups</a>
</h1>
<p id="rfc.section.6.4.p.1">Groups of Connections can be created using the Clone Action:</p>
<pre>
Connection := Connection.Clone()
</pre>
<p id="rfc.section.6.4.p.2">Calling Clone on a Connection yields a group of two Connections: the parent Connection on which Clone was called, and the resulting cloned Connection. These connections are &#8220;entangled&#8221; with each other, and become part of a Connection Group. Calling Clone on any of these two Connections adds a third Connection to the Connection Group, and so on. Connections in a Connection Group share all Protocol Properties that are not applicable to a Message.</p>
<p id="rfc.section.6.4.p.3">Changing one of these Protocol Properties on one Connection in the group changes it for all others. Per-Message Protocol Properties, however, are not entangled.  For example, changing &#8220;Timeout for aborting Connection&#8221; (see <a href="#conn-timeout" class="xref">Section 9.1.6</a>) on one Connection in a group will automatically change this Protocol Property for all Connections in the group in the same way. However, changing &#8220;Lifetime&#8221; (see <a href="#msg-lifetime" class="xref">Section 7.3.1</a>) of a Message will only affect a single Message on a single Connection, entangled or not.</p>
<p id="rfc.section.6.4.p.4">If the underlying protocol supports multi-streaming, it is natural to use this functionality to implement Clone. In that case, entangled Connections are multiplexed together, giving them similar treatment not only inside endpoints but also across the end-to-end Internet path.</p>
<p id="rfc.section.6.4.p.5">If the underlying Protocol Stack does not support cloning, or cannot create a new stream on the given Connection, then attempts to clone a connection will result in a CloneError:</p>
<pre>
Connection -&gt; CloneError&lt;&gt;
</pre>
<p id="rfc.section.6.4.p.6">The Protocol Property &#8220;Niceness&#8221; operates on entangled Connections as in <a href="#msg-niceness" class="xref">Section 7.3.2</a>: when allocating available network capacity among Connections in a Connection Group, sends on Connections with higher Niceness values will be prioritized over sends on Connections with lower Niceness values. An ideal transport system implementation would assign each Connection the capacity share (M-N) x C / M, where N is the Connection&#8217;s Niceness value, M is the maximum Niceness value used by all Connections in the group and C is the total available capacity. However, the Niceness setting is purely advisory, and no guarantees are given about the way capacity is shared.  Each implementation is free to implement a way to share capacity that it sees fit.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sending" id="sending">Sending Data</a>
</h1>
<p id="rfc.section.7.p.1">Once a Connection has been established, it can be used for sending data. Data is sent in terms of Messages, which allow the application to communicate the boundaries of the data being transferred. By default, Send enqueues a complete Message, and takes optional per-Message properties (see <a href="#send-basic" class="xref">Section 7.1</a>). All Send actions are asynchronous, and deliver events (see <a href="#send-events" class="xref">Section 7.2</a>). Sending partial Messages for streaming large data is also supported (see <a href="#send-partial" class="xref">Section 7.4</a>).</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#send-basic" id="send-basic">Basic Sending</a>
</h1>
<p id="rfc.section.7.1.p.1">The most basic form of sending on a connection involves enqueuing a single Data block as a complete Message, with default Message Properties. Message data is created as an array of octets, and the resulting object contains both the byte array and the length of the array.</p>
<pre>
messageData := "hello".octets()
Connection.Send(messageData)
</pre>
<p id="rfc.section.7.1.p.2">The interpretation of a Message to be sent is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport properties.  For example, a Message may be a single datagram for UDP Connections; or an HTTP Request for HTTP Connections.</p>
<p id="rfc.section.7.1.p.3">Some transport protocols can deliver arbitrarily sized Messages, but other protocols constrain the maximum Message size. Applications can query the protocol property Maximum Message Size on Send to determine the maximum size allowed for a single Message. If a Message is too large to fit in the Maximum Message Size for the Connection, the Send will fail with a SendError event (<a href="#send-error" class="xref">Section 7.2.3</a>). For example, it is invalid to send a Message over a UDP connection that is larger than the available datagram sending size.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#send-events" id="send-events">Send Events</a>
</h1>
<p id="rfc.section.7.2.p.1">Like all Actions in this interface, the Send Action is asynchronous. There are several events that can be delivered in response to Sending a Message.</p>
<p id="rfc.section.7.2.p.2">Note that if partial Sends are used (<a href="#send-partial" class="xref">Section 7.4</a>), there will still be exactly one Send Event delivered for each call to Send. For example, if a Message expired while two requests to Send data for that Message are outstanding, there will be two Expired events delivered.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#sent" id="sent">Sent</a>
</h1>
<pre>
Connection -&gt; Sent&lt;msgRef&gt;
</pre>
<p id="rfc.section.7.2.1.p.1">The Sent Event occurs when a previous Send Action has completed, i.e., when the data derived from the Message has been passed down or through the underlying Protocol Stack and is no longer the responsibility of the implementation of this interface. The exact disposition of the Message (i.e., whether it has actually been transmitted, moved into a buffer on the network interface, moved into a kernel buffer, and so on) when the Sent Event occurs is implementation-specific. The Sent Event contains an implementation-specific reference to the Message to which it applies.</p>
<p id="rfc.section.7.2.1.p.2">Sent Events allow an application to obtain an understanding of the amount of buffering it creates. That is, if an application calls the Send Action multiple times without waiting for a Sent Event, it has created more buffer inside the transport system than an application that always waits for the Sent Event before calling the next Send Action.</p>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> <a href="#expired" id="expired">Expired</a>
</h1>
<pre>
Connection -&gt; Expired&lt;msgRef&gt;
</pre>
<p id="rfc.section.7.2.2.p.1">The Expired Event occurs when a previous Send Action expired before completion; i.e. when the Message was not sent before its Lifetime (see <a href="#msg-lifetime" class="xref">Section 7.3.1</a>) expired. This is separate from SendError, as it is an expected behavior for partially reliable transports. The Expired Event contains an implementation-specific reference to the Message to which it applies.</p>
<h1 id="rfc.section.7.2.3">
<a href="#rfc.section.7.2.3">7.2.3.</a> <a href="#send-error" id="send-error">SendError</a>
</h1>
<pre>
Connection -&gt; SendError&lt;msgRef&gt;
</pre>
<p id="rfc.section.7.2.3.p.1">A SendError occurs when a Message could not be sent due to an error condition: an attempt to send a Message which is too large for the system and Protocol Stack to handle, some failure of the underlying Protocol Stack, or a set of Message Properties not consistent with the Connection&#8217;s transport properties. The SendError contains an implementation-specific reference to the Message to which it applies.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#message-props" id="message-props">Message Context Parameters</a>
</h1>
<p id="rfc.section.7.3.p.1">Applications may need to annotate the Messages they send with extra information to control how data is scheduled and processed by the transport protocols in the Connection. A messageContext object contains parameters for sending Messages, and can be passed to the Send Action. Some of these parameters are properties as defined in <a href="#transport-props" class="xref">Section 12</a>. Note that these properties are per-Message, not per-Send if partial Messages are sent (<a href="#send-partial" class="xref">Section 7.4</a>). All data blocks associated with a single Message share properties. For example, it would not make sense to have the beginning of a Message expire, but allow the end of a Message to still be sent.</p>
<pre>
messageData := "hello".octets()
messageContext := NewMessageContext()
messageContext.add(parameter, value)
Connection.Send(messageData, messageContext)
</pre>
<p id="rfc.section.7.3.p.2">The simpler form of Send that does not take any messageContext is equivalent to passing a default messageContext with not values added.</p>
<p id="rfc.section.7.3.p.3">Message Properties share a single namespace with Transport Properties (see <a href="#transport-props" class="xref">Section 12</a>). This allows the specification of per-Connection Protocol Properties that can be overridden on a per-Message basis.</p>
<p id="rfc.section.7.3.p.4">If an application wants to override Message Properties for a specific message, it can acquire an empty messageContext Object and add all desired Message Properties to that Object. It can then reuse the same messageContext Object for sending multiple Messages with the same properties.</p>
<p id="rfc.section.7.3.p.5">Parameters may be added to a messageContext object only before the context is used for sending. Once a messageContext has been used with a Send call, modifying any of its parameters is invalid.</p>
<p id="rfc.section.7.3.p.6">Message Properties may be inconsistent with the properties of the Protocol Stacks underlying the Connection on which a given Message is sent. For example, a Connection must provide reliability to allow setting an infinitie value for the lifetime property of a Message. Sending a Message with Message Properties inconsistent with the Selection Properties of the Connection yields an error.</p>
<p id="rfc.section.7.3.p.7">The following Message Context Parameters are supported:</p>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> <a href="#msg-lifetime" id="msg-lifetime">Lifetime</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
</dl>
<p id="rfc.section.7.3.1.p.2">Lifetime specifies how long a particular Message can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted. When a Message&#8217;s Lifetime is infinite, it must be transmitted reliably. The type and units of Lifetime are implementation-specific.</p>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> <a href="#msg-niceness" id="msg-niceness">Niceness</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (non-negative)</dd>
</dl>
<p id="rfc.section.7.3.2.p.2">This property represents an unbounded hierarchy of priorities.  It can specify the priority of a Message, relative to other Messages sent over the same Connection.</p>
<p id="rfc.section.7.3.2.p.3">A Message with Niceness 0 will yield to a Message with Niceness 1, which will yield to a Message with Niceness 2, and so on. Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.</p>
<p id="rfc.section.7.3.2.p.4">This encoding of the priority has a convenient property that the priority increases as both Niceness and Lifetime decrease.  [Michael: Can we remove this? It is weird because there is no mention of decreasing Lifetime being interpreted as a higher priority anywhere.]</p>
<h1 id="rfc.section.7.3.3">
<a href="#rfc.section.7.3.3">7.3.3.</a> <a href="#msg-ordered" id="msg-ordered">Ordered</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.7.3.3.p.2">If true, it specifies that the receiver-side transport protocol stack only deliver the Message to the receiving application after the previous ordered Message which was passed to the same Connection via the Send Action, when such a Message exists. If false, the Message may be delivered to the receiving application out of order.  This property is used for protocols that support preservation of data ordering, see <a href="#prop-ordering" class="xref">Section 12.3.5</a>, but allow out-of-order delivery for certain messages.</p>
<h1 id="rfc.section.7.3.4">
<a href="#rfc.section.7.3.4">7.3.4.</a> <a href="#msg-idempotent" id="msg-idempotent">Idempotent</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.7.3.4.p.2">If true, it specifies that a Message is safe to send to the remote endpoint more than once for a single Send Action. It is used to mark data safe for certain 0-RTT establishment techniques, where retransmission of the 0-RTT data may cause the remote application to receive the Message multiple times.</p>
<h1 id="rfc.section.7.3.5">
<a href="#rfc.section.7.3.5">7.3.5.</a> <a href="#final" id="final">Final</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.7.3.5.p.2">If true, this Message is the last one that the application will send on a Connection. This allows underlying protocols to indicate to the Remote Endpoint that the Connection has been effectively closed in the sending direction. For example, TCP-based Connections can send a FIN once a Message marked as Final has been completely sent, indicated by marking endOfMessage. Protocols that do not support signalling the end of a Connection in a given direction will ignore this property.</p>
<p id="rfc.section.7.3.5.p.3">Note that a Final Message must always be sorted to the end of a list of Messages.  The Final property overrides Niceness and any other property that would re-order Messages. If another Message is sent after a Message marked as Final has already been sent on a Connection, the Send Action for the new Message will cause a SendError Event.</p>
<h1 id="rfc.section.7.3.6">
<a href="#rfc.section.7.3.6">7.3.6.</a> <a href="#msg-checksum" id="msg-checksum">Corruption Protection Length</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (non-negative with -1 as special value)</dd>
</dl>
<p id="rfc.section.7.3.6.p.2">This property specifies the length of the section of the Message, starting from byte 0, that the application requires to be delivered without corruption due to lower layer errors. It is used to specify options for simple integrity protection via checksums. By default, the entire Message is protected by a checksum. A value of 0 means that no checksum is required, and a special value (e.g. -1) can be used to indicate the default. Only full coverage is guaranteed, any other requests are advisory.</p>
<h1 id="rfc.section.7.3.7">
<a href="#rfc.section.7.3.7">7.3.7.</a> <a href="#msg-reliable-message" id="msg-reliable-message">Reliable Data Transfer (Message)</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.7.3.7.p.2">This property specifies that a message should be sent in such a way that the transport protocol ensures all data is received on the other side without corruption. Changing the &#180;Reliable Data Transfer&#180; property on Messages is only possible if the Connection supports reliability.  When this is not the case, changing it will generate an error.</p>
<h1 id="rfc.section.7.3.8">
<a href="#rfc.section.7.3.8">7.3.8.</a> <a href="#send-profile" id="send-profile">Transmission Profile</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Enumeration</dd>
</dl>
<p id="rfc.section.7.3.8.p.2">This enumerated property specifies the application&#8217;s preferred tradeoffs for sending this Message; it is a per-Message override of the Capacity Profile protocol and path selection property (see <a href="#prop-cap-profile" class="xref">Section 12.3.19</a>).</p>
<p id="rfc.section.7.3.8.p.3">The following values are valid for Transmission Profile:</p>
<p></p>

<dl>
<dt>Default:</dt>
<dd style="margin-left: 8">No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when sending this message.</dd>
<dt>Low Latency:</dt>
<dd style="margin-left: 8">Response time (latency) should be optimized at the expense of efficiently using the available capacity when sending this message. This can be used by the system to disable the coalescing of multiple small Messages into larger packets (Nagle&#8217;s algorithm); to prefer immediate acknowledgment from the peer endpoint when supported by the underlying transport; to signal a preference for lower-latency, higher-loss treatment; and so on.</dd>
</dl>
<p id="rfc.section.7.3.8.p.5">[TODO: This is inconsistent with {prop-cap-profile}} - needs to be fixed]</p>
<h1 id="rfc.section.7.3.9">
<a href="#rfc.section.7.3.9">7.3.9.</a> <a href="#singular-transmission" id="singular-transmission">Singular Transmission</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.7.3.9.p.2">This property specifies that a message should be sent and received as a single packet without transport-layer segmentation or network-layer fragmentation.  Attempts to send a message with this property set with a size greater to the transport&#8217;s current estimate of its maximum transmission segment size will result in a <samp>SendError</samp>. When used with transports supporting this functionality and running over IP version 4, the Don&#8217;t Fragment bit will be set.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#send-partial" id="send-partial">Partial Sends</a>
</h1>
<p id="rfc.section.7.4.p.1">It is not always possible for an application to send all data associated with a Message in a single Send Action. The Message data may be too large for the application to hold in memory at one time, or the length of the Message may be unknown or unbounded.</p>
<p id="rfc.section.7.4.p.2">Partial Message sending is supported by passing an endOfMessage boolean parameter to the Send Action. This value is always true by default, and the simpler forms of Send are equivalent to passing true for endOfMessage.</p>
<p id="rfc.section.7.4.p.3">The following example sends a Message in two separate calls to Send.</p>
<pre>
messageContext := NewMessageContext()
messageContext.add(parameter, value)

messageData := "hel".octets()
endOfMessage := false
Connection.Send(messageData, messageContext, endOfMessage)

messageData := "lo".octets()
endOfMessage := true
Connection.Send(messageData, messageContext, endOfMessage)
</pre>
<p id="rfc.section.7.4.p.4">All messageData sent with the same messageContext object will be treated as belonging to the same Message, and will constitute an in-order series until the endOfMessage is marked.  Once the end of the Message is marked, the messageContext object may be re-used as a new Message with identical parameters.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#send-batching" id="send-batching">Batching Sends</a>
</h1>
<p id="rfc.section.7.5.p.1">In order to reduce the overhead of sending multiple small Messages on a Connection, the application may want to batch several Send actions together. This provides a hint to the system that the sending of these Messages should be coalesced when possible, and that sending any of the batched Messages may be delayed until the last Message in the batch is enqueued.</p>
<pre>
Connection.Batch(
    Connection.Send(messageData)
    Connection.Send(messageData)
)
</pre>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#initiate-and-send" id="initiate-and-send">Send on Active Open: InitiateWithIdempotentSend</a>
</h1>
<p id="rfc.section.7.6.p.1">For application-layer protocols where the Connection initiator also sends the first message, the InitiateWithIdempotentSend() action combines Connection initiation with a first Message sent, provided that message is idempotent.</p>
<p id="rfc.section.7.6.p.2">Without a message context (as in <a href="#send-basic" class="xref">Section 7.1</a>):</p>
<pre>
Connection := Preconnection.InitiateWithIdempotentSend(messageData)
</pre>
<p id="rfc.section.7.6.p.3">With a message context (as in <a href="#message-props" class="xref">Section 7.3</a>):</p>
<pre>
Connection := Preconnection.InitiateWithIdempotentSend(messageData, messageContext)
</pre>
<p id="rfc.section.7.6.p.4">The message passed to InitiateWithIdempotentSend() is, as suggested by the name, considered to be idempotent (see <a href="#msg-idempotent" class="xref">Section 7.3.4</a>) regardless of declared message properties or defaults. If protocol stacks supporting 0-RTT establishment with idempotent data are available on the Preconnection, then 0-RTT establishment may be used with the given message when establishing candidate connections. For a non-idemponent initial message, or when the selected stack(s) do not support 0-RTT establishment, InitiateWithIdempotentSend is identical to Initiate() followed by Send().</p>
<p id="rfc.section.7.6.p.5">Neither partial sends nor send batching are supported by InitiateWithIdempotentSend().</p>
<p id="rfc.section.7.6.p.6">The Events that may be sent after InitiateWithIdempotentSend() are equivalent to those that would be sent by an invocation of Initate() followed immediately by an invocation of Send(), with the caveat that a send failure that occurs because the Connection could not be established will not result in a SendError separate from the InitiateError signaling the failure of Connection establishment.</p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> <a href="#send-framing" id="send-framing">Sender-side Framing</a>
</h1>
<p id="rfc.section.7.7.p.1">Sender-side framing allows a caller to provide the interface with a function that takes a Message of an appropriate application-layer type and returns an array of octets, the on-the-wire representation of the Message to be handed down to the Protocol Stack. It consists of a Framer Object with a single Action, Frame. Since the Framer depends on the protocol used at the application layer, it is bound to the Preconnection during the pre-establishment phase:</p>
<pre>
Preconnection.FrameWith(Framer)

OctetArray := Framer.Frame(messageData)
</pre>
<p id="rfc.section.7.7.p.2">Sender-side framing is a convenience feature of the interface, for parity with receiver-side framing (see <a href="#receive-framing" class="xref">Section 8.4</a>).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#receiving" id="receiving">Receiving Data</a>
</h1>
<p id="rfc.section.8.p.1">Once a Connection is established, it can be used for receiving data. As with sending, data is received in terms of Messages. Receiving is an asynchronous operation, in which each call to Receive enqueues a request to receive new data from the connection. Once data has been received, or an error is encountered, an event will be delivered to complete the Receive request (see <a href="#receive-events" class="xref">Section 8.2</a>).</p>
<p id="rfc.section.8.p.2">As with sending, the type of the Message to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#enqueuing-receives" id="enqueuing-receives">Enqueuing Receives</a>
</h1>
<p id="rfc.section.8.1.p.1">Receive takes two parameters to specify the length of data that an application is willing to receive, both of which are optional and have default values if not specified.</p>
<pre>
Connection.Receive(minIncompleteLength, maxLength)
</pre>
<p id="rfc.section.8.1.p.2">By default, Receive will try to deliver complete Messages in a single event (<a href="#receive-complete" class="xref">Section 8.2.1</a>).</p>
<p id="rfc.section.8.1.p.3">The application can set a minIncompleteLength value to indicates the smallest partial Message data size in bytes that should be delivered in response to this Receive. By default, this value is infinite, which means that only complete Messages should be delivered (see <a href="#receive-partial" class="xref">Section 8.2.2</a> and <a href="#receive-framing" class="xref">Section 8.4</a> for more information on how this is accomplished).  If this value is set to some smaller value, the associated receive event will be triggered only when at least that many bytes are available, or the Message is complete with fewer bytes, or the system needs to free up memory. Applications should always check the length of the data delivered to the receive event and not assume it will be as long as minIncompleteLength in the case of shorter complete Messages or memory issues.</p>
<p id="rfc.section.8.1.p.4">The maxLength argument indicates the maximum size of a Message in bytes the application is currently prepared to receive. The default value for maxLength is infinite. If an incoming Message is larger than the minimum of this size and the maximum Message size on receive for the Connection&#8217;s Protocol Stack, it will be delivered via ReceivedPartial events (<a href="#receive-partial" class="xref">Section 8.2.2</a>).</p>
<p id="rfc.section.8.1.p.5">Note that maxLength does not guarantee that the application will receive that many bytes if they are available; the interface may return ReceivedPartial events with less data than maxLength according to implementation constraints.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#receive-events" id="receive-events">Receive Events</a>
</h1>
<p id="rfc.section.8.2.p.1">Each call to Receive will be paired with a single Receive Event, which can be a success or an error. This allows an application to provide backpressure to the transport stack when it is temporarily not ready to receive messages.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#receive-complete" id="receive-complete">Received</a>
</h1>
<pre>
Connection -&gt; Received&lt;messageData, messageContext&gt;
</pre>
<p id="rfc.section.8.2.1.p.1">A Received event indicates the delivery of a complete Message. It contains two objects, the received bytes as messageData, and the metadata and properties of the received Message as messageContext. See {#receive-context} for details about the received context.</p>
<p id="rfc.section.8.2.1.p.2">The messageData object provides access to the bytes that were received for this Message, along with the length of the byte array.</p>
<p id="rfc.section.8.2.1.p.3">See <a href="#receive-framing" class="xref">Section 8.4</a> for handling Message framing in situations where the Protocol Stack provides octet-stream transport only.</p>
<h1 id="rfc.section.8.2.2">
<a href="#rfc.section.8.2.2">8.2.2.</a> <a href="#receive-partial" id="receive-partial">ReceivedPartial</a>
</h1>
<pre>
Connection -&gt; ReceivedPartial&lt;messageData, messageContext, endOfMessage&gt;
</pre>
<p id="rfc.section.8.2.2.p.1">If a complete Message cannot be delivered in one event, one part of the Message may be delivered with a ReceivedPartial event. In order to continue to receive more of the same Message, the application must invoke Receive again.</p>
<p id="rfc.section.8.2.2.p.2">Multiple invocations of ReceivedPartial deliver data for the same Message by passing the same messageContext, until the endOfMessage flag is delivered or a ReceiveError occurs. All partial blocks of a single Message are delivered in order without gaps. This event does not support delivering discontiguous partial Messages.</p>
<p id="rfc.section.8.2.2.p.3">If the minIncompleteLength in the Receive request was set to be infinite (indicating a request to receive only complete Messages), the ReceivedPartial event may still be delivered if one of the following conditions is true:</p>
<p></p>

<ul>
<li>the underlying Protocol Stack supports message boundary preservation, and the size of the Message is larger than the buffers available for a single message;</li>
<li>the underlying Protocol Stack does not support message boundary preservation, and the deframer (see <a href="#receive-framing" class="xref">Section 8.4</a>) cannot determine the end of the message using the buffer space it has available; or</li>
<li>the underlying Protocol Stack does not support message boundary preservation, and no deframer was supplied by the application</li>
</ul>
<p id="rfc.section.8.2.2.p.5">Note that in the absence of message boundary preservation or deframing, all bytes received on the Connection will be represented as one large message of indeterminate length.</p>
<h1 id="rfc.section.8.2.3">
<a href="#rfc.section.8.2.3">8.2.3.</a> <a href="#receiveerror" id="receiveerror">ReceiveError</a>
</h1>
<pre>
Connection -&gt; ReceiveError&lt;messageContext&gt;
</pre>
<p id="rfc.section.8.2.3.p.1">A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or deframed, or when some other indication is received that reception has failed. Such conditions that irrevocably lead to the termination of the Connection are signaled using ConnectionError instead (see <a href="#termination" class="xref">Section 10</a>).</p>
<p id="rfc.section.8.2.3.p.2">The ReceiveError event passes an optional associated messageContext. This may indicate that a Message that was being partially received previously, but had not completed, encountered an error and will not be completed.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#receive-context" id="receive-context">Message Receive Context</a>
</h1>
<p id="rfc.section.8.3.p.1">Each Received Message Context may contain metadata from protocols in the Protocol Stack; which metadata is available is Protocol Stack dependent. The following metadata values are supported:</p>
<h1 id="rfc.section.8.3.1">
<a href="#rfc.section.8.3.1">8.3.1.</a> <a href="#receive-ecn" id="receive-ecn">ECN</a>
</h1>
<p id="rfc.section.8.3.1.p.1">When available, Message metadata carries the value of the Explicit Congestion Notification (ECN) field. This information can be used for logging and debugging purposes, and for building applications which need access to information about the transport internals for their own operation.</p>
<h1 id="rfc.section.8.3.2">
<a href="#rfc.section.8.3.2">8.3.2.</a> <a href="#receive-early" id="receive-early">Early Data</a>
</h1>
<p id="rfc.section.8.3.2.p.1">In some cases it may be valuable to know whether data was read as part of early data transfer (before connection establishment has finished). This is useful if applications need to treat early data separately, e.g., if early data has different security properties than data sent after connection establishment. In the case of TLS 1.3, client early data can be replayed maliciously (see <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>). Thus, receivers may wish to perform additional checks for early data to ensure it is idempotent or not replayed. If TLS 1.3 is available and the recipient Message was sent as part of early data, the corresponding metadata carries a flag indicating as such. If early data is enabled, applications should check this metadata field for Messages received during connection establishment and respond accordingly.</p>
<h1 id="rfc.section.8.3.3">
<a href="#rfc.section.8.3.3">8.3.3.</a> <a href="#receiving-final-messages" id="receiving-final-messages">Receiving Final Messages</a>
</h1>
<p id="rfc.section.8.3.3.p.1">The Received Message Context can indicate whether or not this Message is the Final Message on a Connection. For any Message that is marked as Final, the application can assume that there will be no more Messages received on the Connection once the Message has been completely delivered. This corresponds to the Final property that may be marked on a sent Message <a href="#send-final" class="xref">Section 12.3.1</a>.</p>
<p id="rfc.section.8.3.3.p.2">Some transport protocols and peers may not support signaling of the Final property.  Applications therefore should not rely on receiving a Message marked Final to know that the other endpoint is done sending on a connection.</p>
<p id="rfc.section.8.3.3.p.3">Any calls to Receive once the Final Message has been delivered will result in errors.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#receive-framing" id="receive-framing">Receiver-side De-framing over Stream Protocols</a>
</h1>
<p id="rfc.section.8.4.p.1">The Receive Event is intended to be fired once per application-layer Message sent by the remote endpoint; i.e., it is a desired property of this interface that a Send at one end of a Connection maps to exactly one Receive on the other end. This is possible with Protocol Stacks that provide message boundary preservation, but is not the case over Protocol Stacks that provide a simple octet stream transport.</p>
<p id="rfc.section.8.4.p.2">For preserving message boundaries over stream transports, this interface provides receiver-side de-framing. This facility is based on the observation that, since many of our current application protocols evolved over TCP, which does not provide message boundary preservation, and since many of these protocols require message boundaries to function, each application layer protocol has defined its own framing. A Deframer allows an application to push this de-framing down into the interface, in order to transform an octet stream into a sequence of Messages.</p>
<p id="rfc.section.8.4.p.3">Concretely, receiver-side de-framing allows a caller to provide the interface with a function that takes an octet stream, as provided by the underlying Protocol Stack, reads and returns a single Message of an appropriate type for the application and platform, and leaves the octet stream at the start of the next Message to deframe. It consists of a Deframer Object with a single Action, Deframe. Since the Deframer depends on the protocol used at the application layer, it is bound to the Preconnection during the pre-establishment phase:</p>
<pre>
Preconnection.DeframeWith(Deframer)

{messageData} := Deframer.Deframe(OctetStream, ...)
</pre>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#introspection" id="introspection">Managing Connections: Setting Properties and Obtaining Information</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#connection-properties" id="connection-properties">Connection Properties</a>
</h1>
<p id="rfc.section.9.1.p.1">The application can set per-connection Properties.  Certain Connection Properties may be read-only, on a protocol- and property-specific basis.  ~~~ Connection.SetProperty(property, value) ~~~</p>
<p id="rfc.section.9.1.p.2">At any point, the application can query Connection Properties.  ~~~ ConnectionProperties := Connection.GetProperties() ~~~</p>
<p id="rfc.section.9.1.p.3">Depending on the status of the connection, the queried Connection Properties will include different information:</p>
<p id="rfc.section.9.1.p.4">[TODO: turn this list into actual properties or move up into the explaining text]</p>
<p></p>

<ul>
<li>The connection state, which can be one of the following: Establishing, Established, Closing, or Closed.</li>
<li>Whether the connection can be used to send data. A connection can not be used for sending if the connection was created with the Selection Property &#8220;Direction of Communication&#8221; set to &#8220;unidirectional receive&#8221; or if a Message marked as &#8220;Final&#8221; was sent over this connection, see <a href="#send-final" class="xref">Section 12.3.1</a>.</li>
<li>Whether the connection can be used to receive data. A connection can not be used for reading if the connection was created with the Selection Property &#8220;Direction of Communication&#8221; set to &#8220;unidirectional send&#8221; or if a Message marked as &#8220;Final&#8221; was received, see <a href="#receiving-final-messages" class="xref">Section 8.3.3</a>. The latter is only supported by certain transport protocols, e.g., by TCP as half-closed connection.</li>
<li>For Connections that are Establishing: Transport Properties that the application specified on the Preconnection, see <a href="#connection-props" class="xref">Section 5.2</a>.</li>
<li>For Connections that are Established, Closing, or Closed: Transport Properties of the actual protocols that were selected and instantiated. These features correspond to the properties given in <a href="#transport-props" class="xref">Section 12</a> and include Selection Properties and Protocol Properties.  <ul>
<li>Selection Properties indicate whether or not the Connection has or offers a certain Selection Property. Note that the actually instantiated protocol stack may not match all Protocol Selection Properties that the application specified on the Preconnection. For example, a certain Protocol Selection Property that an application specified as Preferred may not actually be present in the chosen protocol stack because none of the currently available transport protocols had this feature.</li>
<li>Protocol Properties of the protocol stack in use (see <a href="#protocol-props" class="xref">Section 12.2.2</a>).</li>
</ul>
</li>
<li>For Connections that are Established, properties of the path(s) in use. These properties can be derived from the local provisioning domain <a href="#RFC7556" class="xref">[RFC7556]</a>, measurements by the Protocol Stack, or other sources.</li>
</ul>
<h1 id="rfc.section.9.1.1">
<a href="#rfc.section.9.1.1">9.1.1.</a> <a href="#conn-retrans-notify" id="conn-retrans-notify">Notification of excessive retransmissions</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.9.1.1.p.2">This property specifies whether an application considers it useful to be informed in case sent data was retransmitted more often than a certain threshold.  When set to true, the effect is twofold: The application may receive events in case excessive retransmissions.  In addition, the transport system considers this as a preference to use transports stacks that can provide this notification. This is not a strict requirement.  If set to false, no notification of excessive retransmissions will be sent and this transport feature is ignored for protocol selection.</p>
<p id="rfc.section.9.1.1.p.3">The default is to have this option.</p>
<h1 id="rfc.section.9.1.2">
<a href="#rfc.section.9.1.2">9.1.2.</a> <a href="#conn-excss-retransmit" id="conn-excss-retransmit">Retransmission threshold before excessive retransmission notification</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
</dl>
<p id="rfc.section.9.1.2.p.2">This property specifies after how many retransmissions to inform the application about &#8220;Excessive Retransmissions&#8221;.</p>
<h1 id="rfc.section.9.1.3">
<a href="#rfc.section.9.1.3">9.1.3.</a> <a href="#conn-soft-error" id="conn-soft-error">Notification of ICMP soft error message arrival</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Boolean</dd>
</dl>
<p id="rfc.section.9.1.3.p.2">This property specifies whether an application considers it useful to be informed when an ICMP error message arrives that does not force termination of a connection.  When set to true, received ICMP errors will be available as SoftErrors.  Note that even if a protocol supporting this property is selected, not all ICMP errors will necessarily be delivered, so applications cannot rely on receiving them.  Setting this option also implies a preference to prefer transports stacks that can provide this notification.  If not set, no events will be sent for ICMP soft error message and this transport feature is ignored for protocol selection.</p>
<p id="rfc.section.9.1.3.p.3">This property applies to Connections and Connection Groups.  The default is not to have this option.</p>
<h1 id="rfc.section.9.1.4">
<a href="#rfc.section.9.1.4">9.1.4.</a> <a href="#conn-recv-checksum" id="conn-recv-checksum">Required minimum coverage of the checksum for receiving</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
</dl>
<p id="rfc.section.9.1.4.p.2">This property specifies the part of the received data that needs to be covered by a checksum. It is given in Bytes. A value of 0 means that no checksum is required, and a special value (e.g., -1) indicates full checksum coverage.</p>
<h1 id="rfc.section.9.1.5">
<a href="#rfc.section.9.1.5">9.1.5.</a> <a href="#conn-niceness" id="conn-niceness">Niceness (Connection)</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
</dl>
<p id="rfc.section.9.1.5.p.2">This Property is a non-negative integer representing the relative inverse priority of this Connection relative to other Connections in the same Connection Group. It has no effect on Connections not part of a Connection Group. As noted in <a href="#groups" class="xref">Section 6.4</a>, this property is not entangled when Connections are cloned.</p>
<h1 id="rfc.section.9.1.6">
<a href="#rfc.section.9.1.6">9.1.6.</a> <a href="#conn-timeout" id="conn-timeout">Timeout for aborting Connection</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
</dl>
<p id="rfc.section.9.1.6.p.2">This property specifies how long to wait before aborting a Connection during establishment, or before deciding that a Connection has failed after establishment. It is given in seconds.</p>
<h1 id="rfc.section.9.1.7">
<a href="#rfc.section.9.1.7">9.1.7.</a> <a href="#conn-scheduler" id="conn-scheduler">Connection group transmission scheduler</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Enum</dd>
</dl>
<p id="rfc.section.9.1.7.p.2">This property specifies which scheduler should be used among Connections within a Connection Group, see <a href="#groups" class="xref">Section 6.4</a>. The set of schedulers can be taken from <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</p>
<h1 id="rfc.section.9.1.8">
<a href="#rfc.section.9.1.8">9.1.8.</a> <a href="#size-idempotent" id="size-idempotent">Maximum message size concurrent with Connection establishment</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (read only)</dd>
</dl>
<p id="rfc.section.9.1.8.p.2">This property represents the maximum Message size that can be sent before or during Connection establishment, see also <a href="#msg-idempotent" class="xref">Section 7.3.4</a>.  It is given in Bytes.</p>
<h1 id="rfc.section.9.1.9">
<a href="#rfc.section.9.1.9">9.1.9.</a> <a href="#conn-max-msg-notfrag" id="conn-max-msg-notfrag">Maximum Message size before fragmentation or segmentation</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (read only)</dd>
</dl>
<p id="rfc.section.9.1.9.p.2">This property, if applicable, represents the maximum Message size that can be sent without incurring network-layer fragmentation or transport layer segmentation at the sender.</p>
<h1 id="rfc.section.9.1.10">
<a href="#rfc.section.9.1.10">9.1.10.</a> <a href="#conn-max-msg-send" id="conn-max-msg-send">Maximum Message size on send</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (read only)</dd>
</dl>
<p id="rfc.section.9.1.10.p.2">This property represents the maximum Message size that can be sent.</p>
<h1 id="rfc.section.9.1.11">
<a href="#rfc.section.9.1.11">9.1.11.</a> <a href="#conn-max-msg-recv" id="conn-max-msg-recv">Maximum Message size on receive</a>
</h1>
<p></p>

<dl>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer (read only)</dd>
</dl>
<p id="rfc.section.9.1.11.p.2">This numeric property represents the maximum Message size that can be received.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#soft-errors" id="soft-errors">Soft Errors</a>
</h1>
<p id="rfc.section.9.2.p.1">Slightly different from &#8220;querying&#8221;, a SoftError Event can also occur, informing the application about the receipt of an ICMP error message related to the Connection. This will only happen if the underlying protocol stack supports access to soft errors; however, even if the underlying stack supports it, there is no guarantee that a soft error will be signaled.</p>
<pre>
Connection -&gt; SoftError&lt;&gt;
</pre>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.10.p.1">Close terminates a Connection after satisfying all the requirements that were specified regarding the delivery of Messages that the application has already given to the transport system. For example, if reliable delivery was requested for a Message handed over before calling Close, the transport system will ensure that this Message is indeed delivered. If the Remote Endpoint still has data to send, it cannot be received after this call.</p>
<pre>
Connection.Close()
</pre>
<p id="rfc.section.10.p.2">The Closed Event can inform the application that the Remote Endpoint has closed the Connection; however, there is no guarantee that a remote Close will indeed be signaled.</p>
<pre>
Connection -&gt; Closed&lt;&gt;
</pre>
<p id="rfc.section.10.p.3">Abort terminates a Connection without delivering remaining data:</p>
<pre>
Connection.Abort()
</pre>
<p id="rfc.section.10.p.4">A ConnectionError can inform the application that the other side has aborted the Connection; however, there is no guarantee that an Abort will indeed be signaled.</p>
<pre>
Connection -&gt; ConnectionError&lt;&gt;
</pre>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#connection-state-and-ordering-of-operations-and-events" id="connection-state-and-ordering-of-operations-and-events">Connection State and Ordering of Operations and Events</a>
</h1>
<p id="rfc.section.11.p.1">As this interface is designed to be independent of an implementation&#8217;s concurrency model, the details of how exactly actions are handled, and on which threads/callbacks events are dispatched, are implementation dependent.</p>
<p id="rfc.section.11.p.2">Each transition of connection state is associated with one of more events:</p>
<p></p>

<ul>
<li>Ready&lt;&gt; occurs when a Connection created with Initiate() or InitiateWithIdempotentData() transitions to Established state.</li>
<li>ConnectionReceived&lt;&gt; occurs when a Connection created with Listen() transitions to Established state.</li>
<li>RendezvousDone&lt;&gt; occurs when a Connection created with Rendezvous() transitions to Established state.</li>
<li>Closed&lt;&gt; occurs when a Connection transitions to Closed state without error.</li>
<li>InitiateError&lt;&gt; occurs when a Connection created with Initiate() transitions from Establishing state to Closed state due to an error.</li>
<li>ConnectionError&lt;&gt; occurs when a Connection transitions to Closed state due to an error in all other circumstances.</li>
</ul>
<p id="rfc.section.11.p.4">The interface provides the following guarantees about the ordering of operations:</p>
<p></p>

<ul>
<li>Sent&lt;&gt; events will occur on a Connection in the order in which the Messages were sent (i.e., delivered to the kernel or to the network interface, depending on implementation).</li>
<li>Received&lt;&gt; will never occur on a Connection before it is Established; i.e.  before a Ready&lt;&gt; event on that Connection, or a ConnectionReceived&lt;&gt; or RendezvousDone&lt;&gt; containing that Connection.</li>
<li>No events will occur on a Connection after it is Closed; i.e., after a Closed&lt;&gt; event, an InitiateError&lt;&gt; or ConnectionError&lt;&gt; on that connection. To ensure this ordering, Closed&lt;&gt; will not occur on a Connection while other events on the Connection are still locally outstanding (i.e., known to the interface and waiting to be dealt with by the application). ConnectionError&lt;&gt; may occur after Closed&lt;&gt;, but the interface must gracefully handle all cases where application ignores these errors.</li>
</ul>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#transport-props" id="transport-props">Transport Properties</a>
</h1>
<p id="rfc.section.12.p.1">Having discussed Selection Properties in <a href="#selection-props" class="xref">Section 12.2.1</a>, Connection Properties <a href="#connection-props" class="xref">Section 5.2</a>, and Message Properties (<a href="#message-props" class="xref">Section 7.3</a>), we now provide a complete overview of a transport system&#8217;s defined Transport Properties.</p>
<p id="rfc.section.12.p.2">Transport Properties are structured by the phase and object they are applied: - Selection Properties apply to Preconnections - see <a href="#selection-props" class="xref">Section 12.2.1</a> - Connections Properties apply to Connections - see <a href="#connection-props" class="xref">Section 5.2</a> - Messages Properties apply to Messages - see <a href="#message-props" class="xref">Section 7.3</a></p>
<p id="rfc.section.12.p.3">All Transport Properties are organized within a single namespace.  This enables setting them as defaults in earlier stages and querying them in later stages: - Connections Properties can be set on Preconnections - Message Properties can be set on Preconnections and Connections - The effect of Selection Properties can be queried on Connections and Messages.</p>
<p id="rfc.section.12.p.4">Note that it is possible for a set of specified Transport Properties to be internally inconsistent, or to be inconsistent with the later use of the API by the application. Application developers can reduce inconsistency by only using the most stringent preference levels when failure to meet the property would break the application&#8217;s functionality. For example, they can set the Selection Property &#8220;Reliable Data Transfer&#8221;, which is a core assumption of many application protocols, as Required. However, since this comes at the cost of flexibility of the transport system, such strict choices should be made with care.  Implementations of this interface should also raise any detected errors in configuration as early as possible, to help ensure that inconsistencies are caught early in the development process.</p>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#transport-props-types" id="transport-props-types">Transport Property Types</a>
</h1>
<p id="rfc.section.12.1.p.1">Each Transport Property takes a value of a property-specific type.</p>
<h1 id="rfc.section.12.1.1">
<a href="#rfc.section.12.1.1">12.1.1.</a> <a href="#transport-props-bool" id="transport-props-bool">Boolean</a>
</h1>
<p id="rfc.section.12.1.1.p.1">A boolean is a data type that can be either &#8220;true&#8221; or &#8220;false&#8221;.  Boolean transport properties should only be used for properties that can not be used in an optional way or to query the state of the transport implementation.  For optional features, especially in Selection Properties, the usage of the Preference type (see <a href="#transport-props-preference" class="xref">Section 12.1.4</a>) is preferred.</p>
<h1 id="rfc.section.12.1.2">
<a href="#rfc.section.12.1.2">12.1.2.</a> <a href="#transport-props-enum" id="transport-props-enum">Enumeration</a>
</h1>
<p id="rfc.section.12.1.2.p.1">Enumeration types are used for transport properties that can take one value out of a limited set of choices.  The representation is implementation dependent.</p>
<h1 id="rfc.section.12.1.3">
<a href="#rfc.section.12.1.3">12.1.3.</a> <a href="#transport-props-int" id="transport-props-int">Integer</a>
</h1>
<p id="rfc.section.12.1.3.p.1">Integer types are used to represent integer numbers.  The representation is implementation dependent.</p>
<h1 id="rfc.section.12.1.4">
<a href="#rfc.section.12.1.4">12.1.4.</a> <a href="#transport-props-preference" id="transport-props-preference">Preference</a>
</h1>
<p id="rfc.section.12.1.4.p.1">The Preference type is used in most Selection properties on a Preconnection object to constrain Path Selection and Protocol Selection.  It is a specific instance of the &#8220;Enum&#8221; type and has five different preference levels:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Preference</th>
<th class="left">Effect</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Require</td>
<td class="left">Select only protocols/paths providing the property, fail otherwise</td>
</tr>
<tr>
<td class="left">Prefer</td>
<td class="left">Prefer protocols/paths providing the property, proceed otherwise</td>
</tr>
<tr>
<td class="left">Ignore</td>
<td class="left">Cancel any default preference for this property</td>
</tr>
<tr>
<td class="left">Avoid</td>
<td class="left">Prefer protocols/paths not providing the property, proceed otherwise</td>
</tr>
<tr>
<td class="left">Prohibit</td>
<td class="left">Select only protocols/paths not providing the property, fail otherwise</td>
</tr>
</tbody>
</table>
<p id="rfc.section.12.1.4.p.2">When used on a Connection, this type becomes a (read-only) Boolean representing whether the selected transport supports the requested feature.</p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#transport-props-classes" id="transport-props-classes">Transport Property Classification</a>
</h1>
<p id="rfc.section.12.2.p.1">[TODO: This section is mostly obsolete due to our consensus on how to structure properties &#8211; double-check whether text needs to be moved and delete this section afterwards]</p>
<h1 id="rfc.section.12.2.1">
<a href="#rfc.section.12.2.1">12.2.1.</a> <a href="#selection-props" id="selection-props">Selection Properties</a>
</h1>
<p id="rfc.section.12.2.1.p.1">Selection Properties influence protocol and path selection.  Their value usually is or includes a Preference that constrains (in case of Require or Prohibit) or influences (Prefer, Ignore, Avoid) the selection of transport protocols and paths used.</p>
<p id="rfc.section.12.2.1.p.2">An implementation of this interface must provide sensible defaults for Selection Properties. The defaults given for each property below represent a configuration that can be implemented over TCP. An alternate set of default Protocol Selection Properties would represent a configuration that can be implemented over UDP.</p>
<p id="rfc.section.12.2.1.p.3">Protocol Selection Properties can only be set on Preconnections, see <a href="#connection-props" class="xref">Section 5.2</a>.  Path Selection Properties are usually used on Preconnections, but might also be used on messages to assist per-message path selection for multipath aware protocols.</p>
<h1 id="rfc.section.12.2.2">
<a href="#rfc.section.12.2.2">12.2.2.</a> <a href="#protocol-props" id="protocol-props">Protocol Properties</a>
</h1>
<p id="rfc.section.12.2.2.p.1">Protocol Properties represent the configuration of the selected Protocol Stacks backing a Connection. Some properties apply generically across multiple transport protocols, while other properties only apply to specific protocols.  Generic properties will be passed to the selected candidate Protocol Stack(s) to configure them before candidate Connection establishment.  The default settings of these properties will vary based on the specific protocols being used and the system&#8217;s configuration.</p>
<p id="rfc.section.12.2.2.p.2">Most Protocol Properties can be set on a Preconnection during pre-establishment to preconfigure Protocol Stacks during establishment.</p>
<p id="rfc.section.12.2.2.p.3">In order to specify Specific Protocol Properties, transport system implementations may offer applications to attach a set of options to the Preconnection Object, associated with a specific protocol. For example, an application could specify a set of TCP Options to use if and only if TCP is selected by the system. Such properties must not be assumed to apply across different protocols. Attempts to set specific protocol properties on a protocol stack not containing that specific protocol are simply ignored, and do not raise an error.</p>
<p id="rfc.section.12.2.2.p.4">Note that many protocol properties have a corresponding selection property which asks for a protocol providing a specific transport feature that is controlled by the protocol property.</p>
<h1 id="rfc.section.12.2.3">
<a href="#rfc.section.12.2.3">12.2.3.</a> <a href="#control-props" id="control-props">Message Properties</a>
</h1>
<p id="rfc.section.12.2.3.p.1">[TODO: Discuss]</p>
<p id="rfc.section.12.2.3.p.2">Control properties manage the local transport system behavior or request state changes in the local transport system. Depending on the protocols used, setting these properties might also influence the protocol state machine.  See <a href="#send-final" class="xref">Section 12.3.1</a> for an example.</p>
<h1 id="rfc.section.12.2.4">
<a href="#rfc.section.12.2.4">12.2.4.</a> <a href="#intents" id="intents">Intents</a>
</h1>
<p id="rfc.section.12.2.4.p.1">[TODO: Discuss]</p>
<p id="rfc.section.12.2.4.p.2">Intents are hints to the transport system that do not directly map to a single protocol/transport feature or behavior of the transport system, but express a presumed application behavior or generic application needs.</p>
<p id="rfc.section.12.2.4.p.3">The application can expect the transport system to take appropriate actions involving protocol selection, path selection and setting of protocol flags.  For example, if an application sets the &#8220;Capacity Profile&#8221; to &#8220;bulk&#8221; on a Preconnection, this will likely influence path selection, DSCP flags in the IP header as well as Niceness for multi-streaming connections.  When using Intents, the application must not expect consistent behavior across different environments, implementations or versions of the same implementation.</p>
<h1 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#mandatory-transport-properties" id="mandatory-transport-properties">Mandatory Transport Properties</a>
</h1>
<p id="rfc.section.12.3.p.1">The following properties are mandatory to implement in a transport system:</p>
<h1 id="rfc.section.12.3.1">
<a href="#rfc.section.12.3.1">12.3.1.</a> <a href="#send-final" id="send-final">Final</a>
</h1>
<p id="rfc.section.12.3.1.p.1">Boolean Message Property - see <a href="#final" class="xref">Section 7.3.5</a>.</p>
<h1 id="rfc.section.12.3.2">
<a href="#rfc.section.12.3.2">12.3.2.</a> <a href="#prop-reliable" id="prop-reliable">Reliable Data Transfer (Connection)</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.2.p.2">This property specifies whether the application needs to use a transport protocol that ensures that all data is received on the other side without corruption. This also entails being notified when a Connection is closed or aborted. The default is to enable Reliable Data Transfer.</p>
<h1 id="rfc.section.12.3.3">
<a href="#rfc.section.12.3.3">12.3.3.</a> <a href="#prop-partially-reliable" id="prop-partially-reliable">Configure per-Message reliability</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.3.p.2">This property specifies whether an application considers it useful to indicate its reliability requirements on a per-Message basis. This property applies to Connections and Connection Groups. The default is to not have this option.</p>
<h1 id="rfc.section.12.3.4">
<a href="#rfc.section.12.3.4">12.3.4.</a> <a href="#reliable-data-transfer-message" id="reliable-data-transfer-message">Reliable Data Transfer (Message)</a>
</h1>
<p id="rfc.section.12.3.4.p.1">Boolean Message Property - see <a href="#msg-reliable-message" class="xref">Section 7.3.7</a></p>
<h1 id="rfc.section.12.3.5">
<a href="#rfc.section.12.3.5">12.3.5.</a> <a href="#prop-ordering" id="prop-ordering">Preservation of data ordering</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.5.p.2">This property specifies whether the application wishes to use a transport protocol that can ensure that data is received by the application on the other end in the same order as it was sent. The default is to preserve data ordering.</p>
<h1 id="rfc.section.12.3.6">
<a href="#rfc.section.12.3.6">12.3.6.</a> <a href="#ordered" id="ordered">Ordered</a>
</h1>
<p id="rfc.section.12.3.6.p.1">Boolean Message Property - see <a href="#msg-ordered" class="xref">Section 7.3.3</a>.</p>
<h1 id="rfc.section.12.3.7">
<a href="#rfc.section.12.3.7">12.3.7.</a> <a href="#direction-of-communication" id="direction-of-communication">Direction of communication</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property, Control Property [TODO: Discuss]</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Enumeration</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.7.p.2">This property specifies whether an application wants to use the connection for sending and/or receiving data.  Possible values are:</p>
<p></p>

<dl>
<dt>Bidirectional (default):</dt>
<dd style="margin-left: 8">The connection must support sending and receiving data</dd>
<dt>unidirectional send:</dt>
<dd style="margin-left: 8">The connection must support sending data.</dd>
<dt>unidirectional receive:</dt>
<dd style="margin-left: 8">The connection must support receiving data</dd>
</dl>
<p id="rfc.section.12.3.7.p.4">In case a unidirectional connection is requested, but unidirectional connections are not supported by the transport protocol, the system should fall back to bidirectional transport.</p>
<h1 id="rfc.section.12.3.8">
<a href="#rfc.section.12.3.8">12.3.8.</a> <a href="#prop-0rtt" id="prop-0rtt">Use 0-RTT session establishment with an idempotent Message</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.8.p.2">This property specifies whether an application would like to supply a Message to the transport protocol before Connection establishment, which will then be reliably transferred to the other side before or during Connection establishment, potentially multiple times.  See also <a href="#msg-idempotent" class="xref">Section 7.3.4</a>. The default is to not have this option.</p>
<h1 id="rfc.section.12.3.9">
<a href="#rfc.section.12.3.9">12.3.9.</a> <a href="#idempotent" id="idempotent">Idempotent</a>
</h1>
<p id="rfc.section.12.3.9.p.1">Boolean Message Property - see <a href="#msg-idempotent" class="xref">Section 7.3.4</a>.</p>
<h1 id="rfc.section.12.3.10">
<a href="#rfc.section.12.3.10">12.3.10.</a> <a href="#prop-multistream" id="prop-multistream">Multistream Connections in Group</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.10.p.2">This property specifies that the application would prefer multiple Connections within a Connection Group to be provided by streams of a single underlying transport connection where possible. The default is to not have this option.</p>
<h1 id="rfc.section.12.3.11">
<a href="#rfc.section.12.3.11">12.3.11.</a> <a href="#notification-of-excessive-retransmissions" id="notification-of-excessive-retransmissions">Notification of excessive retransmissions</a>
</h1>
<p id="rfc.section.12.3.11.p.1">Boolean Connection Property - see <a href="#conn-retrans-notify" class="xref">Section 9.1.1</a>.</p>
<h1 id="rfc.section.12.3.12">
<a href="#rfc.section.12.3.12">12.3.12.</a> <a href="#retransmission-threshold-before-excessive-retransmission-notification" id="retransmission-threshold-before-excessive-retransmission-notification">Retransmission threshold before excessive retransmission notification</a>
</h1>
<p id="rfc.section.12.3.12.p.1">Integer Connection Property - see <a href="#conn-excss-retransmit" class="xref">Section 9.1.2</a></p>
<h1 id="rfc.section.12.3.13">
<a href="#rfc.section.12.3.13">12.3.13.</a> <a href="#notification-of-icmp-soft-error-message-arrival" id="notification-of-icmp-soft-error-message-arrival">Notification of ICMP soft error message arrival</a>
</h1>
<p id="rfc.section.12.3.13.p.1">Boolean Connection Property - see <a href="#conn-soft-error" class="xref">Section 9.1.3</a></p>
<h1 id="rfc.section.12.3.14">
<a href="#rfc.section.12.3.14">12.3.14.</a> <a href="#prop-checksum-control" id="prop-checksum-control">Control checksum coverage on sending or receiving</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.14.p.2">This property specifies whether the application considers it useful to enable, disable, or configure a checksum when sending a Message, or configure whether to require a checksum or not when receiving.  The default is full checksum coverage without the option to configure it, and requiring a checksum when receiving.</p>
<h1 id="rfc.section.12.3.15">
<a href="#rfc.section.12.3.15">12.3.15.</a> <a href="#corruption-protection-length" id="corruption-protection-length">Corruption Protection Length</a>
</h1>
<p id="rfc.section.12.3.15.p.1">Integer Message Property - see <a href="#msg-checksum" class="xref">Section 7.3.6</a>.</p>
<h1 id="rfc.section.12.3.16">
<a href="#rfc.section.12.3.16">12.3.16.</a> <a href="#required-minimum-coverage-of-the-checksum-for-receiving" id="required-minimum-coverage-of-the-checksum-for-receiving">Required minimum coverage of the checksum for receiving</a>
</h1>
<p id="rfc.section.12.3.16.p.1">Integer Connection Property - see <a href="#conn-recv-checksum" class="xref">Section 9.1.4</a></p>
<h1 id="rfc.section.12.3.17">
<a href="#rfc.section.12.3.17">12.3.17.</a> <a href="#prop-interface" id="prop-interface">Interface Instance or Type</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Tuple (Enumeration, Preference)</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.17.p.2">This property allows the application to select which specific network interfaces or categories of interfaces it wants to <samp>Require</samp>, <samp>Prohibit</samp>, <samp>Prefer</samp>, or <samp>Avoid</samp>.</p>
<p id="rfc.section.12.3.17.p.3">If a system supports discovery of specific interface identifiers, such as <samp>en0</samp> or <samp>eth0</samp> on Unix-style systems, an implemention should allow using these identifiers to define path preferences. Note that marking a specific interface as <samp>Required</samp> strictly limits path selection to a single interface, and leads to less flexible and resilient connection establishment.</p>
<p id="rfc.section.12.3.17.p.4">The set of valid interface types is implementation- and system-specific. For example, on a mobile device, there may be <samp>Wi-Fi</samp> and <samp>Cellular</samp> interface types available; whereas on a desktop computer, there may be <samp>Wi-Fi</samp> and <samp>Wired Ethernet</samp> interface types available. Implementations should provide all types that are supported on some system to all systems, in order to allow applications to write generic code.  For example, if a single implementation is used on both mobile devices and desktop devices, it should define the <samp>Cellular</samp> interface type for both systems, since an application may want to always <samp>Prohibit Cellular</samp>. Note that marking a specific interface type as <samp>Required</samp> limits path selection to a small set of interfaces, and leads to less flexible and resilient connection establishment.</p>
<p id="rfc.section.12.3.17.p.5">The set of interface types is expected to change over time as new access technologies become available.</p>
<p id="rfc.section.12.3.17.p.6">Interface types should not be treated as a proxy for properties of interfaces such as metered or unmetered network access. If an application needs to prohibit metered interfaces, this should be specified via Provisioning Domain attributes (see <a href="#prop-pvd" class="xref">Section 12.3.18</a>) or another specific property.</p>
<h1 id="rfc.section.12.3.18">
<a href="#rfc.section.12.3.18">12.3.18.</a> <a href="#prop-pvd" id="prop-pvd">Provisioning Domain Instance or Type</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Tuple (Enumeration, Preference)</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.18.p.2">Similar to interface instances and types (see <a href="#prop-interface" class="xref">Section 12.3.17</a>), this property allows the application to control path selection by selecting which specific Provisioning Domains or categories of Provisioning Domains it wants to  <samp>Require</samp>, <samp>Prohibit</samp>, <samp>Prefer</samp>, or <samp>Avoid</samp>.  Provisioning Domains define consistent sets of network properties that may be more specific than network interfaces <a href="#RFC7556" class="xref">[RFC7556]</a>.</p>
<p id="rfc.section.12.3.18.p.3">The identification of a specific Provisioning Domain (PvD) is defined to be implementation- and system-specific, since there is not a portable standard format for a PvD identitfier.  For example, this identifier may be a string name or an integer. As with requiring specific interfaces, requiring a specific PvD strictly limits path selection.</p>
<p id="rfc.section.12.3.18.p.4">Categories or types of PvDs are also defined to be implementation- and system-specific.  These may be useful to identify a service that is provided by a PvD. For example, if an application wants to use a PvD that provides a Voice-Over-IP service on a Cellular network, it can use the relevant PvD type to require some PvD that provides this service, without needing to look up a particular instance. While this does restrict path selection, it is broader than requiring specific PvD instances or interface instances, and should be preferred over these options.</p>
<h1 id="rfc.section.12.3.19">
<a href="#rfc.section.12.3.19">12.3.19.</a> <a href="#prop-cap-profile" id="prop-cap-profile">Capacity Profile</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Enumeration</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection, Message</dd>
</dl>
<p id="rfc.section.12.3.19.p.2">This property specifies the desired network treatment for traffic sent by the application and the tradeoffs the application is prepared to make in path and protocol selection to receive that desired treatment. When the capacity profile is set to a value other than Default, the transport system should select paths and profiles to optimize for the capacity profile specified. The following values are valid for the Capacity Profile:</p>
<p id="rfc.section.12.3.19.p.3">Default: : The application makes no representation about its expected capacity profile. No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when selecting and configuring transport protocol stacks. Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign the DSCP Default Forwarding <a href="#RFC2474" class="xref">[RFC2474]</a> PHB; when the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<p id="rfc.section.12.3.19.p.4">Scavenger: : The application is not interactive. It expects to send and/or receive data without any urgency. This can, for example, be used to select protocol stacks with scavenger transmission control and/or to assign the traffic to a lower-effort service. Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign the DSCP Less than Best Effort <a href="#LE-PHB" class="xref">[LE-PHB]</a> PHB; when the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<p id="rfc.section.12.3.19.p.5">Low Latency/Interactive: : The application is interactive, and prefers loss to latency. Response time should be optimized at the expense of bandwidth efficiency and delay variation when sending on this connection. This can be used by the system to disable the coalescing of multiple small Messages into larger packets (Nagle&#8217;s algorithm); to prefer immediate acknowledgment from the peer endpoint when supported by the underlying transport; and so on.  Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign the DSCP Expedited Forwarding <a href="#RFC3246" class="xref">[RFC3246]</a> PHB; when the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<p id="rfc.section.12.3.19.p.6">Low Latency/Non-Interactive: : The application prefers loss to latency but is not interactive. Response time should be optimized at the expense of bandwidth efficiency and delay variation when sending on this connection.Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign a DSCP Assured Forwarding (AF21,AF22,AF23,AF24) <a href="#RFC2597" class="xref">[RFC2597]</a> PHB; when the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<p id="rfc.section.12.3.19.p.7">Constant-Rate Streaming: : The application expects to send/receive data at a constant rate after Connection establishment. Delay and delay variation should be minimized at the expense of bandwidth efficiency. This implies that the Connection may fail if the desired rate cannot be maintained across the Path.  A transport may interpret this capacity profile as preferring a circuit breaker <a href="#RFC8084" class="xref">[RFC8084]</a> to a rate-adaptive congestion controller. Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign a DSCP Assured Forwarding (AF31,AF32,AF33,AF34) <a href="#RFC2597" class="xref">[RFC2597]</a> PHB; when the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<p id="rfc.section.12.3.19.p.8">High Throughput Data: : The application expects to send/receive data at the maximum rate allowed by its congestion controller over a relatively long period of time. Transport system implementations that map the requested capacity profile onto per-connection DSCP signaling without multiplexing SHOULD assign a DSCP Assured Forwarding (AF11,AF12,AF13,AF14) <a href="#RFC2597" class="xref">[RFC2597]</a> PHB per section 4.8 of <a href="#RFC4594" class="xref">[RFC4594]</a>. When the Connection is multiplexed, the guidelines in section 6 of <a href="#RFC7657" class="xref">[RFC7657]</a> apply.</p>
<h1 id="rfc.section.12.3.20">
<a href="#rfc.section.12.3.20">12.3.20.</a> <a href="#prop-cc" id="prop-cc">Congestion control</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection (read only)</dd>
</dl>
<p id="rfc.section.12.3.20.p.2">This property specifies whether the application would like the Connection to be congestion controlled or not. Note that if a Connection is not congestion controlled, an application using such a Connection should itself perform congestion control in accordance with <a href="#RFC2914" class="xref">[RFC2914]</a>. Also note that reliability is usually combined with congestion control in protocol implementations, rendering &#8220;reliable but not congestion controlled&#8221; a request that is unlikely to succeed. The default is that the Connection is congestion controlled.</p>
<h1 id="rfc.section.12.3.21">
<a href="#rfc.section.12.3.21">12.3.21.</a> <a href="#niceness-connection" id="niceness-connection">Niceness (Connection)</a>
</h1>
<p id="rfc.section.12.3.21.p.1">Integer Connection Property - see <a href="#conn-niceness" class="xref">Section 9.1.5</a></p>
<h1 id="rfc.section.12.3.22">
<a href="#rfc.section.12.3.22">12.3.22.</a> <a href="#niceness-message" id="niceness-message">Niceness (Message)</a>
</h1>
<p id="rfc.section.12.3.22.p.1">[TODO: Discuss: should we remove this? Whether we need this or the other depends on how we want to implement multi-streaming. We don&#8217;t need both, so we should make a decision. @mwelzl &#8211; These are really two different things @philsbln]</p>
<p id="rfc.section.12.3.22.p.2">Integer Message Property - see <a href="#msg-niceness" class="xref">Section 7.3.2</a>.</p>
<p id="rfc.section.12.3.22.p.3">Note that this property is not a per-message override of the connection Niceness - see <a href="#conn-niceness" class="xref">Section 9.1.5</a>.  Both Niceness properties may interact, but can be used independently and be realized by different mechanisms.</p>
<h1 id="rfc.section.12.3.23">
<a href="#rfc.section.12.3.23">12.3.23.</a> <a href="#timeout-for-aborting-connection" id="timeout-for-aborting-connection">Timeout for aborting Connection</a>
</h1>
<p id="rfc.section.12.3.23.p.1">Integer Connection Property - see <a href="#conn-timeout" class="xref">Section 9.1.6</a></p>
<h1 id="rfc.section.12.3.24">
<a href="#rfc.section.12.3.24">12.3.24.</a> <a href="#connection-group-transmission-scheduler" id="connection-group-transmission-scheduler">Connection group transmission scheduler</a>
</h1>
<p id="rfc.section.12.3.24.p.1">Enum Connection Property - see <a href="#conn-scheduler" class="xref">Section 9.1.7</a></p>
<h1 id="rfc.section.12.3.25">
<a href="#rfc.section.12.3.25">12.3.25.</a> <a href="#maximum-message-size-concurrent-with-connection-establishment" id="maximum-message-size-concurrent-with-connection-establishment">Maximum message size concurrent with Connection establishment</a>
</h1>
<p id="rfc.section.12.3.25.p.1">Integer Connection Property (read-only) - see <a href="#size-idempotent" class="xref">Section 9.1.8</a></p>
<h1 id="rfc.section.12.3.26">
<a href="#rfc.section.12.3.26">12.3.26.</a> <a href="#maximum-message-size-before-fragmentation-or-segmentation" id="maximum-message-size-before-fragmentation-or-segmentation">Maximum Message size before fragmentation or segmentation</a>
</h1>
<p id="rfc.section.12.3.26.p.1">Integer Connection Property (read-only) - see <a href="#conn-max-msg-notfrag" class="xref">Section 9.1.9</a></p>
<h1 id="rfc.section.12.3.27">
<a href="#rfc.section.12.3.27">12.3.27.</a> <a href="#maximum-message-size-on-send" id="maximum-message-size-on-send">Maximum Message size on send</a>
</h1>
<p id="rfc.section.12.3.27.p.1">Integer Connection Property (read-only) - see <a href="#conn-max-msg-send" class="xref">Section 9.1.10</a></p>
<h1 id="rfc.section.12.3.28">
<a href="#rfc.section.12.3.28">12.3.28.</a> <a href="#maximum-message-size-on-receive" id="maximum-message-size-on-receive">Maximum Message size on receive</a>
</h1>
<p id="rfc.section.12.3.28.p.1">Integer Connection Property (read-only) - see <a href="#conn-max-msg-recv" class="xref">Section 9.1.11</a></p>
<h1 id="rfc.section.12.3.29">
<a href="#rfc.section.12.3.29">12.3.29.</a> <a href="#lifetime" id="lifetime">Lifetime</a>
</h1>
<p id="rfc.section.12.3.29.p.1">Integer Message Property - see <a href="#msg-lifetime" class="xref">Section 7.3.1</a>.</p>
<h1 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#optional-transport-properties" id="optional-transport-properties">Optional Transport Properties</a>
</h1>
<p id="rfc.section.12.4.p.1">TODO: Maybe move some of the above properties here.</p>
<h1 id="rfc.section.12.5">
<a href="#rfc.section.12.5">12.5.</a> <a href="#experimental-transport-properties" id="experimental-transport-properties">Experimental Transport Properties</a>
</h1>
<p id="rfc.section.12.5.p.1">TODO: Move <a href="#appendix-non-consensus" class="xref">Appendix A</a> here.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.13.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.13.p.2">This document has no Actions for IANA.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.14.p.1">This document describes a generic API for interacting with a transport services (TAPS) system.  Part of this API includes configuration details for transport security protocols, as discussed in <a href="#security-parameters" class="xref">Section 5.3</a>. It does not recommend use (or disuse) of specific algorithms or protocols. Any API-compatible transport security protocol should work in a TAPS system.</p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.15.p.1">This work has received funding from the European Union&#8217;s Horizon 2020 research and innovation programme under grant agreements No. 644334 (NEAT) and No. 688421 (MAMI).</p>
<p id="rfc.section.15.p.2">This work has been supported by Leibniz Prize project funds of DFG - German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).</p>
<p id="rfc.section.15.p.3">This work has been supported by the UK Engineering and Physical Sciences Research Council under grant EP/R04144X/1.</p>
<p id="rfc.section.15.p.4">Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work. Thanks to Laurent Chuat and Jason Lee for initial work on the Post Sockets interface, from which this work has evolved.</p>
<h1 id="rfc.references">
<a href="#rfc.references">16.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">16.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-taps-arch">[I-D.ietf-taps-arch]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Trammell, B.</a>, <a>Brunstrom, A.</a>, <a>Fairhurst, G.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-arch-01">An Architecture for Transport Services</a>", Internet-Draft draft-ietf-taps-arch-01, July 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-taps-minset">[I-D.ietf-taps-minset]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-11">A Minimal Set of Transport Services for End Systems</a>", Internet-Draft draft-ietf-taps-minset-11, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-28">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-28, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-rtcweb-qos">[I-D.ietf-tsvwg-rtcweb-qos]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Dhesikan, S.</a>, <a>Jennings, C.</a> and <a>D. Druta</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">DSCP Packet Markings for WebRTC QoS</a>", Internet-Draft draft-ietf-tsvwg-rtcweb-qos-18, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-sctp-ndata">[I-D.ietf-tsvwg-sctp-ndata]</b></td>
<td class="top">
<a>Stewart, R.</a>, <a>Tuexen, M.</a>, <a>Loreto, S.</a> and <a>R. Seggelmann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13">Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</a>", Internet-Draft draft-ietf-tsvwg-sctp-ndata-13, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">16.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-taps-transport-security">[I-D.ietf-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Perkins, C.</a>, <a>Rose, K.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-transport-security-02">A Survey of Transport Security Protocols</a>", Internet-Draft draft-ietf-taps-transport-security-02, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="LE-PHB">[LE-PHB]</b></td>
<td class="top">
<a>Bless, R.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-le-phb-06">A Lower Effort Per-Hop Behavior (LE PHB)</a>", Internet-Draft draft-ietf-tsvwg-le-phb-06, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2474">[RFC2474]</b></td>
<td class="top">
<a>Nichols, K.</a>, <a>Blake, S.</a>, <a>Baker, F.</a> and <a>D. Black</a>, "<a href="https://tools.ietf.org/html/rfc2474">Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</a>", RFC 2474, DOI 10.17487/RFC2474, December 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2597">[RFC2597]</b></td>
<td class="top">
<a>Heinanen, J.</a>, <a>Baker, F.</a>, <a>Weiss, W.</a> and <a>J. Wroclawski</a>, "<a href="https://tools.ietf.org/html/rfc2597">Assured Forwarding PHB Group</a>", RFC 2597, DOI 10.17487/RFC2597, June 1999.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2914">[RFC2914]</b></td>
<td class="top">
<a>Floyd, S.</a>, "<a href="https://tools.ietf.org/html/rfc2914">Congestion Control Principles</a>", BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3246">[RFC3246]</b></td>
<td class="top">
<a>Davie, B.</a>, <a>Charny, A.</a>, <a>Bennet, J.</a>, <a>Benson, K.</a>, <a>Le Boudec, J.</a>, <a>Courtney, W.</a>, <a>Davari, S.</a>, <a>Firoiu, V.</a> and <a>D. Stiliadis</a>, "<a href="https://tools.ietf.org/html/rfc3246">An Expedited Forwarding PHB (Per-Hop Behavior)</a>", RFC 3246, DOI 10.17487/RFC3246, March 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="https://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, DOI 10.17487/RFC3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4594">[RFC4594]</b></td>
<td class="top">
<a>Babiarz, J.</a>, <a>Chan, K.</a> and <a>F. Baker</a>, "<a href="https://tools.ietf.org/html/rfc4594">Configuration Guidelines for DiffServ Service Classes</a>", RFC 4594, DOI 10.17487/RFC4594, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="https://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7478">[RFC7478]</b></td>
<td class="top">
<a>Holmberg, C.</a>, <a>Hakansson, S.</a> and <a>G. Eriksson</a>, "<a href="https://tools.ietf.org/html/rfc7478">Web Real-Time Communication Use Cases and Requirements</a>", RFC 7478, DOI 10.17487/RFC7478, March 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7556">[RFC7556]</b></td>
<td class="top">
<a>Anipko, D.</a>, "<a href="https://tools.ietf.org/html/rfc7556">Multiple Provisioning Domain Architecture</a>", RFC 7556, DOI 10.17487/RFC7556, June 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7657">[RFC7657]</b></td>
<td class="top">
<a>Black, D.</a> and <a>P. Jones</a>, "<a href="https://tools.ietf.org/html/rfc7657">Differentiated Services (Diffserv) and Real-Time Communication</a>", RFC 7657, DOI 10.17487/RFC7657, November 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8084">[RFC8084]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, "<a href="https://tools.ietf.org/html/rfc8084">Network Transport Circuit Breakers</a>", BCP 208, RFC 8084, DOI 10.17487/RFC8084, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#appendix-non-consensus" id="appendix-non-consensus">Additional Properties</a>
</h1>
<p id="rfc.section.A.p.1">The interface specified by this document represents the minimal common interface to an endpoint in the transport services architecture <a href="#I-D.ietf-taps-arch" class="xref">[I-D.ietf-taps-arch]</a>, based upon that architecture and on the minimal set of transport service features elaborated in <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>. However, the interface has been designed with extension points to allow the implementation of features beyond those in the minimal common interface: Protocol Selection Properties, Path Selection Properties, and Message Properties are open sets. Implementations of the interface are free to extend these sets to provide additional expressiveness to applications written on top of them.</p>
<p id="rfc.section.A.p.2">This appendix enumerates a few additional properties that could be used to enhance transport protocol and/or path selection, or the transmission of messages given a Protocol Stack that implements them. These are not part of the interface, and may be removed from the final document, but are presented here to support discussion within the TAPS working group as to whether they should be added to a future revision of the base specification.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#experimental-transport-properties-1" id="experimental-transport-properties-1">Experimental Transport Properties</a>
</h1>
<p id="rfc.section.A.1.p.1">The following Transport Properties might be made available in addition to those specified in <a href="#transport-props" class="xref">Section 12</a>:</p>
<h1 id="rfc.appendix.A.1.1">
<a href="#rfc.appendix.A.1.1">A.1.1.</a> <a href="#suggest-a-timeout-to-the-remote-endpoint" id="suggest-a-timeout-to-the-remote-endpoint">Suggest a timeout to the Remote Endpoint</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Selection Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Preference</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection</dd>
</dl>
<p id="rfc.section.A.1.1.p.2">This property specifies whether an application considers it useful to propose a timeout until the Connection is assumed to be lost. The default is to have this option.</p>
<p id="rfc.section.A.1.1.p.3">[EDITOR&#8217;S NOTE: For discussion of this option, see https://github.com/taps-api/drafts/issues/109]</p>
<h1 id="rfc.appendix.A.1.2">
<a href="#rfc.appendix.A.1.2">A.1.2.</a> <a href="#abort-timeout-to-suggest-to-the-remote-endpoint" id="abort-timeout-to-suggest-to-the-remote-endpoint">Abort timeout to suggest to the Remote Endpoint</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Protocol Property</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Connection</dd>
</dl>
<p id="rfc.section.A.1.2.p.2">This numeric property specifies the timeout to propose to the Remote Endpoint.  It is given in seconds.</p>
<p id="rfc.section.A.1.2.p.3">[EDITOR&#8217;S NOTE: For discussion of this property, see https://github.com/taps-api/drafts/issues/109]</p>
<h1 id="rfc.appendix.A.1.3">
<a href="#rfc.appendix.A.1.3">A.1.3.</a> <a href="#traffic-category" id="traffic-category">Traffic Category</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Intent</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Enumeration</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection</dd>
</dl>
<p id="rfc.section.A.1.3.p.2">This property specifies what the application expects the dominating traffic pattern to be. Possible values are:</p>
<p></p>

<dl>
<dt>Query:</dt>
<dd style="margin-left: 8">Single request / response style workload, latency bound</dd>
<dt>Control:</dt>
<dd style="margin-left: 8">Long lasting low bandwidth control channel, not bandwidth bound</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">Stream of data with steady data rate</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Bulk transfer of large Messages, presumably bandwidth bound</dd>
</dl>
<p id="rfc.section.A.1.3.p.4">The default is to not assume any particular traffic pattern. Most categories suggest the use of other intents to further describe the traffic pattern anticipated, e.g., the bulk category suggesting the use of the Message Size intents or the stream category suggesting the Stream Bitrate and Duration intents.</p>
<h1 id="rfc.appendix.A.1.4">
<a href="#rfc.appendix.A.1.4">A.1.4.</a> <a href="#size-to-be-sent-or-received" id="size-to-be-sent-or-received">Size to be Sent or Received</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Intent</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Message</dd>
</dl>
<p id="rfc.section.A.1.4.p.2">This property specifies how many bytes the application expects to send (Size to be Sent) or how many bytes the application expects to receive in response (Size to be Received).</p>
<h1 id="rfc.appendix.A.1.5">
<a href="#rfc.appendix.A.1.5">A.1.5.</a> <a href="#duration" id="duration">Duration</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Intent</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection</dd>
</dl>
<p id="rfc.section.A.1.5.p.2">This Intent specifies what the application expects the lifetime of a Connection to be. It is given in milliseconds.</p>
<h1 id="rfc.appendix.A.1.6">
<a href="#rfc.appendix.A.1.6">A.1.6.</a> <a href="#send-or-receive-bit-rate" id="send-or-receive-bit-rate">Send or Receive Bit-rate</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Intent</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Integer</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Message</dd>
</dl>
<p id="rfc.section.A.1.6.p.2">This Intent specifies what the application expects the bit-rate of a transfer to be. It is given in Bytes per second.</p>
<p id="rfc.section.A.1.6.p.3">On a Message, this property specifies at what bitrate the application wishes the Message to be sent. A transport system supporting this feature will not exceed the requested Send Bitrate even if flow-control and congestion control allow higher bitrates. This helps to avoid a bursty traffic pattern on busy streaming video servers.</p>
<h1 id="rfc.appendix.A.1.7">
<a href="#rfc.appendix.A.1.7">A.1.7.</a> <a href="#cost-preferences" id="cost-preferences">Cost Preferences</a>
</h1>
<p></p>

<dl>
<dt>Classification:</dt>
<dd style="margin-left: 8">Intent</dd>
<dt>Type:</dt>
<dd style="margin-left: 8">Enumeration</dd>
<dt>Applicability:</dt>
<dd style="margin-left: 8">Preconnection, Message</dd>
</dl>
<p id="rfc.section.A.1.7.p.2">This property describes what an application prefers regarding monetary costs, e.g., whether it considers it acceptable to utilize limited data volume. It provides hints to the transport system on how to handle trade-offs between cost and performance or reliability.</p>
<p id="rfc.section.A.1.7.p.3">Possible values are:</p>
<p></p>

<dl>
<dt>No Expense:</dt>
<dd style="margin-left: 8">Avoid transports associated with monetary cost</dd>
<dt>Optimize Cost:</dt>
<dd style="margin-left: 8">Prefer inexpensive transports and accept service degradation</dd>
<dt>Balance Cost:</dt>
<dd style="margin-left: 8">Use system policy to balance cost and other criteria</dd>
<dt>Ignore Cost:</dt>
<dd style="margin-left: 8">Ignore cost, choose transport solely based on other criteria</dd>
</dl>
<p id="rfc.section.A.1.7.p.5">The default is &#8220;Balance Cost&#8221;.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#appendix-api-sketch" id="appendix-api-sketch">Sample API definition in Go</a>
</h1>
<p id="rfc.section.B.p.1">This document defines an abstract interface. To illustrate how this would map concretely into a programming language, an API interface definition in Go is available online at https://github.com/mami-project/postsocket.  Documentation for this API &#8211; an illustration of the documentation an application developer would see for an instance of this interface - is available online at https://godoc.org/github.com/mami-project/postsocket. This API definition will be kept largely in sync with the development of this abstract interface definition.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael Welzl</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Welzl</span>
	  </span>
	</span>
	<span class="org vcardline">University of Oslo</span>
	<span class="adr">
	  <span class="vcardline">PO Box 1080 Blindern</span>

	  <span class="vcardline">
		<span class="locality">0316  Oslo</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Norway</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michawe@ifi.uio.no">michawe@ifi.uio.no</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Godred Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  <span class="vcardline">Fraser Noble Building</span>

	  <span class="vcardline">
		<span class="locality">Aberdeen, AB24 3UE</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Scotland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

<span class="vcardline">URI: <a href="http://www.erg.abdn.ac.uk/">http://www.erg.abdn.ac.uk/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
