



TAPS Working Group                                      B. Trammell, Ed.
Internet-Draft                                                ETH Zurich
Intended status: Informational                             M. Welzl, Ed.
Expires: August 10, 2018                              University of Oslo
                                                            G. Fairhurst
                                                  University of Aberdeen
                                                           M. Kuehlewind
                                                              ETH Zurich
                                                              C. Perkins
                                                   University of Glasgow
                                                               P. Tiesel
                                                               TU Berlin
                                                                 C. Wood
                                                              Apple Inc.
                                                       February 06, 2018


     An Abstract Application Layer Interface to Transport Services
                  draft-trammell-taps-interface-latest

Abstract

   This document describes an abstract programming interface to the
   transport layer, following the Transport Services Architecture.  It
   supports the asynchronous, atomic transmission of messages over
   transport protocols and network paths dynamically selected at
   runtime.  It is intended to replace the traditional BSD sockets API
   as the lowest common denominator interface to the transport layer, in
   an environment where endpoints have multiple interfaces and potential
   transport protocols to select from.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 10, 2018.




Trammell, et al.         Expires August 10, 2018                [Page 1]

Internet-Draft               TAPS Interface                February 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology and Notation  . . . . . . . . . . . . . . . . . .   3
   3.  Design Principles . . . . . . . . . . . . . . . . . . . . . .   4
   4.  API Summary . . . . . . . . . . . . . . . . . . . . . . . . .   5
   5.  Pre-Establishment Phase . . . . . . . . . . . . . . . . . . .   5
     5.1.  Resolving Remote Endpoints  . . . . . . . . . . . . . . .   5
     5.2.  Specifying Transport Parameters . . . . . . . . . . . . .   5
     5.3.  Specifying Cryptographic Parameters . . . . . . . . . . .   5
   6.  Establishing Connections  . . . . . . . . . . . . . . . . . .   6
     6.1.  Active Open: Initiate . . . . . . . . . . . . . . . . . .   6
     6.2.  Passive Open: Listen  . . . . . . . . . . . . . . . . . .   7
     6.3.  Peer to Peer Establishment: Rendezvous  . . . . . . . . .   7
     6.4.  Connection Groups . . . . . . . . . . . . . . . . . . . .   8
   7.  Sending Data  . . . . . . . . . . . . . . . . . . . . . . . .   8
     7.1.  Send Properties . . . . . . . . . . . . . . . . . . . . .   9
       7.1.1.  Lifetime  . . . . . . . . . . . . . . . . . . . . . .   9
       7.1.2.  Niceness  . . . . . . . . . . . . . . . . . . . . . .   9
       7.1.3.  Ordered . . . . . . . . . . . . . . . . . . . . . . .   9
       7.1.4.  Immediate . . . . . . . . . . . . . . . . . . . . . .  10
       7.1.5.  Idempotent  . . . . . . . . . . . . . . . . . . . . .  10
     7.2.  Sender-side Framing over Stream Protocols . . . . . . . .  10
   8.  Receiving Data  . . . . . . . . . . . . . . . . . . . . . . .  10
     8.1.  Application-Layer Backpressure at the Receiver  . . . . .  10
     8.2.  Receiver-side Deframing over Stream Protocols . . . . . .  11
   9.  Connection Termination  . . . . . . . . . . . . . . . . . . .  11
   10. Event and Error Handling  . . . . . . . . . . . . . . . . . .  11
   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11
   12. Security Considerations . . . . . . . . . . . . . . . . . . .  11
   13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     13.1.  Normative References . . . . . . . . . . . . . . . . . .  11
     13.2.  Informative References . . . . . . . . . . . . . . . . .  12



Trammell, et al.         Expires August 10, 2018                [Page 2]

Internet-Draft               TAPS Interface                February 2018


   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  12

1.  Introduction

   The BSD Unix Sockets API's SOCK_STREAM abstraction, by bringing
   network sockets into the UNIX programming model, allowing anyone who
   knew how to write programs that dealt with sequential-access files to
   also write network applications, was a revolution in simplicity.  It
   would not be an overstatement to say that this simple API is the
   reason the Internet won the protocol wars of the 1980s.  SOCK_STREAM
   is tied to the Transmission Control Protocol (TCP), specified in 1981
   [RFC0793].  TCP has scaled remarkably well over the past three and a
   half decades, but its total ubiquity has hidden an uncomfortable
   fact: the network is not really a file, and stream abstractions are
   too simplistic for many modern application programming models.

   In the meantime, the nature of Internet access, and the variety of
   Internet transport protocols, is evolving.  The challenges that new
   protocols and access paradigms present to the sockets API and to
   programming models based on them inspire the design principles of a
   new approach, which we outline in Section 3.

   As a first step to realizing this design, [TAPS-ARCH] describes a
   high-level architecture for transport services.  This document builds
   a modern abstract programming interface atop this architecture,
   deriving specific path and protocol selection properties and
   supported transport features from the analysis provided in [RFC8095]
   and [TAPS-MINSET].

2.  Terminology and Notation

   This API is described in terms of Objects, which an application can
   interact with; Actions the application can perform on these objects;
   Events, which an object can send to an application asynchronously;
   and Parameters associated with these Actions and Events.

   The following notations, which can be combined, are used in this
   document:

   o  Object := Action()



         An Action creates an Object.

   o  Object.Action()





Trammell, et al.         Expires August 10, 2018                [Page 3]

Internet-Draft               TAPS Interface                February 2018


         An Action is performed on an Object.

   o  Object -> Event<>



         An Object sends an Event.

   o  Action(parameter, parameter, ...) / Event<parameter, parameter,
      ...>



         An Action takes a set of Parameters; an Event contains a set of
         Parameters.

   Actions associated with no object are Actions on the abstract
   interface itself; they are equivalent to actions on a per-application
   global context.

   How these abstract concepts map into concrete implementations of this
   API in a given language on a given platform is largely dependent on
   the features of the language and the platform.  Actions could be
   implemented as functions or method calls, for instance, and Events
   could be implemented though via callback passing or other
   asynchronous calling conventions.

3.  Design Principles

   We begin with a set of initial design principles for the abstract
   interface to realize.

   o  Transport protocol stack independence in line with the Transport
      Services Architecture [TAPS-ARCH], allowing applications to be
      written in terms of the semantics best for the application's own
      design, separate from the protocol(s) used on the wire to achieve
      them.  This enables applications written to a single API to make
      use of transport protocols in terms of the features they provide.

   o  Explicit support for multistreaming and multipath transport
      protocols.

   o  Explicit support for security properties as first-order transport
      features, and for long-term caching of cryptographic identities
      and parameters for associations among endpoints.






Trammell, et al.         Expires August 10, 2018                [Page 4]

Internet-Draft               TAPS Interface                February 2018


   o  Atomic transmission of content, using application-assisted framing
      and deframing where the underlying transport does not provide
      these.

   o  Asynchronous connection establishment, transmission, and
      reception, allowing most application interactions with the
      transport layer to be event-driven.

4.  API Summary

   [TASK: write three paragraph summary here, should state how all this
   works for common cases from the application's PoV.]

   In the following sections, we describe the details of application
   interaction with Objects through Actions and Events in each phase of
   a connection, following the phases described in [TAPS-ARCH].

5.  Pre-Establishment Phase

   Establishment begins with the creation of a Connection...

   Connection := NewConnection(localSpecifier, remoteSpecifier,
   transportParameters, cryptographicParameters)

   [NOTE: note also that framers and deframers should be bound to
   connections during pre-establishment, forward-reference Section 7.2
   and Section 8.2]

5.1.  Resolving Remote Endpoints

   [TASK: write me. note: resolution should be flexible, and should
   accept URLS and URL-like things. binding to transport or
   pseudotransport happens via pre-establishment properties. resolution
   happens as part of connection creation.]

5.2.  Specifying Transport Parameters

   [TASK: write me. list parameters to bind to a connection before
   establishing it. look at minset for this. note that the API should
   have sensible and well-defined defaults.]

5.3.  Specifying Cryptographic Parameters

   [TASK: write me. separate out cryptographic parameters, since these
   bind to a local and a remote. chris?]






Trammell, et al.         Expires August 10, 2018                [Page 5]

Internet-Draft               TAPS Interface                February 2018


6.  Establishing Connections

   Before a Connection can be used for data transfer, it must be
   established.  Establishment ends the pre-establishment phase; all
   transport and cryptographic parameter specification must be complete
   before establishment, as these parameters will be used to select
   candidate Paths and Protocol Stacks for the Connection.
   Establishment may be active, using the Initiate() Action; passive,
   using the Listen() Action; or simultaneous for peer-to-peer, using
   the Rendezvous() Action.  These Actions are described in the
   subsections below.

6.1.  Active Open: Initiate

   Active open is the action of establishing a connection to an endpoint
   presumed to be listening for incoming connection requests, commonly
   used by clients in client-server interactions.  Active open is
   supported by this interface through the Initiate action:

   Connection.Initiate()

   Before calling Initiate, the caller must have initialized the
   Connection during the pre-establishment phase with local and remote
   endpoint specifiers, as well as all parameters necessary for
   candidate selection.  After calling Initiate, no further parameters
   may be bound to the Connection, and no subsequent establishment call
   may be made on the Connection.

   Once Initiate is called, the candidate Protocol Stack(s) may cause
   one or more transport-layer connections to be created to the
   specified remote endpoint.  The caller may immediately begin sending
   Content on the Connection (see Section 7) after calling Initate,
   though it may wait for one of the following events before doing so.

   Connection -> Ready<>

   The Ready event occurs after Initiate has established a transport-
   layer connection on at least one usable candidate Protocol Stack over
   at least one candidate Path.  No Receive events (see Section 8) will
   occur until after the Ready event for connections established using
   Initiate.

   Connection -> InitiateError<>

   An InitiateError occurs either when the set of local and remote
   specifiers and transport and cryptographic parameters cannot be
   fulfilled on a connection for initiation (e.g. the set of available
   Paths and/or Protocol Stacks meeting the constraints is empty), when



Trammell, et al.         Expires August 10, 2018                [Page 6]

Internet-Draft               TAPS Interface                February 2018


   the remote specifier cannot be resolved, or when no transport-layer
   connection can be established to the remote endpoint (e.g.  because
   the remote endpoint is not accepting connections, or the application
   is prohibited from opening a connection by the operating system).

6.2.  Passive Open: Listen

   Passive open is the action of waiting for connections from remote
   endpoints, commonly used by servers in client-server interactions.
   Passive open is supported by this interface through the Listen
   action:

   Connection.Listen()

   Before calling Listen, the caller must have initialized the
   Connection during the pre-establishment phase with local endpoint
   specifiers, as well as all parameters necessary for Protocol Stack
   selection.  After calling Listen, no further parameters may be bound
   to the Connection, and no subsequent establishment call may be made
   on the Connection.

   Connection -> ConnectionReceived<Connection>

   The ConnectionReceived event occurs when a remote endpoint has
   established a transport-layer connection to this Connection, causing
   a new Connection to be created.  The resulting Connection is
   contained within the ConnectionReceived event, and is ready to use as
   soon as it is passed to the application via the event.

   Connection -> ListenError<>

   A ListenError occurs either when the set of local specifier,
   transport and cryptographic parameters cannot be fulfilled for
   listening, when the local specifier cannot be resolved, or when the
   application is prohibited from listening by the operating system.

6.3.  Peer to Peer Establishment: Rendezvous

   Connection.Rendezvous()

   Connection -> Ready<>

   Connection -> RendezvousError<>








Trammell, et al.         Expires August 10, 2018                [Page 7]

Internet-Draft               TAPS Interface                February 2018


6.4.  Connection Groups

7.  Sending Data

   Once a Connection has been established, it can be used for sending
   data.  Data is sent by passing a Content object and additional
   properties Section 7.1 to the Send action on an established
   connection:

   Connection.Send(Content, ...)

   The type of the Content to be passed is dependent on the
   implementation, and on the constraints on the Protocol Stacks implied
   by the Connection's transport parameters.  It may itself contain an
   array of octets to be transmitted in the transport protocol payload,
   or be transformable to an array of octets by a sender-side framer
   (see Section 7.2).

   If Send is called on a Connection which has not yet been established,
   an Initiate action will be implicitly performed simultaneously with
   the Send.  Used together with the Idempotent property (see
   Section 7.1.5), this can be used to send data during establishment
   for 0-RTT session resumption on Protocol Stacks that support it.

   Like all Actions in this interface, the Send action is asynchronous.
   However, a Send call may block until there is sufficient buffer space
   in the implementation and/or the underlying Protocol Stack to handle
   the Content, in order to provide sender-side backpressure to the
   application when transmission is limited by transport channel
   capacity.

   Connection -> Sent<contentRef>

   The Sent event occurs when a previous Send action has completed, i.e.
   when the data derived from the Content has been passed down or
   through the underlying Protocol Stack and is no longer the
   responsbility of the implementation of this interface.  The exact
   disposition of Content when the Sent event occurs is specific to the
   implementation and the constraints on the Protocol Stacks implied by
   the Connection's transport parameters.  The Sent event contains an
   implementation-specific reference to the Content to which it applies.

   Connection -> Expired<contentRef>

   The Expired event occurs when a previous Send action expired before
   completion; i.e. when the data derived from the Content was not sent
   before its Lifetime (see Section 7.1.1) expired.  This is separate
   from SendError, as it is an expected behavior for partially reliable



Trammell, et al.         Expires August 10, 2018                [Page 8]

Internet-Draft               TAPS Interface                February 2018


   transports.  The Expired event contains an implementation-specific
   reference to the Content to which it applies.

   Connection -> SendError<contentRef>

   A SendError occurs when Content could not be sent due to an error
   condition: some failure of the underlying Protocol Stack, or a set of
   send parameters not consistent with the Connection's transport
   parameters.

7.1.  Send Properties

   The Send action takes five per-Content properties which control how
   it will be sent down to the underlying Protocol Stack and
   transmitted.  Note that some of these properties are not compatible
   with transport parameters; attempting to Send with such an
   incompatibility yields a SendError.

7.1.1.  Lifetime

   Lifetime specifies how long a particular Content can wait to be sent
   to the remote endpoint before it is irrelevant and no longer needs to
   be (re-)transmitted.  When a Content's Lifetime is infinite, it must
   be transmitted reliably.  The type and units of Lifetime are
   implementation-specific.

7.1.2.  Niceness

   Niceness represents an unbounded hierarchy of priorities of Content,
   relative to other Content sent over the same Connection and/or
   Connection Group (see Section 6.4).  It is most naturally represented
   as a non-negative integer.  Content with Niceness 0 will yield to
   Content with Niceness 1, which will yield to Content with Niceness 2,
   and so on.  Niceness may be used as a sender-side scheduling
   construct only, or be used to specify priorities on the wire for
   Protocol Stacks supporting prioritization.

   Note that this inversion of normal schemes for expressing priority
   has a convenient property: priority increases as both Niceness and
   Lifetime decrease.

7.1.3.  Ordered

   Ordered is a boolean property.  If true, this Content should be
   delivered after the last Content passed to the same Connection via
   the Send action; if false, this Content may be delivered before the
   last Content passed to the same Connection.




Trammell, et al.         Expires August 10, 2018                [Page 9]

Internet-Draft               TAPS Interface                February 2018


7.1.4.  Immediate

   Immediate is a boolean property.  If true, the caller prefers
   immediacy to efficiency for this Content, and the Content should not
   be bundled with other Content into the same transmission by the
   underlying Protocol Stack.

7.1.5.  Idempotent

   Idempotent is a boolean property.  If true, the application-layer
   entity in the Content is safe to send to the remote endpoint more
   than once for a single Send action.  It is used to mark data safe for
   certain 0-RTT establishment techniques, where retransmission of the
   0-RTT data may cause the remote application to receive the Content
   multiple times.

   [NOTE: we need some way to signal to the transport that we want to
   wait for 0RTT data on Initiate.  Probably a transport parameter]

7.2.  Sender-side Framing over Stream Protocols

   Sender-side framing allows a caller to provide the interface with a
   function that takes Content of an appropriate type and returns an
   array of octets, the on-the-wire representation of the content to be
   handed down to the Protocol Stack.  It consists of a Framer object
   with a single Action, Frame.  Since the Framer depends on the
   protocol used at the application layer, it is bound to the Connection
   during the pre-establishment phase:

   Connection.FrameWith(Framer)

   OctetArray := Framer.Frame(Content)

   Sender-side framing is a convenience feature of the interface, for
   parity with receiver-side framing (see Section 8.2).

8.  Receiving Data

   Connection -> Received<Content>

   Connection -> ReceiveError<>

8.1.  Application-Layer Backpressure at the Receiver








Trammell, et al.         Expires August 10, 2018               [Page 10]

Internet-Draft               TAPS Interface                February 2018


8.2.  Receiver-side Deframing over Stream Protocols

   Connection.DeframeWith(Deframer)

   Content := Deframer.Deframe(OctetStream)

   [NOTE: somewhere we should capture the idea that a Content has
   metadata that comes from the stack.  This set of actions doesn't
   allow for that as is.]

9.  Connection Termination

   Connection.Close()

   Connection -> Finished<>

   Connection.Abort()

   Connection -> ConnectionError<>

10.  Event and Error Handling

   [NOTE: point out that events and errors may be handled differently,
   although they are the modeled the same in this specification.]

11.  IANA Considerations

   RFC-EDITOR: Please remove this section before publication.

   This document has no actions for IANA.

12.  Security Considerations

   be paranoid

13.  References

13.1.  Normative References

   [TAPS-ARCH]
              Pauly, T., Ed., Trammell, B., Ed., Brunstrom, A.,
              Fairhurst, G., Perkins, C., Tiesel, P., and C. Wood, "An
              Architecture for Transport Services", n.d..








Trammell, et al.         Expires August 10, 2018               [Page 11]

Internet-Draft               TAPS Interface                February 2018


13.2.  Informative References

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.

   [RFC8095]  Fairhurst, G., Ed., Trammell, B., Ed., and M. Kuehlewind,
              Ed., "Services Provided by IETF Transport Protocols and
              Congestion Control Mechanisms", RFC 8095,
              DOI 10.17487/RFC8095, March 2017,
              <https://www.rfc-editor.org/info/rfc8095>.

   [TAPS-MINSET]
              Welzl, M. and S. Gjessing, "A Minimal Set of Transport
              Services for TAPS Systems", draft-ietf-taps-minset-00
              (work in progress), October 2017.

Authors' Addresses

   Brian Trammell (editor)
   ETH Zurich
   Gloriastrasse 35
   8092 Zurich
   Switzerland

   Email: ietf@trammell.ch


   Michael Welzl (editor)
   University of Oslo


   Gorry Fairhurst
   University of Aberdeen

   Email: gorry@erg.abdn.ac.uk


   Mirja Kuehlewind
   ETH Zurich
   Gloriastrasse 35
   8092 Zurich
   Switzerland

   Email: mirja.kuehlewind@tik.ee.ethz.ch






Trammell, et al.         Expires August 10, 2018               [Page 12]

Internet-Draft               TAPS Interface                February 2018


   Colin Perkins
   University of Glasgow
   School of Computing Science
   Glasgow  G12 8QQ
   United Kingdom

   Email: csp@csperkins.org


   Philipp S. Tiesel
   TU Berlin

   Email: philipp@inet.tu-berlin.de


   Chris Wood
   Apple Inc.
   1 Infinite Loop
   Cupertino, California 95014
   United States of America

   Email: cawood@apple.com





























Trammell, et al.         Expires August 10, 2018               [Page 13]
