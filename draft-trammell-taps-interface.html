<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Abstract Application Layer Interface to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 Design Principles">
<link href="#rfc.section.4" rel="Chapter" title="4 API Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-Establishment Phase">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Resolving Remote Endpoints">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Specifying Transport Parameters">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Protocol Selection Properties">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Protocol Properties">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Path Selection Properties">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 Socket Intents">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Specifying Cryptographic Parameters">
<link href="#rfc.section.6" rel="Chapter" title="6 Establishing Connections">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Active Open: Initiate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Passive Open: Listen">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Peer to Peer Establishment: Rendezvous">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Groups">
<link href="#rfc.section.7" rel="Chapter" title="7 Sending Data">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Send Properties">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Lifetime">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Niceness">
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 Ordered">
<link href="#rfc.section.7.1.4" rel="Chapter" title="7.1.4 Immediate">
<link href="#rfc.section.7.1.5" rel="Chapter" title="7.1.5 Idempotent">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Sender-side Framing">
<link href="#rfc.section.8" rel="Chapter" title="8 Receiving Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Application-Layer Backpressure at the Receiver">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Receiver-side Deframing over Stream Protocols">
<link href="#rfc.section.9" rel="Chapter" title="9 Connection Termination">
<link href="#rfc.section.10" rel="Chapter" title="10 Event and Error Handling">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.5 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Ed., Welzl, M., Ed., Fairhurst, G., Kuehlewind, M., Perkins, C., Tiesel, P., Enghardt, T., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-taps-interface-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-2-08" />
  <meta name="dct.abstract" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />
  <meta name="description" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Welzl, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 12, 2018</td>
<td class="right">University of Oslo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 08, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Abstract Application Layer Interface to Transport Services<br />
  <span class="filename">draft-trammell-taps-interface-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 12, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">Design Principles</a>
</li>
<li>4.   <a href="#rfc.section.4">API Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Pre-Establishment Phase</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Resolving Remote Endpoints</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Specifying Transport Parameters</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Protocol Selection Properties</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Protocol Properties</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Path Selection Properties</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">Socket Intents</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Specifying Cryptographic Parameters</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Establishing Connections</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Active Open: Initiate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Passive Open: Listen</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Peer to Peer Establishment: Rendezvous</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Groups</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Sending Data</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Send Properties</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Lifetime</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Niceness</a>
</li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">Ordered</a>
</li>
<li>7.1.4.   <a href="#rfc.section.7.1.4">Immediate</a>
</li>
<li>7.1.5.   <a href="#rfc.section.7.1.5">Idempotent</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Sender-side Framing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Receiving Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Application-Layer Backpressure at the Receiver</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Receiver-side Deframing over Stream Protocols</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Connection Termination</a>
</li>
<li>10.   <a href="#rfc.section.10">Event and Error Handling</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design principles of a new approach, which we outline in <a href="#principles" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.3">As a first step to realizing this design, <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a> describes a high-level architecture for transport services. This document builds a modern abstract programming interface atop this architecture, deriving specific path and protocol selection properties and supported transport features from the analysis provided in <a href="#RFC8095" class="xref">[RFC8095]</a> and <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology-and-notation" id="terminology-and-notation">Terminology and Notation</a>
</h1>
<p id="rfc.section.2.p.1">This API is described in terms of Objects, which an application can interact with; Actions the application can perform on these objects; Events, which an object can send to an application asynchronously; and Parameters associated with these Actions and Events.</p>
<p id="rfc.section.2.p.2">The following notations, which can be combined, are used in this document:</p>
<p></p>

<ul><li>Object := Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action creates an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object.Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action is performed on an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object -&gt; Event&lt;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Object sends an Event.</li></ul></li></ul>
<p></p>

<ul><li>Action(parameter, parameter, &#8230;) / Event&lt;parameter, parameter, &#8230;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action takes a set of Parameters; an Event contains a set of Parameters.</li></ul></li></ul>
<p id="rfc.section.2.p.11">Actions associated with no object are Actions on the abstract interface itself; they are equivalent to actions on a per-application global context.</p>
<p id="rfc.section.2.p.12">How these abstract concepts map into concrete implementations of this API in a given language on a given platform is largely dependent on the features of the language and the platform. Actions could be implemented as functions or method calls, for instance, and Events could be implemented via callback passing or other asynchronous calling conventions.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#principles" id="principles">Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">We begin with a set of initial design principles for the abstract interface to realize.</p>
<p></p>

<ul>
<li>Transport protocol stack independence in line with the Transport Services Architecture <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>, allowing applications to be written in terms of the semantics best for the application&#8217;s own design, separate from the protocol(s) used on the wire to achieve them. This enables applications written to a single API to make use of transport protocols in terms of the features they provide.</li>
<li>Explicit support for multistreaming and multipath transport protocols.</li>
<li>Explicit support for security properties as first-order transport features, and for long-term caching of cryptographic identities and parameters for associations among endpoints.</li>
<li>Atomic transmission of content, using application-assisted framing and deframing where the underlying transport does not provide these.</li>
<li>Asynchronous connection establishment, transmission, and reception, allowing most application interactions with the transport layer to be event-driven.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#api-summary" id="api-summary">API Summary</a>
</h1>
<p id="rfc.section.4.p.1">[TASK: write three paragraph summary here, should state how all this works for common cases from the application&#8217;s PoV.]</p>
<p id="rfc.section.4.p.2">In the following sections, we describe the details of application interaction with Objects through Actions and Events in each phase of a connection, following the phases described in <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#pre-establishment-phase" id="pre-establishment-phase">Pre-Establishment Phase</a>
</h1>
<p id="rfc.section.5.p.1">Establishment begins with the creation of a Connection&#8230;</p>
<p id="rfc.section.5.p.2">Connection := NewConnection(localSpecifier, remoteSpecifier, transportParameters, cryptographicParameters)</p>
<p id="rfc.section.5.p.3">[NOTE: note also that framers and deframers should be bound to connections during pre-establishment, forward-reference <a href="#send-framing" class="xref">Section 7.2</a> and <a href="#receive-framing" class="xref">Section 8.2</a>]</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#resolving" id="resolving">Resolving Remote Endpoints</a>
</h1>
<p id="rfc.section.5.1.p.1">Name resolution is no explicit step of a transport service API.  Therefore, name resolution may be deferred until connection establishment to incorporate transport parameters.  Instead, a remoteSpecifier object representing the remote endpoint is created providing an appropriate endpoint representation, which include IP addresses, hostnames and URLs:</p>
<p id="rfc.section.5.1.p.2">remoteSpecifier := Endpoint() remoteSpecifier.withUrl(&#8220;https://example.com&#8221;)</p>
<p id="rfc.section.5.1.p.3">remoteSpecifier := Endpoint() remoteSpecifier.withHostname(&#8220;example.com&#8221; remoteSpecifier.withService(&#8220;https&#8221;)</p>
<p id="rfc.section.5.1.p.4">remoteSpecifier := Endpoint() remoteSpecifier.withIPv6Address(2001:db8:4920:e29d:a420:7461:7073:0a) remoteSpecifier.withPort(443)</p>
<p id="rfc.section.5.1.p.5">remoteSpecifier := Endpoint() remoteSpecifier.withIPv4Address(192.0.2.21) remoteSpecifier.withPort(443)</p>
<p id="rfc.section.5.1.p.6">Implementations may also support additional endpoint representations and provide a single Endpoint() call that takes different endpoint representations.</p>
<p id="rfc.section.5.1.p.7">Endpoint representations may imply transport protocols, pseudotransport protocols, or families of protocols, e.g., remoteSpecifier.withUrl(&#8220;https://example.com&#8221;) implies either using HTTP over TLS over TCP or using HTTP over QUIC over UDP.  Whether the protocols implied by the endpoint representation are provided by the transport system is implementation specific, but MUST BE tunable using pre-establishment properties.  Implementations SHOULD provide all parts of the implied transport stack they implement unless specified otherwise using pre-establishment properties.  For example, the transport system may provide TLS over TCP in the above example and let the application implement HTTP pseudo-transport itself.</p>
<p id="rfc.section.5.1.p.8">[TASK: match with #initiate / #listen / #rendezvous and make sure the transport stack used is communicated ]</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#transport-params" id="transport-params">Specifying Transport Parameters</a>
</h1>
<p id="rfc.section.5.2.p.1">When creating a connection, an application needs to specify transport parameters reflecting its requirements and preferences regarding its communication. These Transport parameters include Protocol Selection Properties, Protocol Properties (configuration of a transport protocol once it has been selected), Path Selection Properties, and Socket Intents (hints to the TAPS system what to optimize for).</p>
<p id="rfc.section.5.2.p.2">Some Protocol Selection Properties are strict requirements that the application relies on, while others are hints of what transport features would be helpful for the application. For example, if an application asks for reliable data transfer, choosing a transport protocol such as UDP, which does not have this feature, will break the application&#8217;s functionality. On the other hand, the option to disable checksums when sending an individual message can help optimize for low latency, but if not present, it will most likely not break the fundamental assumptions of the application.</p>
<p id="rfc.section.5.2.p.3">Moreover, there can be conflicts between properties set by the application: If multiple features are requested which are offered by different protocols, it may not be possible to satisfy all requirements. Consequently, a TAPS system must prioritize transport parameters and consider the relevant trade-offs, see also <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.</p>
<p id="rfc.section.5.2.p.4">[Should it be possible for an application to specify which properties are most important to it, or to set properties as required?]</p>
<p id="rfc.section.5.2.p.5">There need to be sensible defaults for the Protocol Selection Properties. The defaults given in the following section represent a configuration that can be implemented over TCP. An alternate set of default Protocol Selection Properties would represent a configuration that can be implemented over UDP.</p>
<p id="rfc.section.5.2.p.6">Note that some parameters can also be set later in the lifetime of a connection. However, Protocol Selection Properties and Path Selection Properties must be specified before Initiate() to be useful. For other properties, it is beneficial for the application to set them as early as possible in order to help the TAPS system optimize.</p>
<p id="rfc.section.5.2.p.7">Connections can be cloned at any time, before or after establishment.  A cloned connection and its parent are entangled: they share the same properties, changing any parameter for one of them also changes the parameter for the other, connecting one of them also connects the other, etc. There is only one exception: priority assignment ((see also <a href="#groups" class="xref">Section 6.4</a> for more details).  Cloning connections during pre-establishment is encouraged, as it informs the transport system about the intent to use Connection Groups.</p>
<p id="rfc.section.5.2.p.8">Connection := Create(ProtocolSelectionProperties, ProtocolProperties, PathSelectionProperties, SocketIntents)</p>
<p id="rfc.section.5.2.p.9">Connection.Configure(ProtocolProperties, SocketIntents)</p>
<p id="rfc.section.5.2.p.10">Connection.QueryProperties()</p>
<p id="rfc.section.5.2.p.11">Connection := Connection.Clone()</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#protocol-selection-props" id="protocol-selection-props">Protocol Selection Properties</a>
</h1>
<p id="rfc.section.5.2.1.p.1">Reliable Data Transfer</p>
<p id="rfc.section.5.2.1.p.2">This boolean property specifies whether the application needs the transport protocol to ensure that data is received completely and without corruption on the other side. This property applies to connections and connection groups.  This is a strict requirement. The default is to enable Reliable Data Transfer.</p>
<p id="rfc.section.5.2.1.p.3">Notification of peer closing/aborting</p>
<p id="rfc.section.5.2.1.p.4">This boolean property specifies whether the application needs the transport protocol to inform it in case the connection terminates. This property applies to connections and connection groups. This is a strict requirement. The default is to enable such notifications.</p>
<p id="rfc.section.5.2.1.p.5">Preservation of data ordering</p>
<p id="rfc.section.5.2.1.p.6">This boolean property specifies whether the application needs the transport protocol to assure that data is received by the application on the other end in the same order as it was sent. This property applies to connections and connection groups. This is a strict requirement. The default is to preserve data ordering.</p>
<p id="rfc.section.5.2.1.p.7">Option to configure reliability for individual messages</p>
<p id="rfc.section.5.2.1.p.8">This boolean property specifies whether an application considers it useful to indicate its reliability requirements on a per-message basis. This property applies to connections and connection groups. This is not a strict requirement.  The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.9">Option of unordered message delivery</p>
<p id="rfc.section.5.2.1.p.10">This boolean property specifies whether an application allows messages to be delivered in a different order than they were sent, potentially at the benefit of lower latency for individual messages. This property applies to connections and connection groups. This is not a strict requirement. The default is to not have this option, so all data arrives strictly in-order.</p>
<p id="rfc.section.5.2.1.p.11">Option to request not to delay acknowledgement (SACK) of a message</p>
<p id="rfc.section.5.2.1.p.12">This boolean property specifies whether an application considers it useful to request for a message that its acknowledgement be sent out as early as possible (SACK) instead of potentially being bundled with other acknowledgements. This property applies to connections and connection groups. This is not a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.13">Option to hand over a message to reliably transfer (possibly multiple times) before connection establishment (0-RTT idempotent)</p>
<p id="rfc.section.5.2.1.p.14">This boolean property specifies whether an application would like to supply a message to the transport protocol before connection establishment, which will then be reliably transferred to the other side before or during connection establishment, potentially multiple times. See also <a href="#send-idempotent" class="xref">Section 7.1.5</a>. This property applies to connections and connection groups. This is a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.15">Option to assign priority or weight per connection in a group</p>
<p id="rfc.section.5.2.1.p.16">This boolean property specifies whether an application considers it useful to have the option to explicitly prioritize between multiple connections within a connection group. This property applies to connection groups. This is not a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.17">Option to choose a scheduler between connections in a group</p>
<p id="rfc.section.5.2.1.p.18">This boolean property specifies whether an application considers it useful to have the option to explicitly set a scheduler between the connections within a connection group. This property applies to connection groups. This is not a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.19">Suggest a timeout to the peer</p>
<p id="rfc.section.5.2.1.p.20">This boolean property specifies whether an application considers it useful to propose a timeout until the connection is assumed to be lost. This property applies to connections and connection groups. This is not a strict requirement. The default is to have this option.</p>
<p id="rfc.section.5.2.1.p.21">Notification of excessive retransmissions (early warning before abortion threshold)</p>
<p id="rfc.section.5.2.1.p.22">This boolean property specifies whether an application considers it useful to be informed in case sent data was retransmitted more often than a certain threshold. This property applies to connections and connection groups. This is not a strict requirement. The default is to have this option.</p>
<p id="rfc.section.5.2.1.p.23">Notification of ICMP error message arrival</p>
<p id="rfc.section.5.2.1.p.24">This boolean property specifies whether an application considers it useful to be informed in case an ICMP error message is received related to this connection. This property applies to connections and connection groups. This is not a strict requirement. The default is to have this option.</p>
<p id="rfc.section.5.2.1.p.25">Specify checksum coverage used by sender</p>
<p id="rfc.section.5.2.1.p.26">This boolean property specifies whether the application considers it useful to have the option to specify what parts of the transmitted data should be covered by the transport protocol checksum. This property applies to connections and connection groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without being able to change it.</p>
<p id="rfc.section.5.2.1.p.27">Option to disable checksum when sending an individual message</p>
<p id="rfc.section.5.2.1.p.28">This boolean property specifies whether the application considers it useful to have the option to disable checksums for individual messages. This property applies to connections and connection groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without the option to disable it.</p>
<p id="rfc.section.5.2.1.p.29">Specify minimum checksum coverage required by receiver</p>
<p id="rfc.section.5.2.1.p.30">This boolean property specifies whether the application considers it useful to have the option to specify what parts of the received data it needs to be covered by the checksum. This property applies to connections and connection groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without being able to change it.</p>
<p id="rfc.section.5.2.1.p.31">Option to disable checksum requirement when receiving an individual message</p>
<p id="rfc.section.5.2.1.p.32">This boolean property specifies whether an application considers it useful to have the option to communicate to the remote endpoint that it does not require an individual message to be covered by a checksum. This property applies to connections and connection groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without the option to disable it.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#protocol-props" id="protocol-props">Protocol Properties</a>
</h1>
<p id="rfc.section.5.2.2.p.1">Protocol Properties represent the configuration of a transport protocols once it has been selected. A transport protocol may not support all Protocol Properties, depending on the available transport features. An application should specify the Protocol Properties as early as possible to help the TAPS system optimize. However, a TAPS system will only actually set those protocol properties that are actually supported by the chosen transport protocol. Some of these properties can also be set on individual messages, similar to the properties in <a href="#send-props" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.5.2.2.p.2">The default settings of these properties depends on the chosen protocol and on the system configuration.</p>
<p id="rfc.section.5.2.2.p.3">Set timeout for aborting connection</p>
<p id="rfc.section.5.2.2.p.4">This numeric property specifies how long to wait before aborting a connection.  It is given in seconds. This property applies to connections and connection groups.</p>
<p id="rfc.section.5.2.2.p.5">Set timeout to suggest to the peer</p>
<p id="rfc.section.5.2.2.p.6">This numeric property specifies the timeout to propose to the peer. It is given in seconds. This property applies to connections and connection groups.</p>
<p id="rfc.section.5.2.2.p.7">Set retransmissions before &#8220;Excessive Retransmissions&#8221;</p>
<p id="rfc.section.5.2.2.p.8">This numeric property specifies after how many retransmissions to inform the application about &#8220;Excessive Retransmissions&#8221;. It applies to connections and connection groups.</p>
<p id="rfc.section.5.2.2.p.9">Set whether to use a checksum for sending</p>
<p id="rfc.section.5.2.2.p.10">This boolean property specifies whether to use a checksum for sending messages on this connection. The default is to use checksums. This property applies to connections, connection groups, and messages.</p>
<p id="rfc.section.5.2.2.p.11">Set length of send checksum</p>
<p id="rfc.section.5.2.2.p.12">This numeric property specifies the length of the checksum of messages sent on this connection. It is given in Bytes. This property applies to connections, connection groups, and messages.</p>
<p id="rfc.section.5.2.2.p.13">Set whether to require a checksum for receiving</p>
<p id="rfc.section.5.2.2.p.14">This boolean property specifies whether to communicate to the remote endpoint that it does not require messages on this connection to be covered by a checksum. This property applies to connections, connection groups, and messages.</p>
<p id="rfc.section.5.2.2.p.15">Set required minimum coverage of the checksum</p>
<p id="rfc.section.5.2.2.p.16">This numeric property specifies the part of the received data that needs to be covered by a checksum. It is given in Bytes. This property applies to connections, connection groups, and messages.</p>
<p id="rfc.section.5.2.2.p.17">Set scheduler for connections in a group</p>
<p id="rfc.section.5.2.2.p.18">This property specifies which scheduler should be used among connections within a connection group. It applies to connection groups. For now we suggest we suggest the schedulers defined in <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</p>
<p id="rfc.section.5.2.2.p.19">Configure the priority of a connection for the scheduler</p>
<p id="rfc.section.5.2.2.p.20">This property specifies what priority to assign to a connection within a connection group. It applies to a connection. We suggest the priority as described in <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</p>
<p id="rfc.section.5.2.2.p.21">Set low watermark for buffer to nofity the application</p>
<p id="rfc.section.5.2.2.p.22">This numeric property specifies the buffer threshold below which the application wants to be informed. It is given in Bytes. This property applies to connections and connection group.</p>
<p id="rfc.section.5.2.2.p.23">Maximum Message Size Before Connection Establishment</p>
<p id="rfc.section.5.2.2.p.24">This numeric property can be queried by the application after creating a connection. It represents the maximum message size that can be sent before or during connection establishment, see also <a href="#send-idempotent" class="xref">Section 7.1.5</a>. It is given in Bytes.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#path-selection-props" id="path-selection-props">Path Selection Properties</a>
</h1>
<p id="rfc.section.5.2.3.p.1">Not all transport protocols work on all paths. Thus, transport protocol selection is tied to path selection, which may involve choosing between multiple local interfaces that are connected to different access networks.</p>
<p id="rfc.section.5.2.3.p.2">Path Selection Properties are requirements, prohibitions, or preferences, that an application has regarding path selection. These properties should be specified as early as possible in order to help the TAPS system optimize.  However, they may also be specified later.</p>
<p id="rfc.section.5.2.3.p.3">Interface Type to prefer</p>
<p id="rfc.section.5.2.3.p.4">This property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to prefer over others for this connection, in case they are available.  This is not a strict requirement. The default is to use the default interface configured in the system policy.</p>
<p id="rfc.section.5.2.3.p.5">Interface Type to prohibit</p>
<p id="rfc.section.5.2.3.p.6">This property specifies which kind of access network interface, e.g., WiFi, Ethternet, or LTE, to not use for this connection. This is a strict requirement and connection establishment will fail if no other interface is available. The default is to not prohibit any particular interface.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> <a href="#socket-intents" id="socket-intents">Socket Intents</a>
</h1>
<p id="rfc.section.5.2.4.p.1">Socket Intents are a group of properties expressing what an application wants to achieve, knows, assumes or prefers regarding its communication. They are not strict requirements. In particular, they should not be used to express any Quality of Service expectations that an application might have. Instead, an application should express its intentions and its expected traffic characteristics in order to help the TAPS system make decisions that best match it, but on a best-effort basis. Even though Socket Intents do not represent Quality of Service requirements, a TAPS system may use them to determine a DSCP value, e.g. similar to Table 1 in <a href="#I-D.ietf-tsvwg-rtcweb-qos" class="xref">[I-D.ietf-tsvwg-rtcweb-qos]</a>.</p>
<p id="rfc.section.5.2.4.p.2">Socket Intents can influence protocol selection, protocol configuration, path selection, and endpoint selection. For example, setting the &#8220;Timeliness&#8221; Intent to &#8220;Interactive&#8221; may lead the TAPS system to disable the Nagle algorithm for a connection, while setting the &#8220;Timeliness&#8221; to &#8220;Background&#8221; may lead it to setting the DSCP value to &#8220;scavenger&#8221;. If the &#8220;Size to be Sent&#8221; Intent is set on a series of messages, it may influence path selection, e.g., when the TAPS system schedules big messages over an interface with higher bandwidth, and small messages over an interface with lower latency.</p>
<p id="rfc.section.5.2.4.p.3">Specifying Socket Intents is not mandatory. An application can specify any combination of Socket Intents. All Socket Intents can be specified for connections and connection groups. Some Intents can also be specified for individual messages, similar to the properties in <a href="#send-props" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.5.2.4.p.4">Traffic Category</p>
<p id="rfc.section.5.2.4.p.5">This Intent specifies what the application expect the dominating traffic pattern to be. It applies to connections and connection groups</p>
<p id="rfc.section.5.2.4.p.6">Possible Category values are:</p>
<p></p>

<dl>
<dt>Query:</dt>
<dd style="margin-left: 8">Single request / response style workload, latency bound</dd>
<dt>Control:</dt>
<dd style="margin-left: 8">Long lasting low bandwidth control channel, not bandwidth bound</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">Stream of bytes/messages with steady data rate</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Bulk transfer of large messages, presumably bandwidth bound</dd>
</dl>
<p id="rfc.section.5.2.4.p.8">The default is to not assume any particular traffic pattern. Most categories suggest the use of other intents to further describe the traffic pattern anticipated, e.g., the bulk category suggesting the use of the Message Size intents or the stream category suggesting the Stream Bitrate and Duration intents.</p>
<p id="rfc.section.5.2.4.p.9">Size to be Sent / Received</p>
<p id="rfc.section.5.2.4.p.10">This Intent specifies what the application expects the size of a transfer to be.  It is a numeric property and given in Bytes. It can also apply to individual messages.</p>
<p id="rfc.section.5.2.4.p.11">Duration</p>
<p id="rfc.section.5.2.4.p.12">This Intent specifies what the application expects the lifetime of a transfer to be. It is a numeric property and given in milliseconds. It applies to connections and connection groups.</p>
<p id="rfc.section.5.2.4.p.13">Stream Bitrate Sent / Received</p>
<p id="rfc.section.5.2.4.p.14">This Intent specifies what the application expects the bitrate of a transfer to be. It is a numeric property and given in Bytes per second. It applies to connections and connection groups.</p>
<p id="rfc.section.5.2.4.p.15">Burstiness</p>
<p id="rfc.section.5.2.4.p.16">This Intent specifies what the application expects the sender-side burst characteristics of the traffic to be. The application can provide hints about the anticipated communication pattern, i.e., how it expects the number of sent bytes to vary over time and the expected length of sequences of consecutively sent messages. Note that the actual burst characteristics will depend on the network, especially at the receiver side. This Intents applies to connections and connection groups.</p>
<p id="rfc.section.5.2.4.p.17">Possible Burstiness values are:</p>
<p></p>

<dl>
<dt>No Bursts:</dt>
<dd style="margin-left: 8">Application sends traffic at a constant rate</dd>
<dt>Regular Bursts:</dt>
<dd style="margin-left: 8">Application sends bursts of traffic periodically</dd>
<dt>Random Bursts:</dt>
<dd style="margin-left: 8">Application sends bursts of traffic irregularly</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Application sends a bulk of traffic</dd>
</dl>
<p id="rfc.section.5.2.4.p.19">The default is to not assume any particular burst characteristics.</p>
<p id="rfc.section.5.2.4.p.20">Timeliness</p>
<p id="rfc.section.5.2.4.p.21">This Intent specifies what delay characteristcs the applications prefers. It provides hints for the TAPS system whether to optimize for low latency or other criteria. Note that setting this Intents does not imply any guarantees on whether an application&#8217;s requirements can actually be satisfied. This Intents applies to connections, connection groups, or messages.</p>
<p></p>

<dl>
<dt>Stream:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be kept as low as possible</dd>
<dt>Interactive:</dt>
<dd style="margin-left: 8">Delay should be kept as low as possible, but some variation is tolerable</dd>
<dt>Transfer:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be reasonable, but are not critical</dd>
<dt>Background:</dt>
<dd style="margin-left: 8">Delay and packet delay variation is no concern</dd>
</dl>
<p id="rfc.section.5.2.4.p.23">The default is &#8220;Transfer&#8221;.</p>
<p id="rfc.section.5.2.4.p.24">Disruption Resilience</p>
<p id="rfc.section.5.2.4.p.25">This Intent describes what an application knows about its own ability to deal with disruption of its communication, e.g., connection loss. It provides hints of how well an application assumes it can recover from such disturbances and can have an impact on the tradeoff between providing failover techniques and resource utilization. This Intent applies to connections, connection groups, and messages.</p>
<p></p>

<dl>
<dt>Sensitive:</dt>
<dd style="margin-left: 8">Disruptions result in application failure, disrupting user experience</dd>
<dt>Recoverable:</dt>
<dd style="margin-left: 8">Disruptions are inconvenient for the application, but can be recovered from</dd>
<dt>Resilient:</dt>
<dd style="margin-left: 8">Disruptions have minimal impact for the application</dd>
</dl>
<p id="rfc.section.5.2.4.p.27">The default is &#8220;Sensitive&#8221;.</p>
<p id="rfc.section.5.2.4.p.28">Cost Preferences</p>
<p id="rfc.section.5.2.4.p.29">This Intent describes what an application prefers regarding monetary costs, e.g., whether it considers it acceptable to utilize limited data volume. It provides hints to the TAPS system on how to handle tradeoffs between cost and performance or reliability.  This Intent applies to connections, connection groups, and messages.</p>
<p></p>

<dl>
<dt>No Expense:</dt>
<dd style="margin-left: 8">Avoid transports associated with monetary cost</dd>
<dt>Optimize Cost:</dt>
<dd style="margin-left: 8">Prefer inexpensive transports and accept service degradation</dd>
<dt>Balance Cost:</dt>
<dd style="margin-left: 8">Use system policy to balance cost and other criteria</dd>
<dt>Ignore Cost:</dt>
<dd style="margin-left: 8">Ignore cost, choose transport solely based on other criteria</dd>
</dl>
<p id="rfc.section.5.2.4.p.31">The default is &#8220;Balance Cost&#8221;.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#crypto-params" id="crypto-params">Specifying Cryptographic Parameters</a>
</h1>
<p id="rfc.section.5.3.p.1">[TASK: write me. separate out cryptographic parameters, since these bind to a local and a remote. chris?]</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#establishing-connections" id="establishing-connections">Establishing Connections</a>
</h1>
<p id="rfc.section.6.p.1">Before a Connection can be used for data transfer, it must be established.  Establishment ends the pre-establishment phase; all transport and cryptographic parameter specification must be complete before establishment, as these parameters will be used to select candidate Paths and Protocol Stacks for the Connection. Establishment may be active, using the Initiate() Action; passive, using the Listen() Action; or simultaneous for peer-to-peer, using the Rendezvous() Action. These Actions are described in the subsections below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#initiate" id="initiate">Active Open: Initiate</a>
</h1>
<p id="rfc.section.6.1.p.1">Active open is the action of establishing a connection to an endpoint presumed to be listening for incoming connection requests, commonly used by clients in client-server interactions. Active open is supported by this interface through the Initiate action:</p>
<p id="rfc.section.6.1.p.2">Connection.Initiate()</p>
<p id="rfc.section.6.1.p.3">Before calling Initiate, the caller must have initialized the Connection during the pre-establishment phase with local and remote endpoint specifiers, as well as all parameters necessary for candidate selection. After calling Initiate, no further parameters may be bound to the Connection, and no subsequent establishment call may be made on the Connection.</p>
<p id="rfc.section.6.1.p.4">Once Initiate is called, the candidate Protocol Stack(s) may cause one or more transport-layer connections to be created to the specified remote endpoint.  The caller may immediately begin sending Content on the Connection (see <a href="#sending" class="xref">Section 7</a>) after calling Initate, though it may wait for one of the following events before doing so.</p>
<p id="rfc.section.6.1.p.5">Connection -&gt; Ready&lt;&gt;</p>
<p id="rfc.section.6.1.p.6">The Ready event occurs after Initiate has established a transport-layer connection on at least one usable candidate Protocol Stack over at least one candidate Path. No Receive events (see <a href="#receiving" class="xref">Section 8</a>) will occur until after the Ready event for connections established using Initiate.</p>
<p id="rfc.section.6.1.p.7">Connection -&gt; InitiateError&lt;&gt;</p>
<p id="rfc.section.6.1.p.8">An InitiateError occurs either when the set of local and remote specifiers and transport and cryptographic parameters cannot be fulfilled on a connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty), when the remote specifier cannot be resolved, or when no transport-layer connection can be established to the remote endpoint (e.g.  because the remote endpoint is not accepting connections, or the application is prohibited from opening a connection by the operating system).</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#listen" id="listen">Passive Open: Listen</a>
</h1>
<p id="rfc.section.6.2.p.1">Passive open is the action of waiting for connections from remote endpoints, commonly used by servers in client-server interactions. Passive open is supported by this interface through the Listen action:</p>
<p id="rfc.section.6.2.p.2">Connection.Listen()</p>
<p id="rfc.section.6.2.p.3">Before calling Listen, the caller must have initialized the Connection during the pre-establishment phase with local endpoint specifiers, as well as all parameters necessary for Protocol Stack selection. After calling Listen, no further parameters may be bound to the Connection, and no subsequent establishment call may be made on the Connection.</p>
<p id="rfc.section.6.2.p.4">Connection -&gt; ConnectionReceived&lt;Connection&gt;</p>
<p id="rfc.section.6.2.p.5">The ConnectionReceived event occurs when a remote endpoint has established a transport-layer connection to this Connection, causing a new Connection to be created. The resulting Connection is contained within the ConnectionReceived event, and is ready to use as soon as it is passed to the application via the event.</p>
<p id="rfc.section.6.2.p.6">Connection -&gt; ListenError&lt;&gt;</p>
<p id="rfc.section.6.2.p.7">A ListenError occurs either when the set of local specifier, transport and cryptographic parameters cannot be fulfilled for listening, when the local specifier cannot be resolved, or when the application is prohibited from listening by the operating system.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#rendezvous" id="rendezvous">Peer to Peer Establishment: Rendezvous</a>
</h1>
<p id="rfc.section.6.3.p.1">Connection.Rendezvous()</p>
<p id="rfc.section.6.3.p.2">Connection -&gt; Ready&lt;&gt;</p>
<p id="rfc.section.6.3.p.3">Connection -&gt; RendezvousError&lt;&gt;</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#groups" id="groups">Connection Groups</a>
</h1>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sending" id="sending">Sending Data</a>
</h1>
<p id="rfc.section.7.p.1">Once a Connection has been established, it can be used for sending data. Data is sent by passing a Content object and additional properties <a href="#send-props" class="xref">Section 7.1</a> to the Send action on an established connection:</p>
<p id="rfc.section.7.p.2">Connection.Send(Content, &#8230;)</p>
<p id="rfc.section.7.p.3">The type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. It may itself contain an array of octets to be transmitted in the transport protocol payload, or be transformable to an array of octets by a sender-side framer (see <a href="#send-framing" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.7.p.4">If Send is called on a Connection which has not yet been established, an Initiate action will be implicitly performed simultaneously with the Send.  Used together with the Idempotent property (see <a href="#send-idempotent" class="xref">Section 7.1.5</a>), this can be used to send data during establishment for 0-RTT session resumption on Protocol Stacks that support it.</p>
<p id="rfc.section.7.p.5">Like all Actions in this interface, the Send action is asynchronous. However, a Send call may block until there is sufficient buffer space in the implementation and/or the underlying Protocol Stack to handle the Content, in order to provide sender-side backpressure to the application when transmission is limited by transport channel capacity.</p>
<p id="rfc.section.7.p.6">Connection -&gt; Sent&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.7">The Sent event occurs when a previous Send action has completed, i.e. when the data derived from the Content has been passed down or through the underlying Protocol Stack and is no longer the responsbility of the implementation of this interface. The exact disposition of Content when the Sent event occurs is specific to the implementation and the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Sent event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.8">Connection -&gt; Expired&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.9">The Expired event occurs when a previous Send action expired before completion; i.e. when the data derived from the Content was not sent before its Lifetime (see <a href="#send-lifetime" class="xref">Section 7.1.1</a>) expired. This is separate from SendError, as it is an expected behavior for partially reliable transports. The Expired event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.10">Connection -&gt; SendError&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.11">A SendError occurs when Content could not be sent due to an error condition: some failure of the underlying Protocol Stack, or a set of send parameters not consistent with the Connection&#8217;s transport parameters.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#send-props" id="send-props">Send Properties</a>
</h1>
<p id="rfc.section.7.1.p.1">The Send action takes five per-Content properties which control how it will be sent down to the underlying Protocol Stack and transmitted. Note that some of these properties are not compatible with transport parameters; attempting to Send with such an incompatibility yields a SendError.</p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#send-lifetime" id="send-lifetime">Lifetime</a>
</h1>
<p id="rfc.section.7.1.1.p.1">Lifetime specifies how long a particular Content can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted. When a Content&#8217;s Lifetime is infinite, it must be transmitted reliably. The type and units of Lifetime are implementation-specific.</p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#send-niceness" id="send-niceness">Niceness</a>
</h1>
<p id="rfc.section.7.1.2.p.1">Niceness represents an unbounded hierarchy of priorities of Content, relative to other Content sent over the same Connection and/or Connection Group (see <a href="#groups" class="xref">Section 6.4</a>). It is most naturally represented as a non-negative integer.  Content with Niceness 0 will yield to Content with Niceness 1, which will yield to Content with Niceness 2, and so on. Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.</p>
<p id="rfc.section.7.1.2.p.2">Note that this inversion of normal schemes for expressing priority has a convenient property: priority increases as both Niceness and Lifetime decrease.</p>
<h1 id="rfc.section.7.1.3">
<a href="#rfc.section.7.1.3">7.1.3.</a> <a href="#send-ordered" id="send-ordered">Ordered</a>
</h1>
<p id="rfc.section.7.1.3.p.1">Ordered is a boolean property. If true, this Content should be delivered after the last Content passed to the same Connection via the Send action; if false, this Content may be delivered before the last Content passed to the same Connection.</p>
<h1 id="rfc.section.7.1.4">
<a href="#rfc.section.7.1.4">7.1.4.</a> <a href="#send-immediate" id="send-immediate">Immediate</a>
</h1>
<p id="rfc.section.7.1.4.p.1">Immediate is a boolean property. If true, the caller prefers immediacy to efficiency for this Content, and the Content should not be bundled with other Content into the same transmission by the underlying Protocol Stack.</p>
<h1 id="rfc.section.7.1.5">
<a href="#rfc.section.7.1.5">7.1.5.</a> <a href="#send-idempotent" id="send-idempotent">Idempotent</a>
</h1>
<p id="rfc.section.7.1.5.p.1">Idempotent is a boolean property. If true, the application-layer entity in the Content is safe to send to the remote endpoint more than once for a single Send action. It is used to mark data safe for certain 0-RTT establishment techniques, where retransmission of the 0-RTT data may cause the remote application to receive the Content multiple times.</p>
<p id="rfc.section.7.1.5.p.2">[NOTE: we need some way to signal to the transport that we want to wait for 0RTT data on Initiate. Probably a transport parameter]</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#send-framing" id="send-framing">Sender-side Framing</a>
</h1>
<p id="rfc.section.7.2.p.1">Sender-side framing allows a caller to provide the interface with a function that takes Content of an appropriate type and returns an array of octets, the on-the-wire representation of the content to be handed down to the Protocol Stack. It consists of a Framer object with a single Action, Frame. Since the Framer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.7.2.p.2">Connection.FrameWith(Framer)</p>
<p id="rfc.section.7.2.p.3">OctetArray := Framer.Frame(Content)</p>
<p id="rfc.section.7.2.p.4">Sender-side framing is a convenience feature of the interface, for parity with receiver-side framing (see <a href="#receive-framing" class="xref">Section 8.2</a>).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#receiving" id="receiving">Receiving Data</a>
</h1>
<p id="rfc.section.8.p.1">Once a Connection is established, Content may be received on it. The interface notifies the application that content has been received via the Received event:</p>
<p id="rfc.section.8.p.2">Connection -&gt; Received&lt;Content&gt;</p>
<p id="rfc.section.8.p.3">As with sending, the type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Content may also contain metadata from protocols in the Protocol Stack for logging and debugging purposes.</p>
<p id="rfc.section.8.p.4">The Content object must provide some method to retrieve an octet array containing application data, corresponding to a single message within the underlying Protocol Stack&#8217;s framing.  See <a href="#receive-framing" class="xref">Section 8.2</a> for handling framing in situations where the Protocol Stack provides octet-stream transport only.</p>
<p id="rfc.section.8.p.5">Connection -&gt; ReceiveError&lt;&gt;</p>
<p id="rfc.section.8.p.6">A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or deframed, or when some other indication is recieved that reception has failed. Such conditions that irrevocably lead the the termination of the Connection are signaled using ConnectionError instead (see <a href="#termination" class="xref">Section 9</a>).</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#receive-backpressure" id="receive-backpressure">Application-Layer Backpressure at the Receiver</a>
</h1>
<p id="rfc.section.8.1.p.1">Implementations of this interface must provide some way for the application to indicate that it is temporarily not ready to receive new Content. Since the mechanisms of event handling are implementation-platform specific, this document does not specify the exact nature of this</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#receive-framing" id="receive-framing">Receiver-side Deframing over Stream Protocols</a>
</h1>
<p id="rfc.section.8.2.p.1">The Receive event is intended to be fired once per application-layer Content sent by the remote endpoint; i.e., it is a desired property of this interface that a Send at one end of a Connection maps to exactly one Receive on the other end. This is possible with Protocol Stacks that provide a mechanism message boundary preservation, but is not the case over Protocol Stacks that provide a simple octet stream transport.</p>
<p id="rfc.section.8.2.p.2">For preserving message boundaries over stream transports, this interface provides receiver-side deframing. This facility is based on the observation that, since many of our current application protocols evolved over TCP, which does not provide message boundary preservation, and since many these protocols require message boundaries to function, each application layer protocol has defined its own framing. A Deframer allows an application to push this deframing down into the interface, in order to transform an octet stream into a sequence of Content.</p>
<p id="rfc.section.8.2.p.3">Concretely, receiver-side deframing allows a caller to provide the interface with a function that takes an octet stream, as provided by the underlying Protocol Stack, reads and returns a sigle Content of an appropriate type for the application and platform, and leaves the octet stream at the start of the next Content. It consists of a Deframer object with a single Action, Deframe.  Since the Deframer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.8.2.p.4">Connection.DeframeWith(Deframer)</p>
<p id="rfc.section.8.2.p.5">Content := Deframer.Deframe(OctetStream, &#8230;)</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.9.p.1">Connection.Close()</p>
<p id="rfc.section.9.p.2">Connection -&gt; Finished&lt;&gt;</p>
<p id="rfc.section.9.p.3">Connection.Abort()</p>
<p id="rfc.section.9.p.4">Connection -&gt; ConnectionError&lt;&gt;</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#event-and-error-handling" id="event-and-error-handling">Event and Error Handling</a>
</h1>
<p id="rfc.section.10.p.1">[NOTE: point out that events and errors may be handled differently, although they are the modeled the same in this specification.]</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.11.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">be paranoid</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-rtcweb-qos">[I-D.ietf-tsvwg-rtcweb-qos]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Dhesikan, S.</a>, <a>Jennings, C.</a> and <a>D. Druta</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">DSCP Packet Markings for WebRTC QoS</a>", Internet-Draft draft-ietf-tsvwg-rtcweb-qos-18, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-sctp-ndata">[I-D.ietf-tsvwg-sctp-ndata]</b></td>
<td class="top">
<a>Stewart, R.</a>, <a>Tuexen, M.</a>, <a>Loreto, S.</a> and <a>R. Seggelmann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13">Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</a>", Internet-Draft draft-ietf-tsvwg-sctp-ndata-13, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-ARCH">[TAPS-ARCH]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Trammell, B.</a>, <a>Brunstrom, A.</a>, <a>Fairhurst, G.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a>An Architecture for Transport Services</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-MINSET">[TAPS-MINSET]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-01">A Minimal Set of Transport Services for TAPS Systems</a>", Internet-Draft draft-ietf-taps-minset-01, February 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael Welzl</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Welzl</span>
	  </span>
	</span>
	<span class="org vcardline">University of Oslo</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	
  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Gorry Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
