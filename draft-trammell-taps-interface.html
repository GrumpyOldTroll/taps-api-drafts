<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Abstract Application Layer Interface to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 Design Principles">
<link href="#rfc.section.4" rel="Chapter" title="4 API Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-Establishment Phase">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Specifying Endpoints">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Specifying Transport Parameters">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Protocol Selection Properties">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Protocol Properties">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Path Selection Properties">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 Application Intents">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Specifying Security Parameters and Callbacks">
<link href="#rfc.section.6" rel="Chapter" title="6 Establishing Connections">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Active Open: Initiate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Passive Open: Listen">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Peer to Peer Establishment: Rendezvous">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Groups">
<link href="#rfc.section.7" rel="Chapter" title="7 Sending Data">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Send Properties">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Lifetime">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Niceness">
<link href="#rfc.section.7.1.3" rel="Chapter" title="7.1.3 Ordered">
<link href="#rfc.section.7.1.4" rel="Chapter" title="7.1.4 Immediate">
<link href="#rfc.section.7.1.5" rel="Chapter" title="7.1.5 Idempotent">
<link href="#rfc.section.7.1.6" rel="Chapter" title="7.1.6 Checksum">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Sender-side Framing">
<link href="#rfc.section.8" rel="Chapter" title="8 Receiving Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Application-Layer Backpressure at the Receiver">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Receiver-side Deframing over Stream Protocols">
<link href="#rfc.section.9" rel="Chapter" title="9 Connection Termination">
<link href="#rfc.section.10" rel="Chapter" title="10 Event and Error Handling">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="14 References">
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Transport Parameters">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Application Preferences">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Specifying and Querying Properties">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Ed., Welzl, M., Ed., Fairhurst, G., Kuehlewind, M., Perkins, C., Tiesel, P., Enghardt, T., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-taps-interface-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-02-14" />
  <meta name="dct.abstract" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />
  <meta name="description" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Welzl, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 18, 2018</td>
<td class="right">University of Oslo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 14, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Abstract Application Layer Interface to Transport Services<br />
  <span class="filename">draft-trammell-taps-interface-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 18, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">Design Principles</a>
</li>
<li>4.   <a href="#rfc.section.4">API Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Pre-Establishment Phase</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Specifying Endpoints</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Specifying Transport Parameters</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Protocol Selection Properties</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Protocol Properties</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Path Selection Properties</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">Application Intents</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Specifying Security Parameters and Callbacks</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Establishing Connections</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Active Open: Initiate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Passive Open: Listen</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Peer to Peer Establishment: Rendezvous</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Groups</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Sending Data</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Send Properties</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Lifetime</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Niceness</a>
</li>
<li>7.1.3.   <a href="#rfc.section.7.1.3">Ordered</a>
</li>
<li>7.1.4.   <a href="#rfc.section.7.1.4">Immediate</a>
</li>
<li>7.1.5.   <a href="#rfc.section.7.1.5">Idempotent</a>
</li>
<li>7.1.6.   <a href="#rfc.section.7.1.6">Checksum</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Sender-side Framing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Receiving Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Application-Layer Backpressure at the Receiver</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Receiver-side Deframing over Stream Protocols</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Connection Termination</a>
</li>
<li>10.   <a href="#rfc.section.10">Event and Error Handling</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Acknowledgements</a>
</li>
<li>14.   <a href="#rfc.references">References</a>
</li>
<ul><li>14.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Transport Parameters</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Application Preferences</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Specifying and Querying Properties</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design principles of a new approach, which we outline in <a href="#principles" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.3">As a first step to realizing this design, <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a> describes a high-level architecture for transport services. This document builds a modern abstract programming interface atop this architecture, deriving specific path and protocol selection properties and supported transport features from the analysis provided in <a href="#RFC8095" class="xref">[RFC8095]</a> and <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology-and-notation" id="terminology-and-notation">Terminology and Notation</a>
</h1>
<p id="rfc.section.2.p.1">This API is described in terms of Objects, which an application can interact with; Actions the application can perform on these objects; Events, which an object can send to an application asynchronously; and Parameters associated with these Actions and Events.</p>
<p id="rfc.section.2.p.2">The following notations, which can be combined, are used in this document:</p>
<p></p>

<ul><li>Object := Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action creates an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object.Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action is performed on an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object -&gt; Event&lt;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Object sends an Event.</li></ul></li></ul>
<p></p>

<ul><li>Action(parameter, parameter, &#8230;) / Event&lt;parameter, parameter, &#8230;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action takes a set of Parameters; an Event contains a set of Parameters.</li></ul></li></ul>
<p id="rfc.section.2.p.11">Actions associated with no object are Actions on the abstract interface itself; they are equivalent to actions on a per-application global context.</p>
<p id="rfc.section.2.p.12">How these abstract concepts map into concrete implementations of this API in a given language on a given platform is largely dependent on the features of the language and the platform. Actions could be implemented as functions or method calls, for instance, and Events could be implemented via callback passing or other asynchronous calling conventions.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#principles" id="principles">Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">We begin with a set of initial design principles for the abstract interface to realize.</p>
<p></p>

<ul>
<li>Transport protocol stack independence in line with the Transport Services Architecture <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>, allowing applications to be written in terms of the semantics best for the application&#8217;s own design, separate from the protocol(s) used on the wire to achieve them. This enables applications written to a single API to make use of transport protocols in terms of the features they provide.</li>
<li>Explicit support for multistreaming and multipath transport protocols.</li>
<li>Explicit support for security properties as first-order transport features, and for long-term caching of cryptographic identities and parameters for associations among endpoints.</li>
<li>Atomic transmission of content, using application-assisted framing and deframing where the underlying transport does not provide these.</li>
<li>Asynchronous connection establishment, transmission, and reception, allowing most application interactions with the transport layer to be event-driven.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#api-summary" id="api-summary">API Summary</a>
</h1>
<p id="rfc.section.4.p.1">[TASK: write three paragraph summary here, should state how all this works for common cases from the application&#8217;s PoV.]</p>
<p id="rfc.section.4.p.2">In the following sections, we describe the details of application interaction with Objects through Actions and Events in each phase of a connection, following the phases described in <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#pre-establishment-phase" id="pre-establishment-phase">Pre-Establishment Phase</a>
</h1>
<p id="rfc.section.5.p.1">Establishment begins with the creation of a Connection&#8230;</p>
<pre>
Connection := NewConnection(localSpecifier, remoteSpecifier, transportParameters, cryptographicParameters)
</pre>
<p id="rfc.section.5.p.2">[NOTE: note also that framers and deframers should be bound to connections during pre-establishment, forward-reference <a href="#send-framing" class="xref">Section 7.2</a> and <a href="#receive-framing" class="xref">Section 8.2</a>]</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#enpointspec" id="enpointspec">Specifying Endpoints</a>
</h1>
<p id="rfc.section.5.1.p.1">[NOTE: name resolution is no explict step within the transport API.  Name resolution can be perfoemed whey creating endpoint objects, but may be deferred until connection establishment to incorporate transport parameters.]</p>
<p id="rfc.section.5.1.p.2">The transport service API uses Endpoint objects to refer to local and remote endpoints.  Endpoint objects can be configured using varios endpoint representation, including IP addresses, hostnames, URLs or inteface names as well as port numbers and service names:</p>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier("https://example.com")
</pre>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withHostname("example.com")
remoteSpecifier.withService("https")
</pre>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withIPv6Address(2001:db8:4920:e29d:a420:7461:7073:0a)
remoteSpecifier.withPort(443)
</pre>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withIPv4Address(192.0.2.21)
remoteSpecifier.withPort(443)
</pre>
<pre>
localSpecifier := NewEndpoint()
localSpecifier.withInterface("en0")
localSpecifier.withPort(443)
</pre>
<p id="rfc.section.5.1.p.3">Implementations may also support additional endpoint representations and provide a single NewEndpoint() call that takes different endpoint representations.</p>
<p id="rfc.section.5.1.p.4">Endpoint representations may imply transport protocols, pseudotransport protocols, or families of protocols, e.g., remoteSpecifier.withUrl(&#8220;https://example.com&#8221;) implies either using HTTP over TLS over TCP or using HTTP over QUIC over UDP.  Whether the protocols implied by the endpoint representation are provided by the transport system is implementation specific, but MUST BE tunable using pre-establishment properties.  Implementations SHOULD provide all parts of the implied transport stack they implement unless specified otherwise using pre-establishment properties.  For example, the transport system may provide TLS over TCP in the above example and let the application implement HTTP pseudo-transport itself.</p>
<p id="rfc.section.5.1.p.5">[TASK: match with #initiate / #listen / #rendezvous and make sure the transport stack used is communicated ]</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#transport-params" id="transport-params">Specifying Transport Parameters</a>
</h1>
<p id="rfc.section.5.2.p.1">When creating a connection, an application needs to specify transport parameters reflecting its requirements and preferences regarding its communication. These Transport parameters include Protocol Selection Properties, Protocol Properties (specific configuration of a transport protocol once it has been selected), Path Selection Properties, and Application Intents (hints to the transport system what to optimize for).</p>
<p id="rfc.section.5.2.p.2">Some properties are strict requirements that the application relies on, while others are hints of what transport features would be helpful for the application. For example, if an application asks for reliable data transfer, choosing a transport protocol such as UDP, which does not have this feature, will break the application&#8217;s functionality. On the other hand, the option to not require checksums when receiving an individual Content can help optimize for low latency, but if not present, it will most likely not break the fundamental assumptions of the application.</p>
<p id="rfc.section.5.2.p.3">Moreover, there can be conflicts between properties set by the application: If multiple features are requested which are offered by different protocols, it may not be possible to satisfy all requirements.  Consequently, a transport system must prioritize Transport Parameters and consider the relevant trade-offs, see also <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.  To reflect that, some Transport Parameters can be specified with different preference, whereby the preference is one of the following levels:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Preference</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="left"><samp>intend  </samp></td>
<td class="left">Hint to the transport system (usually Application Intent)</td>
</tr>
<tr>
<td class="left"><samp>require </samp></td>
<td class="left">Fail if requested feature/property can not be met</td>
</tr>
<tr>
<td class="left"><samp>prefer  </samp></td>
<td class="left">Proceed if requested feature/property can not be met</td>
</tr>
<tr>
<td class="left"><samp>avid    </samp></td>
<td class="left">Proceed if requested feature/property can not be avoided</td>
</tr>
<tr>
<td class="left"><samp>prohibit</samp></td>
<td class="left">Fail if requested feature/property can not be avoided</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.2.p.4">Default preference levels and possible combinations of Transport Parameters and preference levels are specified in <a href="#appendix-preferences" class="xref">Appendix A.1</a>.</p>
<p id="rfc.section.5.2.p.5">All properties of the Transport Parameters are collected in a TransportParameters object:</p>
<pre>
transportParameters := NewTransportParameters()
</pre>
<p id="rfc.section.5.2.p.6">The Individual properties, regardless whether thy are Protocol Selection Properties, Protocol Properties, Path Selection Properties, or Application Intents, are then added to the TransportParameters object:</p>
<pre>
transportParameters.addProperty(preference, name, value)
</pre>
<p id="rfc.section.5.2.p.7">For an existing connection, the Transport Parameters can be queried any time by using the following call on the Connection object:</p>
<pre>
transportParameters := connection.getTransportParameters()
</pre>
<p id="rfc.section.5.2.p.8">For most properties, it is beneficial for the application to set them as early as possible in order to help the transport system optimize.  Some parameters can also be set later in the lifetime of a connection.  However, Protocol Selection Properties and Path Selection Properties MUST be added to the TransportParameters object before calling Initiate() and SHOULD result in a runtime error if changed later.  <a href="#appendix-specify-query-params" class="xref">Appendix A.2</a> gives an overview of what Transport Parameters can be specified and queried during which phase.</p>
<p id="rfc.section.5.2.p.9">Connections can be cloned at any time, before or after establishment.  A cloned connection and its parent are entangled: they share the same TransportParameters object, changing any parameter for one of them also changes the parameter for the other, connecting one of them also connects the other, etc.  Cloning connections during pre-establishment is encouraged, as it informs the transport system about the intent to form Connection Groups.</p>
<p id="rfc.section.5.2.p.10">[Note that priority assignment ((see also <a href="#groups" class="xref">Section 6.4</a> for more details) is not shared among cloned connections. Therefore, the priority assignment MUST NOT be realized using the connection level TransportParameters object.]</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#protocol-selection-props" id="protocol-selection-props">Protocol Selection Properties</a>
</h1>
<p id="rfc.section.5.2.1.p.1">The following properties can be adjusted before establishing a Connection.  There need to be sensible defaults for the Protocol Selection Properties. The defaults given in the following section represent a configuration that can be implemented over TCP. An alternate set of default Protocol Selection Properties would represent a configuration that can be implemented over UDP.</p>
<p id="rfc.section.5.2.1.p.2">The following properties apply to Connections and Connection Groups:</p>
<p id="rfc.section.5.2.1.p.3">Reliable Data Transfer</p>
<p id="rfc.section.5.2.1.p.4">This boolean property specifies whether the application needs the transport protocol to ensure that data is received completely and without corruption on the other side. This also entails being notified when a Connection is closed or aborted. This property applies to connections and connection groups.  This is a strict requirement. The default is to enable Reliable Data Transfer.</p>
<p id="rfc.section.5.2.1.p.5">Preservation of data ordering</p>
<p id="rfc.section.5.2.1.p.6">This boolean property specifies whether the application needs the transport protocol to assure that data is received by the application on the other end in the same order as it was sent. This property applies to connections and connection groups. This is a strict requirement. The default is to preserve data ordering.</p>
<p id="rfc.section.5.2.1.p.7">Option to configure reliability for individual Content</p>
<p id="rfc.section.5.2.1.p.8">This boolean property specifies whether an application considers it useful to indicate its reliability requirements on a per-Content basis. This property applies to connections and connection groups. This is not a strict requirement.  The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.9">Option to request not to delay acknowledgment (SACK) of Content</p>
<p id="rfc.section.5.2.1.p.10">This boolean property specifies whether an application considers it useful to request for Content that its acknowledgment be sent out as early as possible (SACK) instead of potentially being bundled with other acknowledgments. This property applies to connections and connection groups. This is not a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.11">Option to use 0-RTT session establishment with idempotent Content</p>
<p id="rfc.section.5.2.1.p.12">This boolean property specifies whether an application would like to supply a Content to the transport protocol before Connection establishment, which will then be reliably transferred to the other side before or during connection establishment, potentially multiple times. See also <a href="#send-idempotent" class="xref">Section 7.1.5</a>.  This is a strict requirement. The default is to not have this option.</p>
<p id="rfc.section.5.2.1.p.13">Option to use Connection Groups with priorities</p>
<p id="rfc.section.5.2.1.p.14">This boolean property specifies whether an application considers it useful to create Connection Groups and explicitly prioritize between Connections within a Connection Group.</p>
<p id="rfc.section.5.2.1.p.15">Suggest a timeout to the peer</p>
<p id="rfc.section.5.2.1.p.16">This boolean property specifies whether an application considers it useful to propose a timeout until the connection is assumed to be lost. This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</p>
<p id="rfc.section.5.2.1.p.17">Notification of special errors (excessive retransmissions, ICMP error message arrival)</p>
<p id="rfc.section.5.2.1.p.18">This boolean property specifies whether an application considers it useful to be informed in case sent data was retransmitted more often than a certain threshold, or when an ICMP error message arrives. This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</p>
<p id="rfc.section.5.2.1.p.19">Control checksum coverage on sending or receiving</p>
<p id="rfc.section.5.2.1.p.20">This boolean property specifies whether the application considers it useful to enable / disable / configure a checksum when sending Content, or decide whether to require a checksum or not when receiving Content.  This property applies to Connections and Connection Groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without being able to change it, and requiring a checksum when receiving.</p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#protocol-props" id="protocol-props">Protocol Properties</a>
</h1>
<p id="rfc.section.5.2.2.p.1">Protocol Properties represent the configuration of a transport protocols once it has been selected. A transport protocol may not support all Protocol Properties, depending on the available transport features. An application should specify the Protocol Properties as early as possible to help the TAPS system optimize. However, a TAPS system will only actually set those protocol properties that are actually supported by the chosen transport protocol. These property all apply to Connections and Connection groups.  The default settings of these properties depends on the chosen protocol and on the system configuration.</p>
<p id="rfc.section.5.2.2.p.2">Set timeout for aborting Connection</p>
<p id="rfc.section.5.2.2.p.3">This numeric property specifies how long to wait before aborting a Connection.  It is given in seconds.</p>
<p id="rfc.section.5.2.2.p.4">Set timeout to suggest to the peer</p>
<p id="rfc.section.5.2.2.p.5">This numeric property specifies the timeout to propose to the peer. It is given in seconds.</p>
<p id="rfc.section.5.2.2.p.6">Set retransmissions before &#8220;Excessive Retransmissions&#8221;</p>
<p id="rfc.section.5.2.2.p.7">This numeric property specifies after how many retransmissions to inform the application about &#8220;Excessive Retransmissions&#8221;.</p>
<p id="rfc.section.5.2.2.p.8">Set required minimum coverage of the checksum for receiving</p>
<p id="rfc.section.5.2.2.p.9">This numeric property specifies the part of the received data that needs to be covered by a checksum. It is given in Bytes. A value of 0 means that no checksum is required, and a special value (e.g., -1) indicates full checksum coverage.</p>
<p id="rfc.section.5.2.2.p.10">Set scheduler for connections in a group</p>
<p id="rfc.section.5.2.2.p.11">This property specifies which scheduler should be used among Connections within a Connection Group. It applies to connection groups. For now we suggest we the schedulers defined in <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</p>
<p id="rfc.section.5.2.2.p.12">Maximum Content Size Before Connection Establishment</p>
<p id="rfc.section.5.2.2.p.13">This numeric property can be queried by the application after creating a Connection. It represents the maximum Content size that can be sent before or during Connection establishment, see also <a href="#send-idempotent" class="xref">Section 7.1.5</a>. It is given in Bytes.</p>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#path-selection-props" id="path-selection-props">Path Selection Properties</a>
</h1>
<p id="rfc.section.5.2.3.p.1">Not all transport protocols work on all paths. Thus, transport protocol selection is tied to path selection, which may involve choosing between multiple local interfaces that are connected to different access networks.</p>
<p id="rfc.section.5.2.3.p.2">Path Selection Properties are requirements, prohibitions, or preferences, that an application has regarding path selection. These properties should be specified as early as possible in order to help the TAPS system optimize.  However, they may also be specified later.</p>
<p id="rfc.section.5.2.3.p.3">Interface Type to prefer</p>
<p id="rfc.section.5.2.3.p.4">This property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to prefer over others for this connection, in case they are available.  This is not a strict requirement. The default is to use the default interface configured in the system policy.</p>
<p id="rfc.section.5.2.3.p.5">Interface Type to prohibit</p>
<p id="rfc.section.5.2.3.p.6">This property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to not use for this connection. This is a strict requirement and connection establishment will fail if no other interface is available. The default is to not prohibit any particular interface.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> <a href="#intents" id="intents">Application Intents</a>
</h1>
<p id="rfc.section.5.2.4.p.1">Application Intents are a group of properties expressing what an application wants to achieve, knows, assumes or prefers regarding its communication. They are not strict requirements. In particular, they should not be used to express any Quality of Service expectations that an application might have. Instead, an application should express its intentions and its expected traffic characteristics in order to help the transport system make decisions that best match it, but on a best-effort basis. Even though Application Intents do not represent Quality of Service requirements, a transport system may use them to determine a DSCP value, e.g. similar to Table 1 in <a href="#I-D.ietf-tsvwg-rtcweb-qos" class="xref">[I-D.ietf-tsvwg-rtcweb-qos]</a>.</p>
<p id="rfc.section.5.2.4.p.2">Application Intents can influence protocol selection, protocol configuration, path selection, and endpoint selection. For example, setting the &#8220;Timeliness&#8221; Intent to &#8220;Interactive&#8221; may lead the transport system to disable the Nagle algorithm for a connection, while setting the &#8220;Timeliness&#8221; to &#8220;Background&#8221; may lead it to setting the DSCP value to &#8220;scavenger&#8221;. If the &#8220;Size to be Sent&#8221; Intent is set on individual Content, it may influence path selection, e.g., when the TAPS system schedules big Content over an interface with higher bandwidth, and small Content over an interface with lower latency.</p>
<p id="rfc.section.5.2.4.p.3">Specifying Application Intents is not mandatory. An application can specify any combination of Application Intents. All Application Intents can be specified for connections and cloning a Connection to form a Connection Group will clone the associated Intents along with the other transport parameters. Some Intents can also be specified for individual Content, similar to the properties in <a href="#send-props" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.5.2.4.p.4">Traffic Category</p>
<p id="rfc.section.5.2.4.p.5">This Intent specifies what the application expect the dominating traffic pattern to be.</p>
<p id="rfc.section.5.2.4.p.6">Possible Category values are:</p>
<p></p>

<dl>
<dt>Query:</dt>
<dd style="margin-left: 8">Single request / response style workload, latency bound</dd>
<dt>Control:</dt>
<dd style="margin-left: 8">Long lasting low bandwidth control channel, not bandwidth bound</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">Stream of bytes/Content with steady data rate</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Bulk transfer of large Content, presumably bandwidth bound</dd>
</dl>
<p id="rfc.section.5.2.4.p.8">The default is to not assume any particular traffic pattern. Most categories suggest the use of other intents to further describe the traffic pattern anticipated, e.g., the bulk category suggesting the use of the Message Size intents or the stream category suggesting the Stream Bitrate and Duration intents.</p>
<p id="rfc.section.5.2.4.p.9">Size to be Sent / Received</p>
<p id="rfc.section.5.2.4.p.10">This Intent specifies what the application expects the size of a transfer to be.  It is a numeric property and given in Bytes. This Intent can also apply to individual Content.</p>
<p id="rfc.section.5.2.4.p.11">Duration</p>
<p id="rfc.section.5.2.4.p.12">This Intent specifies what the application expects the lifetime of a transfer to be. It is a numeric property and given in milliseconds.</p>
<p id="rfc.section.5.2.4.p.13">Stream Bitrate Sent / Received</p>
<p id="rfc.section.5.2.4.p.14">This Intent specifies what the application expects the bitrate of a transfer to be. It is a numeric property and given in Bytes per second.</p>
<p id="rfc.section.5.2.4.p.15">Timeliness</p>
<p id="rfc.section.5.2.4.p.16">This Intent specifies what delay characteristcs the applications prefers. It provides hints for the transport system whether to optimize for low latency or other criteria. Note that setting this Intents does not imply any guarantees on whether an application&#8217;s requirements can actually be satisfied. This Intent can also apply to individual Content.</p>
<p></p>

<dl>
<dt>Stream:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be kept as low as possible</dd>
<dt>Interactive:</dt>
<dd style="margin-left: 8">Delay should be kept as low as possible, but some variation is tolerable</dd>
<dt>Transfer:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be reasonable, but are not critical</dd>
<dt>Background:</dt>
<dd style="margin-left: 8">Delay and packet delay variation is no concern</dd>
</dl>
<p id="rfc.section.5.2.4.p.18">The default is &#8220;Transfer&#8221;.</p>
<p id="rfc.section.5.2.4.p.19">Disruption Resilience</p>
<p id="rfc.section.5.2.4.p.20">This Intent describes what an application knows about its own ability to deal with disruption of its communication, e.g., connection loss. It provides hints of how well an application assumes it can recover from such disturbances and can have an impact on the tradeoff between providing failover techniques and resource utilization. This Intent can also apply to individual Content.</p>
<p></p>

<dl>
<dt>Sensitive:</dt>
<dd style="margin-left: 8">Disruptions result in application failure, disrupting user experience</dd>
<dt>Recoverable:</dt>
<dd style="margin-left: 8">Disruptions are inconvenient for the application, but can be recovered from</dd>
<dt>Resilient:</dt>
<dd style="margin-left: 8">Disruptions have minimal impact for the application</dd>
</dl>
<p id="rfc.section.5.2.4.p.22">The default is &#8220;Sensitive&#8221;.</p>
<p id="rfc.section.5.2.4.p.23">Cost Preferences</p>
<p id="rfc.section.5.2.4.p.24">This Intent describes what an application prefers regarding monetary costs, e.g., whether it considers it acceptable to utilize limited data volume. It provides hints to the transport system on how to handle tradeoffs between cost and performance or reliability. This Intent can also apply to individual Content.</p>
<p></p>

<dl>
<dt>No Expense:</dt>
<dd style="margin-left: 8">Avoid transports associated with monetary cost</dd>
<dt>Optimize Cost:</dt>
<dd style="margin-left: 8">Prefer inexpensive transports and accept service degradation</dd>
<dt>Balance Cost:</dt>
<dd style="margin-left: 8">Use system policy to balance cost and other criteria</dd>
<dt>Ignore Cost:</dt>
<dd style="margin-left: 8">Ignore cost, choose transport solely based on other criteria</dd>
</dl>
<p id="rfc.section.5.2.4.p.26">The default is &#8220;Balance Cost&#8221;.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#security-parameters" id="security-parameters">Specifying Security Parameters and Callbacks</a>
</h1>
<p id="rfc.section.5.3.p.1">Common parameters such as TLS ciphersuites are known to implementations. Clients SHOULD use common safe defaults for these values whenever possible. However, as discussed in <a href="#I-D.pauly-taps-transport-security" class="xref">[I-D.pauly-taps-transport-security]</a>, many transport security protocols require specific security parameters and constraints from the client at the time of configuration and actively during a handshake. These configuration parameters are created as follows</p>
<pre>
securityParameters := NewSecurityParameters()
</pre>
<p id="rfc.section.5.3.p.2">Security configuration parameters and sample usage follow:</p>
<p></p>

<ul><li>Local identity and private keys: Used to perform private key operations and prove one&#8217;s identity to remote peers. (Note, if private keys are not available, e.g., since they are stored in HSMs, handshake callbacks MUST be used. See below for details.)</li></ul>
<pre>
securityParameters.AddIdentity(identity)
securityParameters.AddPrivateKey(privateKey, publicKey)
</pre>
<p></p>

<ul><li>Supported algorithms: Used to restrict what parameters are used by underlying transport security protocols.  When not specified, these algorithms SHOULD default to known and safe defaults for the system. Parameters include: ciphersuites, supported groups, and signature algorithms.</li></ul>
<pre>
securityParameters.AddSupportedGroup(22)    // secp256k1 
securityParameters.AddCiphersuite(0xCCA9)   // TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
securityParameters.AddSignatureAlgorithm(7) // ed25519
</pre>
<p></p>

<ul><li>Session cache: Used to tune cache capacity, lifetime, re-use, and eviction policies, e.g., LRU or FIFO.</li></ul>
<pre>
securityParameters.SetSessionCacheCapacity(1024)     // 1024 elements
securityParameters.SetSessionCacheLifetime(24*60*60) // 24 hours
securityParameters.SetSessionCacheReuse(1)           // One-time use
</pre>
<p></p>

<ul><li>Pre-shared keying material: Used to install pre-shared keying material established out-of-band. Each pre-shared keying material is associated with some identity that typically identifies its use or has some protocol-specific meaning to peers.</li></ul>
<pre>
securityParameters.AddPreSharedKey(key, identity)
</pre>
<p id="rfc.section.5.3.p.7">Security decisions, especially pertaining to trust, are not static. Thus, once configured, parameters must also be supplied during live handshakes. These are best handled as client-provided callbacks. Security handshake callbacks include:</p>
<p></p>

<ul><li>Trust verification callback: Invoked when a peer&#8217;s trust must be validated before the handshake protocol can proceed.</li></ul>
<pre>
trustCallback := NewCallback({
  // Handle trust, return the result
}) 
securityParameters.SetTrustVerificationCallback(trustCallback)
</pre>
<p></p>

<ul><li>Identity challenge callback: Invoked when a private key operation is required, e.g., when local authentication is requested by a remote.</li></ul>
<pre>
challengeCallback := NewCallback({
  // Handle challenge
}) 
securityParameters.SetIdentityChallengeCallback(challengeCallback)
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#establishing-connections" id="establishing-connections">Establishing Connections</a>
</h1>
<p id="rfc.section.6.p.1">Before a Connection can be used for data transfer, it must be established.  Establishment ends the pre-establishment phase; all transport and cryptographic parameter specification must be complete before establishment, as these parameters will be used to select candidate Paths and Protocol Stacks for the Connection. Establishment may be active, using the Initiate() Action; passive, using the Listen() Action; or simultaneous for peer-to-peer, using the Rendezvous() Action. These Actions are described in the subsections below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#initiate" id="initiate">Active Open: Initiate</a>
</h1>
<p id="rfc.section.6.1.p.1">Active open is the action of establishing a connection to an endpoint presumed to be listening for incoming connection requests, commonly used by clients in client-server interactions. Active open is supported by this interface through the Initiate action:</p>
<p id="rfc.section.6.1.p.2">Connection.Initiate()</p>
<p id="rfc.section.6.1.p.3">Before calling Initiate, the caller must have initialized the Connection during the pre-establishment phase with local and remote endpoint specifiers, as well as all parameters necessary for candidate selection. After calling Initiate, no further parameters may be bound to the Connection, and no subsequent establishment call may be made on the Connection.</p>
<p id="rfc.section.6.1.p.4">Once Initiate is called, the candidate Protocol Stack(s) may cause one or more transport-layer connections to be created to the specified remote endpoint.  The caller may immediately begin sending Content on the Connection (see <a href="#sending" class="xref">Section 7</a>) after calling Initate, though it may wait for one of the following events before doing so.</p>
<p id="rfc.section.6.1.p.5">Connection -&gt; Ready&lt;&gt;</p>
<p id="rfc.section.6.1.p.6">The Ready event occurs after Initiate has established a transport-layer connection on at least one usable candidate Protocol Stack over at least one candidate Path. No Receive events (see <a href="#receiving" class="xref">Section 8</a>) will occur until after the Ready event for connections established using Initiate.  [MICHAEL: This is a difficult read. Can we phrase this as &#8220;&#8230;will occur before the Ready event for connections&#8230;&#8221;, or did you have a specific reason to write &#8220;until after the Ready event&#8221;?]</p>
<p id="rfc.section.6.1.p.7">Connection -&gt; InitiateError&lt;&gt;</p>
<p id="rfc.section.6.1.p.8">An InitiateError occurs either when the set of local and remote specifiers and transport and cryptographic parameters cannot be fulfilled on a connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty), when the remote specifier cannot be resolved, or when no transport-layer connection can be established to the remote endpoint (e.g.  because the remote endpoint is not accepting connections, or the application is prohibited from opening a connection by the operating system).</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#listen" id="listen">Passive Open: Listen</a>
</h1>
<p id="rfc.section.6.2.p.1">Passive open is the action of waiting for connections from remote endpoints, commonly used by servers in client-server interactions. Passive open is supported by this interface through the Listen action:</p>
<p id="rfc.section.6.2.p.2">Connection.Listen()</p>
<p id="rfc.section.6.2.p.3">Before calling Listen, the caller must have initialized the Connection during the pre-establishment phase with local endpoint specifiers, as well as all parameters necessary for Protocol Stack selection. After calling Listen, no further parameters may be bound to the Connection, and no subsequent establishment call may be made on the Connection.</p>
<p id="rfc.section.6.2.p.4">Connection -&gt; ConnectionReceived&lt;Connection&gt;</p>
<p id="rfc.section.6.2.p.5">The ConnectionReceived event occurs when a remote endpoint has established a transport-layer connection to this Connection or when the remote endpoint has sent its first Content, causing a new Connection to be created. The resulting Connection is contained within the ConnectionReceived event, and is ready to use as soon as it is passed to the application via the event.</p>
<p id="rfc.section.6.2.p.6">[MICHAEL: JFYI, just to explain why I added &#8220;or when the remote endpoint has sent its first Content&#8221; above: in case the connection is in fact a stream, nothing may happen on the wire when doing Connect, and the first thing the listener gets may already be the first data block.]</p>
<p id="rfc.section.6.2.p.7">Connection -&gt; ListenError&lt;&gt;</p>
<p id="rfc.section.6.2.p.8">A ListenError occurs either when the set of local specifier, transport and cryptographic parameters cannot be fulfilled for listening, when the local specifier cannot be resolved, or when the application is prohibited from listening by the operating system.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#rendezvous" id="rendezvous">Peer to Peer Establishment: Rendezvous</a>
</h1>
<p id="rfc.section.6.3.p.1">Connection.Rendezvous()</p>
<p id="rfc.section.6.3.p.2">Connection -&gt; Ready&lt;&gt;</p>
<p id="rfc.section.6.3.p.3">Connection -&gt; RendezvousError&lt;&gt;</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#groups" id="groups">Connection Groups</a>
</h1>
<p id="rfc.section.6.4.p.1">Groups of Connections can be created using Clone action:</p>
<p id="rfc.section.6.4.p.2">Connection := Connection.Clone()</p>
<p id="rfc.section.6.4.p.3">Calling this once yields a group of two Connections: the parent Connection &#8211; whose Clone action was called &#8211; and the resulting clone. Calling Clone on any of these two Connections adds a third Connection to the group, and so on.  All Connections in a group are entangled. This means that they automatically share all properties: changing a parameter for one of them also changes the parameter for all others, closing one of them also closes all others, etc.</p>
<p id="rfc.section.6.4.p.4">There is only one Protocol Property that is not entangled, i.e. it is a separate per-Connection Property for individual Connections in the group: a priority.  This priority, which can be represented as a non-negative integer or float, expresses a desired share of the Connection Group&#8217;s available network capacity, such that an ideal transport system implementation would assign the Connection the capacity share P x C/sum_P, where P = priority, C = total available capacity and sum_P = sum of all priority values that are used for the Connections in the same Connection Group.  The priority setting is purely advisory; no guarantees are given.</p>
<p id="rfc.section.6.4.p.5">Connection Groups should be created (i.e., the Clone action should be used) as early as possible, ideally already during the Pre-Establishment phase, in order to aid the Transport System in choosing and configuring the right protocols (see also <a href="#transport-params" class="xref">Section 5.2</a>).</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sending" id="sending">Sending Data</a>
</h1>
<p id="rfc.section.7.p.1">Once a Connection has been established, it can be used for sending data. Data is sent by passing a Content object and additional properties <a href="#send-props" class="xref">Section 7.1</a> to the Send action on an established connection:</p>
<p id="rfc.section.7.p.2">Connection.Send(Content, &#8230;)</p>
<p id="rfc.section.7.p.3">The type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. It may itself contain an array of octets to be transmitted in the transport protocol payload, or be transformable to an array of octets by a sender-side framer (see <a href="#send-framing" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.7.p.4">If Send is called on a Connection which has not yet been established, an Initiate action will be implicitly performed simultaneously with the Send.  Used together with the Idempotent property (see <a href="#send-idempotent" class="xref">Section 7.1.5</a>), this can be used to send data during establishment for 0-RTT session resumption on Protocol Stacks that support it.</p>
<p id="rfc.section.7.p.5">Like all Actions in this interface, the Send action is asynchronous.</p>
<p id="rfc.section.7.p.6">Connection -&gt; Sent&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.7">The Sent event occurs when a previous Send action has completed, i.e. when the data derived from the Content has been passed down or through the underlying Protocol Stack and is no longer the responsibility of the implementation of this interface. The exact disposition of Content when the Sent event occurs is specific to the implementation and the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Sent event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.8">Sent events allow an application to obtain an understanding of the amount of buffering it creates. That is, if an application calls the Send action multiple times without waiting for a Sent event, it has created more buffer inside the transport system than an application that only issues a Send after this event fires.</p>
<p id="rfc.section.7.p.9">Connection -&gt; Expired&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.10">The Expired event occurs when a previous Send action expired before completion; i.e. when the data derived from the Content was not sent before its Lifetime (see <a href="#send-lifetime" class="xref">Section 7.1.1</a>) expired. This is separate from SendError, as it is an expected behavior for partially reliable transports. The Expired event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.11">Connection -&gt; SendError&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.12">A SendError occurs when Content could not be sent due to an error condition: some failure of the underlying Protocol Stack, or a set of send parameters not consistent with the Connection&#8217;s transport parameters.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#send-props" id="send-props">Send Properties</a>
</h1>
<p id="rfc.section.7.1.p.1">The Send action takes six per-Content properties which control how it will be sent down to the underlying Protocol Stack and transmitted. Note that some of these properties are not compatible with transport parameters; attempting to Send with such an incompatibility yields a SendError.</p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#send-lifetime" id="send-lifetime">Lifetime</a>
</h1>
<p id="rfc.section.7.1.1.p.1">Lifetime specifies how long a particular Content can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted. When a Content&#8217;s Lifetime is infinite, it must be transmitted reliably. The type and units of Lifetime are implementation-specific.</p>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> <a href="#send-niceness" id="send-niceness">Niceness</a>
</h1>
<p id="rfc.section.7.1.2.p.1">Niceness represents an unbounded hierarchy of priorities of Content, relative to other Content sent over the same Connection and/or Connection Group (see <a href="#groups" class="xref">Section 6.4</a>). It is most naturally represented as a non-negative integer.  Content with Niceness 0 will yield to Content with Niceness 1, which will yield to Content with Niceness 2, and so on. Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.</p>
<p id="rfc.section.7.1.2.p.2">Note that this inversion of normal schemes for expressing priority has a convenient property: priority increases as both Niceness and Lifetime decrease.</p>
<h1 id="rfc.section.7.1.3">
<a href="#rfc.section.7.1.3">7.1.3.</a> <a href="#send-ordered" id="send-ordered">Ordered</a>
</h1>
<p id="rfc.section.7.1.3.p.1">Ordered is a boolean property. If true, this Content should be delivered after the last Content passed to the same Connection via the Send action; if false, this Content may be delivered out of order.</p>
<h1 id="rfc.section.7.1.4">
<a href="#rfc.section.7.1.4">7.1.4.</a> <a href="#send-immediate" id="send-immediate">Immediate</a>
</h1>
<p id="rfc.section.7.1.4.p.1">Immediate is a boolean property. If true, the caller prefers immediacy to efficient capacity usage for this Content. For example, this means that the Content should not be bundled with other Content into the same transmission by the underlying Protocol Stack.</p>
<h1 id="rfc.section.7.1.5">
<a href="#rfc.section.7.1.5">7.1.5.</a> <a href="#send-idempotent" id="send-idempotent">Idempotent</a>
</h1>
<p id="rfc.section.7.1.5.p.1">Idempotent is a boolean property. If true, the application-layer entity in the Content is safe to send to the remote endpoint more than once for a single Send action. It is used to mark data safe for certain 0-RTT establishment techniques, where retransmission of the 0-RTT data may cause the remote application to receive the Content multiple times.</p>
<p id="rfc.section.7.1.5.p.2">[NOTE: we need some way to signal to the transport that we want to wait for 0RTT data on Initiate. Probably a transport parameter] [MICHAEL: why? As an app programmer, I can just use Send instead of Initiate.]</p>
<h1 id="rfc.section.7.1.6">
<a href="#rfc.section.7.1.6">7.1.6.</a> <a href="#send-checksum" id="send-checksum">Checksum</a>
</h1>
<p id="rfc.section.7.1.6.p.1">This numeric property specifies the length of the checksum to be used on the Content.  A value of 0 means that no checksum is required, and a special value (e.g. -1) can be used to indicate full checksum coverage (which is also the default). Only full coverage is guaranteed, any other requests are advisory.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#send-framing" id="send-framing">Sender-side Framing</a>
</h1>
<p id="rfc.section.7.2.p.1">Sender-side framing allows a caller to provide the interface with a function that takes Content of an appropriate type and returns an array of octets, the on-the-wire representation of the content to be handed down to the Protocol Stack. It consists of a Framer object with a single Action, Frame. Since the Framer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.7.2.p.2">Connection.FrameWith(Framer)</p>
<p id="rfc.section.7.2.p.3">OctetArray := Framer.Frame(Content)</p>
<p id="rfc.section.7.2.p.4">Sender-side framing is a convenience feature of the interface, for parity with receiver-side framing (see <a href="#receive-framing" class="xref">Section 8.2</a>).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#receiving" id="receiving">Receiving Data</a>
</h1>
<p id="rfc.section.8.p.1">Once a Connection is established, Content may be received on it. The interface notifies the application that content has been received via the Received event:</p>
<p id="rfc.section.8.p.2">Connection -&gt; Received&lt;Content&gt;</p>
<p id="rfc.section.8.p.3">As with sending, the type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Content may also contain metadata from protocols in the Protocol Stack for logging and debugging purposes. In particular, when this information is available, the value of the Explicit Congestion Notification (ECN) field is contained in such metadata.</p>
<p id="rfc.section.8.p.4">The Content object must provide some method to retrieve an octet array containing application data, corresponding to a single message within the underlying Protocol Stack&#8217;s framing.  See <a href="#receive-framing" class="xref">Section 8.2</a> for handling framing in situations where the Protocol Stack provides octet-stream transport only.</p>
<p id="rfc.section.8.p.5">Connection -&gt; ReceiveError&lt;&gt;</p>
<p id="rfc.section.8.p.6">A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or deframed, or when some other indication is received that reception has failed. Such conditions that irrevocably lead the the termination of the Connection are signaled using ConnectionError instead (see <a href="#termination" class="xref">Section 9</a>).</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#receive-backpressure" id="receive-backpressure">Application-Layer Backpressure at the Receiver</a>
</h1>
<p id="rfc.section.8.1.p.1">Implementations of this interface must provide some way for the application to indicate that it is temporarily not ready to receive new Content. Since the mechanisms of event handling are implementation-platform specific, this document does not specify the exact nature of this interface.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#receive-framing" id="receive-framing">Receiver-side Deframing over Stream Protocols</a>
</h1>
<p id="rfc.section.8.2.p.1">The Receive event is intended to be fired once per application-layer Content sent by the remote endpoint; i.e., it is a desired property of this interface that a Send at one end of a Connection maps to exactly one Receive on the other end. This is possible with Protocol Stacks that provide message boundary preservation, but is not the case over Protocol Stacks that provide a simple octet stream transport.</p>
<p id="rfc.section.8.2.p.2">For preserving message boundaries over stream transports, this interface provides receiver-side deframing. This facility is based on the observation that, since many of our current application protocols evolved over TCP, which does not provide message boundary preservation, and since many of these protocols require message boundaries to function, each application layer protocol has defined its own framing. A Deframer allows an application to push this deframing down into the interface, in order to transform an octet stream into a sequence of Content.</p>
<p id="rfc.section.8.2.p.3">Concretely, receiver-side deframing allows a caller to provide the interface with a function that takes an octet stream, as provided by the underlying Protocol Stack, reads and returns a sigle Content of an appropriate type for the application and platform, and leaves the octet stream at the start of the next Content. It consists of a Deframer object with a single Action, Deframe.  Since the Deframer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.8.2.p.4">Connection.DeframeWith(Deframer)</p>
<p id="rfc.section.8.2.p.5">Content := Deframer.Deframe(OctetStream, &#8230;)</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.9.p.1">Close terminates a Connection after satisfying all the requirements that were specified regarding the delivery of Content that the application has already given to the transport system. For example, if reliable delivery was requested for Content handed over before calling Close, the transport system will ensure that such Content is indeed delivered. If the peer still has data to send, it cannot be received after this call.</p>
<p id="rfc.section.9.p.2">Connection.Close()</p>
<p id="rfc.section.9.p.3">This event can (i.e., this is not guaranteed to happen) inform the application that the peer has closed the Connection:</p>
<p id="rfc.section.9.p.4">Connection -&gt; Finished&lt;&gt;</p>
<p id="rfc.section.9.p.5">Abort terminates a Connection without delivering remaining data:</p>
<p id="rfc.section.9.p.6">Connection.Abort()</p>
<p id="rfc.section.9.p.7">This event can (i.e., this is not guaranteed to happen) inform the application that the other side has aborted the Connection:</p>
<p id="rfc.section.9.p.8">Connection -&gt; ConnectionError&lt;&gt;</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#event-and-error-handling" id="event-and-error-handling">Event and Error Handling</a>
</h1>
<p id="rfc.section.10.p.1">[NOTE: point out that events and errors may be handled differently, although they are the modeled the same in this specification.]</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.11.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">This document describes a generic API for interacting with a transport services (TAPS) system.  Part of this API includes configuration details for transport security protocols, as discussed in Section <a href="#security-parameters" class="xref">Section 5.3</a>. It does not recommend use (or disuse) of specific algorithms or protocols. Any API-compatible transport security protocol should work in a TAPS system.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.13.p.1">This work has received funding from the European Union&#8217;s Horizon 2020 research and innovation programme under grant agreement No. 644334 (NEAT).</p>
<h1 id="rfc.references">
<a href="#rfc.references">14.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">14.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-rtcweb-qos">[I-D.ietf-tsvwg-rtcweb-qos]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Dhesikan, S.</a>, <a>Jennings, C.</a> and <a>D. Druta</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">DSCP Packet Markings for WebRTC QoS</a>", Internet-Draft draft-ietf-tsvwg-rtcweb-qos-18, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-sctp-ndata">[I-D.ietf-tsvwg-sctp-ndata]</b></td>
<td class="top">
<a>Stewart, R.</a>, <a>Tuexen, M.</a>, <a>Loreto, S.</a> and <a>R. Seggelmann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13">Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</a>", Internet-Draft draft-ietf-tsvwg-sctp-ndata-13, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-ARCH">[TAPS-ARCH]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Trammell, B.</a>, <a>Brunstrom, A.</a>, <a>Fairhurst, G.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a>An Architecture for Transport Services</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">14.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.pauly-taps-transport-security">[I-D.pauly-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Rose, K.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-pauly-taps-transport-security-01">A Survey of Transport Security Protocols</a>", Internet-Draft draft-pauly-taps-transport-security-01, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-MINSET">[TAPS-MINSET]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-01">A Minimal Set of Transport Services for TAPS Systems</a>", Internet-Draft draft-ietf-taps-minset-01, February 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#appendix-transport-params" id="appendix-transport-params">Transport Parameters</a>
</h1>
<p id="rfc.section.A.p.1">This appendix provides details about the usage of the Transport Parameters specified in <a href="#transport-params" class="xref">Section 5.2</a>. It clarifies what preference levels an application can set for which Transport Parameter, and during which phase an application can specify and query what kinds of Transport Parameters.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#appendix-preferences" id="appendix-preferences">Application Preferences</a>
</h1>
<p id="rfc.section.A.1.p.1">As described in <a href="#transport-params" class="xref">Section 5.2</a>, an application can specify its preference regarding a Transport Parameter, i.e., whether a certain property is required, preferred, to be avoided, prohibited, or an intention. If an application does not set its preference regarding a Transport Parameter, default preference levels apply as specified in the following table. A default preference of &#8220;None&#8221; means that the transport system assumes that an application does not have any preference regarding the corresponding Transport Parameter and may not take this parameter into account for protocol and path selection.</p>
<p id="rfc.section.A.1.p.2">Not every Transport Parameter can be meaningfully assigned every preference level. For example, if an application explicitly prohibits selecting a transport protocol that allows to suggest a timeout to the peer, this restriction will unnecessarily limit transport protocol selection. Instead, the application could simply not use this feature if it is present in the selected transport protocol.</p>
<p id="rfc.section.A.1.p.3">The following table illustrates which Transport Parameter has which default preference level and which alternative preference levels an application may set.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Transport Parameter</th>
<th class="left">Require</th>
<th class="left">Prefer</th>
<th class="left">Avoid</th>
<th class="left">Prohibit</th>
<th class="left">Default</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Reliable Data Transfer</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Preserve Data Ordering</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Configure Reliability per Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Request SACK</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use 0-RTT with Idempotent Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use Connection Groups with priorities</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Suggest timeout to peer</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Notification of special errors</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Control checksum coverage</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use a certain network interface type</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Application Intents</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Intend</td>
</tr>
</tbody>
</table>
<p id="rfc.section.A.1.p.4">[List individual Intents? Reformulate some of them as preferences?]</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#appendix-specify-query-params" id="appendix-specify-query-params">Specifying and Querying Properties</a>
</h1>
<p id="rfc.section.A.2.p.1">In this appendix we give an overview of the different types of properties, the objects to which they apply, and at what time an application can query them.</p>
<p id="rfc.section.A.2.p.2">During the Pre-Establishment phase, an application may specify Transport Parameters for a Connection as described in <a href="#transport-params" class="xref">Section 5.2</a>.  Specifically, Protocol Selection Properties, Path Selection Properties, and Application Intents for the Connection MUST be specified during Pre-Establishment, as protocol and path selection occur during connection establishment. An application may query the Transport Parameters that were specified for a Connection at all times.</p>
<p id="rfc.section.A.2.p.3">Transport Features represent the actual capabilities of specific Protocol Stacks. They are expressed in the same vocabulary as Protocol Selection Properties, but have a Boolean value expressing whether a Protocol Stack support the given Transport Feature or not. An application may query the Transport Features of Protocol Stacks at all times. Once a Connection is established, an application may query the Transport Features of the actually chosen protocols, the Protocol Stack Instances, for this Connection.</p>
<p id="rfc.section.A.2.p.4">Note that it is possible that the Protocol Stack Instances actually chosen by the transport system do not fully reflect the Transport Parameters that were originally set. For example, a certain Protocol Selection Property that an application specified as Preferred may not actually be present in the chosen Protocol Stack Instances because none of the currently available transport protocols had this feature.</p>
<p id="rfc.section.A.2.p.5">Protocol Stacks and Protocol Stack Instances also have Protocol Properties, which represent the specific configuration of a transport protocol. Their default values can be queried at all times, and an application can override these defaults for a specific Connection by specifying Protocol Properties either during pre-establishment or later in the lifetime of a Connection. This configuration is applied on the Protocol Stack Instance once it is bound to the Connection.</p>
<p id="rfc.section.A.2.p.6">Note that some Protocol Properties set during Pre-Establishment may not apply to the actually chosen protocol later, and consequently not be set in the resulting Protocol Stack Instance. However, it is beneficial for an application to set these properties as early as possible, so the transport system can use them to optimize.</p>
<p id="rfc.section.A.2.p.7">Finally, an application may query the properties of the available paths and the properties of the path(s) chosen for a Connection at all times.</p>
<p id="rfc.section.A.2.p.8">An application may also specify Send Properties per individual Content, as specified in <a href="#send-props" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.A.2.p.9">The following table shows the types of existing properties and what an application can do with them during what phase:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Property Type</th>
<th class="left">Applies to</th>
<th class="left">Pre-Establishment</th>
<th class="left">Established</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Transport Parameters</td>
<td class="left">Connection</td>
<td class="left">Set, Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Features</td>
<td class="left">ProtocolStack, ProtocolStackInstance</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Property defaults</td>
<td class="left">ProtocolStack</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Properties</td>
<td class="left">ProtocolStackInstance</td>
<td class="left">Set</td>
<td class="left">Set, Query</td>
</tr>
<tr>
<td class="left">Path Properties</td>
<td class="left">Path</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Send Properties</td>
<td class="left">Content</td>
<td class="left">Set</td>
<td class="left">Set</td>
</tr>
</tbody>
</table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael Welzl</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Welzl</span>
	  </span>
	</span>
	<span class="org vcardline">University of Oslo</span>
	<span class="adr">
	  <span class="vcardline">PO Box 1080 Blindern</span>

	  <span class="vcardline">
		<span class="locality">0316  Oslo</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Norway</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michawe@ifi.uio.no">michawe@ifi.uio.no</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Gorry Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
