<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Abstract Application Layer Interface to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 Design Principles">
<link href="#rfc.section.4" rel="Chapter" title="4 API Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-Establishment Phase">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Specifying Endpoints">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Specifying Transport Parameters">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Transport Preferences">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Protocol Properties">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Application Intents">
<link href="#rfc.section.5.2.4" rel="Chapter" title="5.2.4 Transport Parameters Object">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Specifying Security Parameters and Callbacks">
<link href="#rfc.section.6" rel="Chapter" title="6 Establishing Connections">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Active Open: Initiate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Passive Open: Listen">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Peer-to-Peer Establishment: Rendezvous">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Groups">
<link href="#rfc.section.7" rel="Chapter" title="7 Sending Data">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Send Parameters">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Content Properties">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Sender-side Framing">
<link href="#rfc.section.8" rel="Chapter" title="8 Receiving Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Application-Layer Back-Pressure at the Receiver">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Receiver-side De-framing over Stream Protocols">
<link href="#rfc.section.9" rel="Chapter" title="9 Setting and Querying of Connection Properties">
<link href="#rfc.section.10" rel="Chapter" title="10 Connection Termination">
<link href="#rfc.section.11" rel="Chapter" title="11 Event and Error Handling">
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Security Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Sample API definition in Go">
<link href="#rfc.appendix.B" rel="Chapter" title="B Transport Parameters">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Application Preferences">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Specifying and Querying Parameters">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.5 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Ed., Welzl, M., Ed., Enghardt, T., Fairhurst, G., Kuehlewind, M., Perkins, C., Tiesel, P., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-taps-interface-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-02-21" />
  <meta name="dct.abstract" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />
  <meta name="description" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Welzl, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 25, 2018</td>
<td class="right">University of Oslo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 21, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Abstract Application Layer Interface to Transport Services<br />
  <span class="filename">draft-trammell-taps-interface-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 25, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">Design Principles</a>
</li>
<li>4.   <a href="#rfc.section.4">API Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Pre-Establishment Phase</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Specifying Endpoints</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Specifying Transport Parameters</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Transport Preferences</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Protocol Properties</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Application Intents</a>
</li>
<li>5.2.4.   <a href="#rfc.section.5.2.4">Transport Parameters Object</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Specifying Security Parameters and Callbacks</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Establishing Connections</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Active Open: Initiate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Passive Open: Listen</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Peer-to-Peer Establishment: Rendezvous</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Groups</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Sending Data</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Send Parameters</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Content Properties</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Sender-side Framing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Receiving Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Application-Layer Back-Pressure at the Receiver</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Receiver-side De-framing over Stream Protocols</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Setting and Querying of Connection Properties</a>
</li>
<li>10.   <a href="#rfc.section.10">Connection Termination</a>
</li>
<li>11.   <a href="#rfc.section.11">Event and Error Handling</a>
</li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Security Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Acknowledgements</a>
</li>
<li>15.   <a href="#rfc.references">References</a>
</li>
<ul><li>15.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Sample API definition in Go</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Transport Parameters</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Application Preferences</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Specifying and Querying Parameters</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design principles of a new approach, which we outline in <a href="#principles" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.3">As a first step to realizing this design, <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a> describes a high-level architecture for transport services. This document builds a modern abstract programming interface atop this architecture, deriving specific path and protocol selection properties and supported transport features from the analysis provided in <a href="#RFC8095" class="xref">[RFC8095]</a> and <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology-and-notation" id="terminology-and-notation">Terminology and Notation</a>
</h1>
<p id="rfc.section.2.p.1">This API is described in terms of Objects, which an application can interact with; Actions the application can perform on these objects; Events, which an object can send to an application asynchronously; and Parameters associated with these Actions and Events.</p>
<p id="rfc.section.2.p.2">The following notations, which can be combined, are used in this document:</p>
<p></p>

<ul><li>Object := Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action creates an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object.Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action is performed on an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object -&gt; Event&lt;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Object sends an Event.</li></ul></li></ul>
<p></p>

<ul><li>Action(parameter, parameter, &#8230;) / Event&lt;parameter, parameter, &#8230;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action takes a set of Parameters; an Event contains a set of Parameters.</li></ul></li></ul>
<p id="rfc.section.2.p.11">Actions associated with no object are Actions on the abstract interface itself; they are equivalent to actions on a per-application global context.</p>
<p id="rfc.section.2.p.12">How these abstract concepts map into concrete implementations of this API in a given language on a given platform is largely dependent on the features of the language and the platform. Actions could be implemented as functions or method calls, for instance, and Events could be implemented via callback passing or other asynchronous calling conventions.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#principles" id="principles">Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">We begin with a set of initial design principles for the abstract interface to realize.</p>
<p></p>

<ul>
<li>Transport protocol stack independence in line with the Transport Services Architecture <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>, allowing applications to be written in terms of the semantics best for the application&#8217;s own design, separate from the protocol(s) used on the wire to achieve them. This enables applications written to a single API to make use of transport protocols in terms of the features they provide.</li>
<li>Explicit support for multistreaming and multipath transport protocols.</li>
<li>Explicit support for security properties as first-order transport features, and for long-term caching of cryptographic identities and parameters for associations among endpoints.</li>
<li>Atomic transmission of content, using application-assisted framing and deframing where the underlying transport does not provide these.</li>
<li>Asynchronous connection establishment, transmission, and reception, allowing most application interactions with the transport layer to be event-driven.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#api-summary" id="api-summary">API Summary</a>
</h1>
<p id="rfc.section.4.p.1">[TASK: write three paragraph summary here, should state how all this works for common cases from the application&#8217;s PoV.]</p>
<p id="rfc.section.4.p.2">In the following sections, we describe the details of application interaction with Objects through Actions and Events in each phase of a connection, following the phases described in <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#pre-establishment-phase" id="pre-establishment-phase">Pre-Establishment Phase</a>
</h1>
<p id="rfc.section.5.p.1">The pre-establishment phase allows applications to specify parameters for the connections they&#8217;re about to make, or to query the API about potential connections they could make.</p>
<p id="rfc.section.5.p.2">A Preconnection object represents a potential connection. It has state that describes parameters of a Connection that might exist in the future.  This state comprises information about the local and remote endpoints (see <a href="#endpointspec" class="xref">Section 5.1</a>), the transport parameters (see <a href="#transport-params" class="xref">Section 5.2</a>), and the security parameters (see <a href="#security-parameters" class="xref">Section 5.3</a>):</p>
<pre>
   localEndpoint   := ...
   remoteEndpoint  := ...
   transportParams := ...
   securityParams  := ...

   preConnection := NewPreconnection(localEndpoint, remoteEndpoint,
                                     transportParams, securityParams);

</pre>
<p id="rfc.section.5.p.3">The Local Endpoint MUST be specified if the Preconnection is used to Listen() for incoming connections, but is OPTIONAL if it is used to Initiate() connections. The Remote Endpoint MUST be specified in the Preconnection is used to Initiate() connections, but is OPTIONAL if it is used to Listen() for incoming connections.</p>
<p id="rfc.section.5.p.4">[NOTE: note also that framers and de-framers should be bound to the Preconnection object during pre-establishment, forward-reference <a href="#send-framing" class="xref">Section 7.2</a> and <a href="#receive-framing" class="xref">Section 8.2</a>]</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#endpointspec" id="endpointspec">Specifying Endpoints</a>
</h1>
<p id="rfc.section.5.1.p.1">The transport services API uses Endpoint objects to refer to local and remote endpoints.  Endpoint objects can be configured using various representations of endpoint identifiers, including IP addresses, hostnames, or interface names as well as port numbers and service names:</p>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withHostname("example.com")
remoteSpecifier.withService("https")
</pre>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withIPv6Address(2001:db8:4920:e29d:a420:7461:7073:0a)
remoteSpecifier.withPort(443)
</pre>
<pre>
remoteSpecifier := NewEndpoint()
remoteSpecifier.withIPv4Address(192.0.2.21)
remoteSpecifier.withPort(443)
</pre>
<pre>
localSpecifier := NewEndpoint()
localSpecifier.withInterface("en0")
localSpecifier.withPort(443)
</pre>
<pre>
localSpecifier := NewLocalEndpoint()
localSpecifier.withStunServer(address, port, credentials)
</pre>
<p id="rfc.section.5.1.p.2">Implementations may also support additional endpoint representations and provide a single NewEndpoint() call that takes different endpoint representations.</p>
<p id="rfc.section.5.1.p.3">[TASK: match with #initiate / #listen / #rendezvous and make sure the transport stack used is communicated ]</p>
<p id="rfc.section.5.1.p.4">Multiple endpoint identifiers can be specified for each LocalEndpoint and RemoteEndoint.  For example, a LocalEndpoint could be configured with two interface names, or a RemoteEndpoint could be specified via both IPv4 and IPv6 addresses.  The multiple identifiers refer to the same endpoint.</p>
<p id="rfc.section.5.1.p.5">The transport services API will resolve names internally, when the Initiate(), Listen(), or Rendezvous() method is called establish a connection.  The API does not need the application to resolve names, and premature name resolution can damage performance by limiting the scope for alternate path discovery during connection establishment.  The Resolve() method is, however, provided to resolve a LocalEndpoint or a RemoteEndpoint in cases where this is required, for example with some NAT traversal protocols (see <a href="#rendezvous" class="xref">Section 6.3</a>).</p>
<p id="rfc.section.5.1.p.6">[NOTE: the API needs MUST be explicit about when name resolution occurs, since the act of resolving a name leaks information, and there may be security implications if this happens unexpectedly.]</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#transport-params" id="transport-params">Specifying Transport Parameters</a>
</h1>
<p id="rfc.section.5.2.p.1">A Preconnection object holds parameters reflecting the application&#8217;s requirements and preferences for the transport.  These include Transport Preferences (towards protocol selection and path selection) as well as Application Intents (hints to the transport system what to optimize for) and Protocol Properties (to configure transport protocols).</p>
<p id="rfc.section.5.2.p.2">All Transport Parameters are organized within a single name space, that is shared with Send Parameters (see <a href="#send-params" class="xref">Section 7.1</a>). While Application Intents and Protocol Properties take parameter specific values, Transport Preferences use one of five fixed levels (see <a href="#transport-prefs" class="xref">Section 5.2.1</a>).</p>
<p id="rfc.section.5.2.p.3">Some parameters express strict requirements that the application relies on, while others are hints of what transport features would be helpful for the application. For example, if an application asks for reliable data transfer, choosing a transport protocol such as UDP, which does not have this feature, will break the application&#8217;s functionality. On the other hand, the option to not require checksums when receiving an individual Content can help optimize for low latency, but if not present, it will most likely not break the fundamental assumptions of the application.  Moreover, there can be conflicts between parameters set by the application: If multiple features are requested which are offered by different protocols, it may not be possible to satisfy all requirements.  Consequently, a transport system must prioritize Transport Parameters and consider the relevant trade-offs, see also <a href="#TAPS-MINSET" class="xref">[TAPS-MINSET]</a>.</p>
<p id="rfc.section.5.2.p.4">Default preference levels and possible combinations of Transport Parameters and preference levels are specified in <a href="#appendix-preferences" class="xref">Appendix B.1</a>.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#transport-prefs" id="transport-prefs">Transport Preferences</a>
</h1>
<p id="rfc.section.5.2.1.p.1">Transport Preferences drive protocol selection and path selection on connection establishment. Since there could be paths over which some transport protocols are unable to operate, or remote endpoints that support only specific network addresses or transports, transport protocol selection is necessarily tied to path selection. This may involve choosing between multiple local interfaces that are connected to different access networks.</p>
<p id="rfc.section.5.2.1.p.2">The Transport Preferences form part of the information used to create a Preconnection object. As such, they can be configured during the pre-establishment phase, but cannot be changed once a Connection has been established.</p>
<p id="rfc.section.5.2.1.p.3">To reflect the needs of an individual connection, they can be specified with different preference levels from the following table , whereby the preference is one of the following levels:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Preference</th>
<th class="left">Effect</th>
</tr></thead>
<tbody>
<tr>
<td class="left"><samp>require </samp></td>
<td class="left">Fail if requested feature/property can not be met</td>
</tr>
<tr>
<td class="left"><samp>prefer  </samp></td>
<td class="left">Proceed if requested feature/property can not be met</td>
</tr>
<tr>
<td class="left"><samp>don't care</samp></td>
<td class="left">None / clear defaults</td>
</tr>
<tr>
<td class="left"><samp>avoid   </samp></td>
<td class="left">Proceed if requested feature/property can not be avoided</td>
</tr>
<tr>
<td class="left"><samp>prohibit</samp></td>
<td class="left">Fail if requested feature/property can not be avoided</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.2.1.p.4">There need to be sensible defaults for the Transport Preferences as well as Protocol Selection Properties. The defaults given in the following section represent a configuration that can be implemented over TCP. An alternate set of default Protocol Selection Properties would represent a configuration that can be implemented over UDP.</p>
<p id="rfc.section.5.2.1.p.5">The following properties apply to Connections and Connection Groups:</p>
<p></p>

<ul>
<li>Reliable Data Transfer: This boolean property specifies whether the application needs the transport protocol to ensure that data is received completely and without corruption on the other side. This also entails being notified when a Connection is closed or aborted. This property applies to connections and connection groups.  This is a strict requirement. The default is to enable Reliable Data Transfer.</li>
<li>Preservation of data ordering: This boolean property specifies whether the application needs the transport protocol to assure that data is received by the application on the other end in the same order as it was sent. This property applies to connections and connection groups. This is a strict requirement. The default is to preserve data ordering.</li>
<li>Configure reliability for individual Content: This boolean property specifies whether an application considers it useful to indicate its reliability requirements on a per-Content basis.  This property applies to connections and connection groups. This is not a strict requirement.  The default is to not have this option.</li>
<li>Request not to delay acknowledgment of Content: This boolean property specifies whether an application considers it useful to request for Content that its acknowledgment be sent out as early as possible instead of potentially being bundled with other acknowledgments. This property applies to connections and connection groups. This is not a strict requirement. The default is to not have this option.</li>
<li>Use 0-RTT session establishment with idempotent Content: This boolean property specifies whether an application would like to supply a Content to the transport protocol before Connection establishment, which will then be reliably transferred to the other side before or during connection establishment, potentially multiple times.  See also <a href="#send-idempotent" class="xref">Section 7.1.1.5</a>.  This is a strict requirement. The default is to not have this option.</li>
<li>Use Connection Groups with priorities: This boolean property specifies whether an application considers it useful to create Connection Groups and explicitly prioritize between Connections within a Connection Group.  This is not a strict requirement.  The default is to not have this option.</li>
<li>Suggest a timeout to the peer: This boolean property specifies whether an application considers it useful to propose a timeout until the connection is assumed to be lost.  This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</li>
<li>Notification of special errors (excessive retransmissions, ICMP error message arrival): This boolean property specifies whether an application considers it useful to be informed in case sent data was retransmitted more often than a certain threshold, or when an ICMP error message arrives. This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</li>
<li>Control checksum coverage on sending or receiving: This boolean property specifies whether the application considers it useful to enable / disable / configure a checksum when sending Content, or decide whether to require a checksum or not when receiving Content.  This property applies to Connections and Connection Groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without being able to change it, and requiring a checksum when receiving.</li>
<li>Interface Type to prefer: This property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to prefer over others for this connection, in case they are available.  This is not a strict requirement. The default is to use the default interface configured in the system policy.</li>
<li>Interface Type to prohibit: This property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to not use for this connection. This is a strict requirement and connection establishment will fail if no other interface is available. The default is to not prohibit any particular interface.</li>
</ul>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#protocol-props" id="protocol-props">Protocol Properties</a>
</h1>
<p id="rfc.section.5.2.2.p.1">Protocol Properties represent the configuration of a transport protocol once it has been selected. A transport protocol may not support all Protocol Properties, depending on the available transport features.  As with Transport Preferences (<a href="#transport-prefs" class="xref">Section 5.2.1</a>), Protocol Properties are specified on the Preconnection object, and are using during initiation of a Connection to help the system choose an appropriate transport.  The system will only actually set those protocol properties that are actually supported by the chosen transport protocol.  These properties all apply to Connections and Connection groups.  The default settings of these properties depends on the chosen protocol and on the system configuration.</p>
<p></p>

<ul>
<li>Set timeout for aborting Connection: This numeric property specifies how long to wait before aborting a Connection attempt.  It is given in seconds.</li>
<li>Set timeout to suggest to the peer: This numeric property specifies the timeout to propose to the peer. It is given in seconds.</li>
<li>Set retransmissions before &#8220;Excessive Retransmissions&#8221;: This numeric property specifies after how many retransmissions to inform the application about &#8220;Excessive Retransmissions&#8221;.</li>
<li>Set required minimum coverage of the checksum for receiving: This numeric property specifies the part of the received data that needs to be covered by a checksum. It is given in Bytes. A value of 0 means that no checksum is required, and a special value (e.g., -1) indicates full checksum coverage.</li>
<li>Set scheduler for connections in a group: This property specifies which scheduler should be used among Connections within a Connection Group. It applies to connection groups. For now we suggest we the schedulers defined in <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</li>
<li>Maximum Content Size Before Connection Establishment: This numeric property represents the maximum Content size that can be sent before or during Connection establishment, see also <a href="#send-idempotent" class="xref">Section 7.1.1.5</a>.  It is given in Bytes.</li>
</ul>
<h1 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#intents" id="intents">Application Intents</a>
</h1>
<p id="rfc.section.5.2.3.p.1">Application Intents are a group of properties expressing what an application wants to achieve, knows, assumes or prefers regarding its communication. They are not strict requirements. In particular, they should not be used to express any Quality of Service expectations that an application might have. Instead, an application should express its intentions and its expected traffic characteristics in order to help the transport system make decisions that best match it, but on a best-effort basis. Even though Application Intents do not represent Quality of Service requirements, a transport system may use them to determine a DSCP value, e.g. similar to Table 1 in <a href="#I-D.ietf-tsvwg-rtcweb-qos" class="xref">[I-D.ietf-tsvwg-rtcweb-qos]</a>.</p>
<p id="rfc.section.5.2.3.p.2">Application Intents can influence protocol selection, protocol configuration, path selection, and endpoint selection. For example, setting the &#8220;Timeliness&#8221; Intent to &#8220;Interactive&#8221; may lead the transport system to disable the Nagle algorithm for a connection, while setting the &#8220;Timeliness&#8221; to &#8220;Background&#8221; may lead it to setting the DSCP value to &#8220;scavenger&#8221;. If the &#8220;Size to be Sent&#8221; Intent is set on individual Content, it may influence path selection, e.g., when the TAPS system schedules big Content over an interface with higher bandwidth, and small Content over an interface with lower latency.</p>
<p id="rfc.section.5.2.3.p.3">Specifying Application Intents is not mandatory. An application can specify any combination of Application Intents.  If specified, Application Intents are defined as parameters passed to the Preconnection object, and may influence the Connection established from that Preconnection.  If a Connection is cloned to form a Connection Group, and associated Application Intents are cloned along with the other transport parameters.  Some Intents have also corresponding Content Properties, similar to the properties in <a href="#send-params" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.5.2.3.p.4">[PHILS:: Some Intents, i.e., Traffic Category, Size to be Received, Receive Bit-rate, Timeliness, Cost Preferences are really useful for per-content path selection. As the latter is out of scope for v1, I removed them from the Send Parameters for now]</p>
<h1 id="rfc.section.5.2.3.1">
<a href="#rfc.section.5.2.3.1">5.2.3.1.</a> <a href="#traffic-category" id="traffic-category">Traffic Category</a>
</h1>
<p id="rfc.section.5.2.3.1.p.1">This Intent specifies what the application expect the dominating traffic pattern to be.</p>
<p id="rfc.section.5.2.3.1.p.2">Possible Category values are:</p>
<p></p>

<dl>
<dt>Query:</dt>
<dd style="margin-left: 8">Single request / response style workload, latency bound</dd>
<dt>Control:</dt>
<dd style="margin-left: 8">Long lasting low bandwidth control channel, not bandwidth bound</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">Stream of bytes/Content with steady data rate</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Bulk transfer of large Content, presumably bandwidth bound</dd>
</dl>
<p id="rfc.section.5.2.3.1.p.4">The default is to not assume any particular traffic pattern. Most categories suggest the use of other intents to further describe the traffic pattern anticipated, e.g., the bulk category suggesting the use of the Message Size intents or the stream category suggesting the Stream Bitrate and Duration intents.</p>
<h1 id="rfc.section.5.2.3.2">
<a href="#rfc.section.5.2.3.2">5.2.3.2.</a> <a href="#size-to-be-sent-received" id="size-to-be-sent-received">Size to be Sent / Received</a>
</h1>
<p id="rfc.section.5.2.3.2.p.1">This Intent specifies what the application expects the size of a transfer to be.  It is a numeric property and given in Bytes.</p>
<h1 id="rfc.section.5.2.3.3">
<a href="#rfc.section.5.2.3.3">5.2.3.3.</a> <a href="#duration" id="duration">Duration</a>
</h1>
<p id="rfc.section.5.2.3.3.p.1">This Intent specifies what the application expects the lifetime of a transfer to be. It is a numeric property and given in milliseconds.</p>
<h1 id="rfc.section.5.2.3.4">
<a href="#rfc.section.5.2.3.4">5.2.3.4.</a> <a href="#send-receive-bit-rate" id="send-receive-bit-rate">Send / Receive Bit-rate</a>
</h1>
<p id="rfc.section.5.2.3.4.p.1">This Intent specifies what the application expects the bit-rate of a transfer to be. It is a numeric property and given in Bytes per second.</p>
<h1 id="rfc.section.5.2.3.5">
<a href="#rfc.section.5.2.3.5">5.2.3.5.</a> <a href="#timeliness" id="timeliness">Timeliness</a>
</h1>
<p id="rfc.section.5.2.3.5.p.1">This Intent specifies what delay characteristics the applications prefers. It provides hints for the transport system whether to optimize for low latency or other criteria. Note that setting this Intents does not imply any guarantees on whether an application&#8217;s requirements can actually be satisfied.</p>
<p></p>

<dl>
<dt>Stream:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be kept as low as possible</dd>
<dt>Interactive:</dt>
<dd style="margin-left: 8">Delay should be kept as low as possible, but some variation is tolerable</dd>
<dt>Transfer:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be reasonable, but are not critical</dd>
<dt>Background:</dt>
<dd style="margin-left: 8">Delay and packet delay variation is no concern</dd>
</dl>
<p id="rfc.section.5.2.3.5.p.3">The default is &#8220;Transfer&#8221;.</p>
<h1 id="rfc.section.5.2.3.6">
<a href="#rfc.section.5.2.3.6">5.2.3.6.</a> <a href="#cost-preferences" id="cost-preferences">Cost Preferences</a>
</h1>
<p id="rfc.section.5.2.3.6.p.1">This Intent describes what an application prefers regarding monetary costs, e.g., whether it considers it acceptable to utilize limited data volume. It provides hints to the transport system on how to handle trade-offs between cost and performance or reliability. This Intent can also apply to individual Content.</p>
<p></p>

<dl>
<dt>No Expense:</dt>
<dd style="margin-left: 8">Avoid transports associated with monetary cost</dd>
<dt>Optimize Cost:</dt>
<dd style="margin-left: 8">Prefer inexpensive transports and accept service degradation</dd>
<dt>Balance Cost:</dt>
<dd style="margin-left: 8">Use system policy to balance cost and other criteria</dd>
<dt>Ignore Cost:</dt>
<dd style="margin-left: 8">Ignore cost, choose transport solely based on other criteria</dd>
</dl>
<p id="rfc.section.5.2.3.6.p.3">The default is &#8220;Balance Cost&#8221;.</p>
<h1 id="rfc.section.5.2.4">
<a href="#rfc.section.5.2.4">5.2.4.</a> <a href="#transport-parameters-object" id="transport-parameters-object">Transport Parameters Object</a>
</h1>
<p id="rfc.section.5.2.4.p.1">All transport parameters used in the pre-establishment phase are collected in a TransportParameters object that is passed to the Preconnection object.</p>
<pre>
transportParameters := NewTransportParameters()
</pre>
<p id="rfc.section.5.2.4.p.2">The Individual parameters are then added to the TransportParameters object.  While Protocol Properties and Application Intents use the <samp>add</samp> call, Transport Preferences use special calls for the levels defined in <a href="#transport-params" class="xref">Section 5.2</a>.</p>
<pre>
transportParameters.add(intent, value)

transportParameters.add(parameter, value)

transportParameters.require(preference)
transportParameters.prefer(preference)
transportParameters.dontcare(preference)
transportParameters.avoid(preference)
transportParameters.prohibit(preference)
</pre>
<p id="rfc.section.5.2.4.p.3">For an existing connection, the Transport Parameters can be queried any time by using the following call on the Connection object:</p>
<pre>
transportParameters := connection.getTransportParameters()
</pre>
<p id="rfc.section.5.2.4.p.4">Note that most properties are only considered for connection establishment and can not be changed later on. <a href="#appendix-specify-query-params" class="xref">Appendix B.2</a> gives an overview of what Transport Parameters can be specified and queried during which phase.</p>
<p id="rfc.section.5.2.4.p.5">[Note: We need to more clearly separate out parameters that can be changed once a connection has been established from those that cannot. (csp)]</p>
<p id="rfc.section.5.2.4.p.6">Connections can be cloned at any time, before or after establishment.  A cloned connection and its parent are entangled: they share the same TransportParameters object, changing any parameter for one of them also changes the parameter for the other, connecting one of them also connects the other, etc.  Cloning connections during pre-establishment is encouraged, as it informs the transport system about the intent to form Connection Groups.</p>
<p id="rfc.section.5.2.4.p.7">Note that priority assignment ((see also <a href="#groups" class="xref">Section 6.4</a> for more details) is not shared among cloned connections. Therefore, the priority assignment MUST NOT be realized using the connection level TransportParameters object.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#security-parameters" id="security-parameters">Specifying Security Parameters and Callbacks</a>
</h1>
<p id="rfc.section.5.3.p.1">Common parameters such as TLS ciphersuites are known to implementations. Clients SHOULD use common safe defaults for these values whenever possible. However, as discussed in <a href="#I-D.pauly-taps-transport-security" class="xref">[I-D.pauly-taps-transport-security]</a>, many transport security protocols require specific security parameters and constraints from the client at the time of configuration and actively during a handshake. These configuration parameters are created as follows</p>
<pre>
securityParameters := NewSecurityParameters()
</pre>
<p id="rfc.section.5.3.p.2">Security configuration parameters and sample usage follow:</p>
<p></p>

<ul><li>Local identity and private keys: Used to perform private key operations and prove one&#8217;s identity to remote peers. (Note, if private keys are not available, e.g., since they are stored in HSMs, handshake callbacks MUST be used. See below for details.)</li></ul>
<pre>
securityParameters.AddIdentity(identity)
securityParameters.AddPrivateKey(privateKey, publicKey)
</pre>
<p></p>

<ul><li>Supported algorithms: Used to restrict what parameters are used by underlying transport security protocols.  When not specified, these algorithms SHOULD default to known and safe defaults for the system. Parameters include: ciphersuites, supported groups, and signature algorithms.</li></ul>
<pre>
securityParameters.AddSupportedGroup(22)    // secp256k1
securityParameters.AddCiphersuite(0xCCA9)   // TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
securityParameters.AddSignatureAlgorithm(7) // ed25519
</pre>
<p></p>

<ul><li>Session cache: Used to tune cache capacity, lifetime, re-use, and eviction policies, e.g., LRU or FIFO.</li></ul>
<pre>
securityParameters.SetSessionCacheCapacity(1024)     // 1024 elements
securityParameters.SetSessionCacheLifetime(24*60*60) // 24 hours
securityParameters.SetSessionCacheReuse(1)           // One-time use
</pre>
<p></p>

<ul><li>Pre-shared keying material: Used to install pre-shared keying material established out-of-band. Each pre-shared keying material is associated with some identity that typically identifies its use or has some protocol-specific meaning to peers.</li></ul>
<pre>
securityParameters.AddPreSharedKey(key, identity)
</pre>
<p id="rfc.section.5.3.p.7">Security decisions, especially pertaining to trust, are not static. Thus, once configured, parameters must also be supplied during live handshakes. These are best handled as client-provided callbacks. Security handshake callbacks include:</p>
<p></p>

<ul><li>Trust verification callback: Invoked when a peer&#8217;s trust must be validated before the handshake protocol can proceed.</li></ul>
<pre>
trustCallback := NewCallback({
  // Handle trust, return the result
})
securityParameters.SetTrustVerificationCallback(trustCallback)
</pre>
<p></p>

<ul><li>Identity challenge callback: Invoked when a private key operation is required, e.g., when local authentication is requested by a remote.</li></ul>
<pre>
challengeCallback := NewCallback({
  // Handle challenge
})
securityParameters.SetIdentityChallengeCallback(challengeCallback)
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#establishing-connections" id="establishing-connections">Establishing Connections</a>
</h1>
<p id="rfc.section.6.p.1">Before a Connection can be used for data transfer, it must be established.  Establishment ends the pre-establishment phase; all transport and cryptographic parameter specification must be complete before establishment, as these parameters will be used to select candidate Paths and Protocol Stacks for the Connection. Establishment may be active, using the Initiate() Action; passive, using the Listen() Action; or simultaneous for peer-to-peer, using the Rendezvous() Action. These Actions are described in the subsections below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#initiate" id="initiate">Active Open: Initiate</a>
</h1>
<p id="rfc.section.6.1.p.1">Active open is the action of establishing a connection to an endpoint presumed to be listening for incoming connection requests, commonly used by clients in client-server interactions. Active open is supported by this interface through the Initiate action:</p>
<p id="rfc.section.6.1.p.2">Connection := Preconnection.Initiate()</p>
<p id="rfc.section.6.1.p.3">Before calling Initiate, the caller must have populated a Preconnection object with local and remote endpoint specifiers, as well as all parameters necessary for candidate selection. After calling Initiate, no further parameters may be bound to the Connection. The Initiate() call consumes the Preconnection and creates a Connection object. A Preconnection can only be initiated once.</p>
<p id="rfc.section.6.1.p.4">Once Initiate is called, the candidate Protocol Stack(s) may cause one or more candidate transport-layer connections to be created to the specified remote endpoint. The caller may immediately begin sending Content on the Connection (see <a href="#sending" class="xref">Section 7</a>) after calling Initate(); note that any idempotent data sent while the Connection is being established may be sent multiple times or on multiple candidates.</p>
<p id="rfc.section.6.1.p.5">The following events may be sent by the Connection after Initiate() is called:</p>
<p id="rfc.section.6.1.p.6">Connection -&gt; Ready&lt;&gt;</p>
<p id="rfc.section.6.1.p.7">The Ready event occurs after Initiate has established a transport-layer connection on at least one usable candidate Protocol Stack over at least one candidate Path. No Receive events (see <a href="#receiving" class="xref">Section 8</a>) will occur before the Ready event for connections established using Initiate.</p>
<p id="rfc.section.6.1.p.8">Connection -&gt; InitiateError&lt;&gt;</p>
<p id="rfc.section.6.1.p.9">An InitiateError occurs either when the set of transport and cryptographic parameters cannot be fulfilled on a connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty) or reconciled with the local and/or remote endpoints; when the remote specifier cannot be resolved; or when no transport-layer connection can be established to the remote endpoint (e.g. because the remote endpoint is not accepting connections, or the application is prohibited from opening a connection by the operating system).</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#listen" id="listen">Passive Open: Listen</a>
</h1>
<p id="rfc.section.6.2.p.1">Passive open is the action of waiting for connections from remote endpoints, commonly used by servers in client-server interactions. Passive open is supported by this interface through the Listen action:</p>
<p id="rfc.section.6.2.p.2">Preconnection.Listen()</p>
<p id="rfc.section.6.2.p.3">Before calling Listen, the caller must have initialized the Preconnection during the pre-establishment phase with local endpoint specifiers, as well as all parameters necessary for Protocol Stack selection.  The Listen() action consumes the Preconnection. Once Listen() has been called, no further parameters may be bound to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<p id="rfc.section.6.2.p.4">Preconnection -&gt; ConnectionReceived&lt;Connection&gt;</p>
<p id="rfc.section.6.2.p.5">The ConnectionReceived event occurs when a RemoteEndpoint has established a transport-layer connection to this Preconnection (for connection-oriented transport protocols), or when the first Content has been received from the remote endpoint (for connectionless protocols), causing a new Connection to be created. The resulting Connection is contained within the ConnectionReceived event, and is ready to use as soon as it is passed to the application via the event.</p>
<p id="rfc.section.6.2.p.6">PreConnection -&gt; Error&lt;&gt;</p>
<p id="rfc.section.6.2.p.7">A ListenError occurs either when the Preconnection cannot be fulfilled for listening, when the LocalEndpoint (or RemoteEndpoint, if specified) cannot be resolved, or when the application is prohibited from listening by policy.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#rendezvous" id="rendezvous">Peer-to-Peer Establishment: Rendezvous</a>
</h1>
<p id="rfc.section.6.3.p.1">Simultaneous peer-to-peer connection establishment is supported by the Rendezvous() action:</p>
<p id="rfc.section.6.3.p.2">Preconnection.Rendezvous()</p>
<p id="rfc.section.6.3.p.3">The Preconnection object must be specified with both a LocalEndpoint and a RemoteEndpoint, and also the transport and security parameters needed for protocol stack selection. The Rendezvous() action causes the Preconnection to listen on the LocalEndpoint for an incoming connection from the RemoteEndpoint, while simultaneously trying to establish a connection from the LocalEndpoint to the RemoteEndpoint.  This corresponds to a TCP simultaneous open, for example.</p>
<p id="rfc.section.6.3.p.4">The Rendezvous() action consumes the Preconnection. Once Rendezvous() has been called, no further parameters may be bound to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<p id="rfc.section.6.3.p.5">Preconnection -&gt; RendezvousDone&lt;Connection&gt;</p>
<p id="rfc.section.6.3.p.6">The RendezvousDone&lt;&gt; event occurs when a connection is established with the RemoteEndpoint. For connection-oriented transports, this occurs when the transport-layer connection is established; for connectionless transports, it occurs when the first Content is received from the RemoteEndpoint. The resulting Connection is contained within the RendezvousDone&lt;&gt; event, and is ready to use as soon as it is passed to the application via the event.</p>
<p id="rfc.section.6.3.p.7">Preconnection -&gt; RendezvousError&lt;contentRef, error&gt;</p>
<p id="rfc.section.6.3.p.8">An RendezvousError occurs either when the Preconnection cannot be fulfilled for listening, when the LocalEndpoint or RemoteEndpoint cannot be resolved, when no transport-layer connection can be established to the RemoteEndpoint, or when the application is prohibited from rendezvous by policy.</p>
<p id="rfc.section.6.3.p.9">When using some NAT traversal protocols, e.g., ICE <a href="#RFC5245" class="xref">[RFC5245]</a>, it is expected that the LocalEndpoint will be configured with some method of discovering NAT bindings, e.g., a STUN server. In this case, the LocalEndpoint may resolve to a mixture of local and server reflexive addresses. The Resolve() method on the Preconnection can be used to discover these bindings:</p>
<pre>
PreconnectionBindings := Preconnection.Resolve()
</pre>
<p id="rfc.section.6.3.p.10">The Resolve() call returns a list of Preconnection objects, that represent the concrete addresses, local and server reflexive, on which a Rendezvous() for the Preconnection will listen for incoming connections. This list can be passed to a peer via a signalling protocol, such as SIP or WebRTC, to configure the remote.</p>
<p id="rfc.section.6.3.p.11">[NOTE: This API is sufficient for TCP-style simultaneous open, but should be considered experimental for ICE-like protocols.]</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#groups" id="groups">Connection Groups</a>
</h1>
<p id="rfc.section.6.4.p.1">Groups of Connections can be created using Clone action:</p>
<p id="rfc.section.6.4.p.2">Connection := Connection.Clone()</p>
<p id="rfc.section.6.4.p.3">Calling this once yields a group of two Connections: the parent Connection &#8211; whose Clone action was called &#8211; and the resulting clone. Calling Clone on any of these two Connections adds a third Connection to the group, and so on.  All Connections in a group are entangled. This means that they automatically share all properties: changing a parameter for one of them also changes the parameter for all others, closing one of them also closes all others, etc.</p>
<p id="rfc.section.6.4.p.4">There is only one Protocol Property that is not entangled, i.e., it is a separate per-Connection Property for individual Connections in the group: a priority.  This priority, which can be represented as a non-negative integer or float, expresses a desired share of the Connection Group&#8217;s available network capacity, such that an ideal transport system implementation would assign the Connection the capacity share P x C/sum_P, where P = priority, C = total available capacity and sum_P = sum of all priority values that are used for the Connections in the same Connection Group.  The priority setting is purely advisory; no guarantees are given.</p>
<p id="rfc.section.6.4.p.5">Connection Groups should be created (i.e., the Clone action should be used) as early as possible, ideally already during the Pre-Establishment phase, in order to aid the Transport System in choosing and configuring the right protocols (see also <a href="#transport-params" class="xref">Section 5.2</a>).</p>
<p id="rfc.section.6.4.p.6">[TASK: If Clone() is a method on Connection, it cannot be called during pre-establishment, since we don&#8217;t have a Connection at that time (csp)]</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sending" id="sending">Sending Data</a>
</h1>
<p id="rfc.section.7.p.1">Once a Connection has been established, it can be used for sending data. Data is sent by passing a Content object and additional parameters <a href="#send-params" class="xref">Section 7.1</a> to the Send action on an established connection:</p>
<p id="rfc.section.7.p.2">Connection.Send(Content, sendParameters)</p>
<p id="rfc.section.7.p.3">The type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. It may itself contain an array of octets to be transmitted in the transport protocol payload, or be transformable to an array of octets by a sender-side framer (see <a href="#send-framing" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.7.p.4">If Send is called on a Connection which has not yet been established, an Initiate action will be implicitly performed simultaneously with the Send.  Used together with the Idempotent property (see <a href="#send-idempotent" class="xref">Section 7.1.1.5</a>), this can be used to send data during establishment for 0-RTT session resumption on Protocol Stacks that support it.</p>
<p id="rfc.section.7.p.5">Like all Actions in this interface, the Send action is asynchronous.</p>
<p id="rfc.section.7.p.6">Connection -&gt; Sent&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.7">The Sent event occurs when a previous Send action has completed, i.e., when the data derived from the Content has been passed down or through the underlying Protocol Stack and is no longer the responsibility of the implementation of this interface. The exact disposition of Content when the Sent event occurs is specific to the implementation and the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Sent event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.8">Sent events allow an application to obtain an understanding of the amount of buffering it creates. That is, if an application calls the Send action multiple times without waiting for a Sent event, it has created more buffer inside the transport system than an application that only issues a Send after this event fires.</p>
<p id="rfc.section.7.p.9">Connection -&gt; Expired&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.10">The Expired event occurs when a previous Send action expired before completion; i.e. when the data derived from the Content was not sent before its Lifetime (see <a href="#send-lifetime" class="xref">Section 7.1.1.1</a>) expired. This is separate from SendError, as it is an expected behavior for partially reliable transports. The Expired event contains an implementation-specific reference to the Content to which it applies.</p>
<p id="rfc.section.7.p.11">Connection -&gt; SendError&lt;contentRef&gt;</p>
<p id="rfc.section.7.p.12">A SendError occurs when Content could not be sent due to an error condition: some failure of the underlying Protocol Stack, or a set of send parameters not consistent with the Connection&#8217;s transport parameters. The SendError contains an implementation-specific reference to the Content to which it applies.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#send-params" id="send-params">Send Parameters</a>
</h1>
<p id="rfc.section.7.1.p.1">[MICHAEL: Here, things get really messy (even after I cleaned them up a bit).  First, I see no need to have app intents defined both per-connection (in an earlier section) AND per-content. If they really make sense per-content, they should be defined here and not in the other section. However, some of the ones here VERY obviously don&#8217;t fit a single piece of content: stream bitrate sent / stream bitrate received. This is about a number that, by nature, is a longer term average. Sure, an application may want to change it whenever, and it can &#8212; but that doesn&#8217;t make it something that really relates to a single piece of content. These two make so little sense here that I decided to remove them for you. For the others, please make up your mind where they fit / what they relate to. Second, whatever will remain doesn&#8217;t need its own &#8220;app intents&#8221; heading: it will only relate to content, genuinely making it a &#8220;content property&#8221;. I leave the heading in there now just so the app intents stuff stands out a bit more, but when you&#8217;re done removing things, please remove this heading and make what&#8217;s left a part of the Content Properties.] [PHILS: Cleanup done. From my perspective, there are Parameters (including Intents), that belong in both categories. Besides those that are useful for per-connection and per-content path-selection (I removed those for v1), there remain two dual-use properties: &#8220;Send Bitrate&#8221; (path selection in connection / shaping and de-bursting in ) and &#8220;Timeliness&#8221; (path selection and DSCP default in connection / buffering and DSCP per content) &#8212; in both cases, I don&#8217;t see how to achieve the functionality when having them only in one of the places.]</p>
<p id="rfc.section.7.1.p.2">The Send action takes per-Content send parameters which control how the contents will be sent down to the underlying Protocol Stack and transmitted.</p>
<p id="rfc.section.7.1.p.3">If Send Parameters should be overridden for a specific content, an empty sent parameter Object can be acquired and all desired Send Parameters can be added to that object. A sendParameters object can be reused for sending multiple contents with the same properties.</p>
<pre>
sendParameters := NewSendParameters()
sendParameters.add(parameter, value)
</pre>
<p id="rfc.section.7.1.p.4">The Send Parameters are organized in <em>Content Properties</em> and <em>Application Intents</em>.  The Send Parameters share a single namespace with the Transport Parameters (see <a href="#transport-params" class="xref">Section 5.2</a>). This allows to specify Protocol Properties and that can be overridden on a per content basis or Application Intents that apply to a specific content.  See <a href="#appendix-specify-query-params" class="xref">Appendix B.2</a> for an overview.</p>
<p id="rfc.section.7.1.p.5">[NOTE: some of these parameters are not compatible with transport parameters; attempting to Send with such an incompatibility yields a SendError.]</p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#content-properties" id="content-properties">Content Properties</a>
</h1>
<h1 id="rfc.section.7.1.1.1">
<a href="#rfc.section.7.1.1.1">7.1.1.1.</a> <a href="#send-lifetime" id="send-lifetime">Lifetime</a>
</h1>
<p id="rfc.section.7.1.1.1.p.1">Lifetime specifies how long a particular Content can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted. When a Content&#8217;s Lifetime is infinite, it must be transmitted reliably. The type and units of Lifetime are implementation-specific.</p>
<h1 id="rfc.section.7.1.1.2">
<a href="#rfc.section.7.1.1.2">7.1.1.2.</a> <a href="#send-niceness" id="send-niceness">Niceness</a>
</h1>
<p id="rfc.section.7.1.1.2.p.1">Niceness represents an unbounded hierarchy of priorities of Content, relative to other Content sent over the same Connection and/or Connection Group (see <a href="#groups" class="xref">Section 6.4</a>). It is most naturally represented as a non-negative integer.  Content with Niceness 0 will yield to Content with Niceness 1, which will yield to Content with Niceness 2, and so on. Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.</p>
<p id="rfc.section.7.1.1.2.p.2">Note that this inversion of normal schemes for expressing priority has a convenient property: priority increases as both Niceness and Lifetime decrease.</p>
<h1 id="rfc.section.7.1.1.3">
<a href="#rfc.section.7.1.1.3">7.1.1.3.</a> <a href="#send-ordered" id="send-ordered">Ordered</a>
</h1>
<p id="rfc.section.7.1.1.3.p.1">Ordered is a boolean property. If true, this Content should be delivered after the last Content passed to the same Connection via the Send action; if false, this Content may be delivered out of order.</p>
<h1 id="rfc.section.7.1.1.4">
<a href="#rfc.section.7.1.1.4">7.1.1.4.</a> <a href="#send-immediate" id="send-immediate">Immediate</a>
</h1>
<p id="rfc.section.7.1.1.4.p.1">Immediate is a boolean property. If true, the caller prefers immediacy to efficient capacity usage for this Content. For example, this means that the Content should not be bundled with other Content into the same transmission by the underlying Protocol Stack.</p>
<h1 id="rfc.section.7.1.1.5">
<a href="#rfc.section.7.1.1.5">7.1.1.5.</a> <a href="#send-idempotent" id="send-idempotent">Idempotent</a>
</h1>
<p id="rfc.section.7.1.1.5.p.1">Idempotent is a boolean property. If true, the application-layer entity in the Content is safe to send to the remote endpoint more than once for a single Send action. It is used to mark data safe for certain 0-RTT establishment techniques, where retransmission of the 0-RTT data may cause the remote application to receive the Content multiple times.</p>
<h1 id="rfc.section.7.1.1.6">
<a href="#rfc.section.7.1.1.6">7.1.1.6.</a> <a href="#send-checksum" id="send-checksum">Corruption Protection Length</a>
</h1>
<p id="rfc.section.7.1.1.6.p.1">This numeric property specifies the length of the section of content, starting from byte 0, that the application assumes will be received without corruption due to lower layer errors. It is used to specify options for simple integrity protection via checksums. By default, the entire Content is protected by checksum. A value of 0 means that no checksum is required, and a special value (e.g. -1) can be used to indicate the default. Only full coverage is guaranteed, any other requests are advisory.</p>
<h1 id="rfc.section.7.1.1.7">
<a href="#rfc.section.7.1.1.7">7.1.1.7.</a> <a href="#send-ackimmed" id="send-ackimmed">Immediate Acknowledgement</a>
</h1>
<p id="rfc.section.7.1.1.7.p.1">This boolean property specifies, if true, that an application wants this Content to be acknowledged immediately by the receiver. In case of reliable transmission, this informs the transport protocol on the sender side faster that it can remove the Content from its buffer; therefore this property can be useful for latency-critical applications that maintain tight control over the send buffer (see <a href="#sending" class="xref">Section 7</a>).</p>
<h1 id="rfc.section.7.1.1.8">
<a href="#rfc.section.7.1.1.8">7.1.1.8.</a> <a href="#send-bitrate" id="send-bitrate">Send Bitrate</a>
</h1>
<p id="rfc.section.7.1.1.8.p.1">This numeric property in Bytes per second specifies at what bitrate the application wishes the content to be sent. A transport supporting this feature will not exceed the requested Send Bitrate even if flow-control and congestion control allow higher bitrates. This helps to avid bursty traffic pattern on busy video streaming servers.</p>
<p id="rfc.section.7.1.1.8.p.2">[PHILS: this my be removed if there is no consensus this this is useful. See https://www.usenix.org/conference/atc12/technical-sessions/presentation/ghobadi for a use case and implementation ]</p>
<h1 id="rfc.section.7.1.1.9">
<a href="#rfc.section.7.1.1.9">7.1.1.9.</a> <a href="#send-timeliness" id="send-timeliness">Timeliness</a>
</h1>
<p id="rfc.section.7.1.1.9.p.1">This specifies what delay characteristics the applications prefers for the given content. It provides hints for the transport system whether to optimize for low latency or other criteria and set the DSCP flags for packets used to transmit the content.</p>
<p></p>

<dl>
<dt>Stream:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be kept as low as possible</dd>
<dt>Interactive:</dt>
<dd style="margin-left: 8">Delay should be kept as low as possible, but some variation is tolerable</dd>
<dt>Transfer:</dt>
<dd style="margin-left: 8">Delay and packet delay variation should be reasonable, but are not critical</dd>
<dt>Background:</dt>
<dd style="margin-left: 8">Delay and packet delay variation is no concern</dd>
</dl>
<p id="rfc.section.7.1.1.9.p.3">The default is &#8220;Transfer&#8221;.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#send-framing" id="send-framing">Sender-side Framing</a>
</h1>
<p id="rfc.section.7.2.p.1">Sender-side framing allows a caller to provide the interface with a function that takes Content of an appropriate type and returns an array of octets, the on-the-wire representation of the content to be handed down to the Protocol Stack. It consists of a Framer object with a single Action, Frame. Since the Framer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.7.2.p.2">Connection.FrameWith(Framer)</p>
<p id="rfc.section.7.2.p.3">OctetArray := Framer.Frame(Content)</p>
<p id="rfc.section.7.2.p.4">Sender-side framing is a convenience feature of the interface, for parity with receiver-side framing (see <a href="#receive-framing" class="xref">Section 8.2</a>).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#receiving" id="receiving">Receiving Data</a>
</h1>
<p id="rfc.section.8.p.1">Once a Connection is established, Content may be received on it. The interface notifies the application that content has been received via the Received event:</p>
<p id="rfc.section.8.p.2">Connection -&gt; Received&lt;Content&gt;</p>
<p id="rfc.section.8.p.3">As with sending, the type of the Content to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Content may also contain metadata from protocols in the Protocol Stack for logging and debugging purposes. In particular, when this information is available, the value of the Explicit Congestion Notification (ECN) field is contained in such metadata.</p>
<p id="rfc.section.8.p.4">The Content object must provide some method to retrieve an octet array containing application data, corresponding to a single message within the underlying Protocol Stack&#8217;s framing.  See <a href="#receive-framing" class="xref">Section 8.2</a> for handling framing in situations where the Protocol Stack provides octet-stream transport only.</p>
<p id="rfc.section.8.p.5">Connection -&gt; ReceiveError&lt;&gt;</p>
<p id="rfc.section.8.p.6">A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or deframed, or when some other indication is received that reception has failed. Such conditions that irrevocably lead the the termination of the Connection are signaled using ConnectionError instead (see <a href="#termination" class="xref">Section 10</a>).</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#receive-backpressure" id="receive-backpressure">Application-Layer Back-Pressure at the Receiver</a>
</h1>
<p id="rfc.section.8.1.p.1">Implementations of this interface must provide some way for the application to indicate that it is temporarily not ready to receive new Content. Since the mechanisms of event handling are implementation-platform specific, this document does not specify the exact nature of this interface.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#receive-framing" id="receive-framing">Receiver-side De-framing over Stream Protocols</a>
</h1>
<p id="rfc.section.8.2.p.1">The Receive event is intended to be fired once per application-layer Content sent by the remote endpoint; i.e., it is a desired property of this interface that a Send at one end of a Connection maps to exactly one Receive on the other end. This is possible with Protocol Stacks that provide message boundary preservation, but is not the case over Protocol Stacks that provide a simple octet stream transport.</p>
<p id="rfc.section.8.2.p.2">For preserving message boundaries over stream transports, this interface provides receiver-side de-framing. This facility is based on the observation that, since many of our current application protocols evolved over TCP, which does not provide message boundary preservation, and since many of these protocols require message boundaries to function, each application layer protocol has defined its own framing. A Deframer allows an application to push this de-framing down into the interface, in order to transform an octet stream into a sequence of Content.</p>
<p id="rfc.section.8.2.p.3">Concretely, receiver-side de-framing allows a caller to provide the interface with a function that takes an octet stream, as provided by the underlying Protocol Stack, reads and returns a sigle Content of an appropriate type for the application and platform, and leaves the octet stream at the start of the next Content. It consists of a Deframer object with a single Action, Deframe.  Since the Deframer depends on the protocol used at the application layer, it is bound to the Connection during the pre-establishment phase:</p>
<p id="rfc.section.8.2.p.4">Connection.DeframeWith(Deframer)</p>
<p id="rfc.section.8.2.p.5">Content := Deframer.Deframe(OctetStream, &#8230;)</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#introspection" id="introspection">Setting and Querying of Connection Properties</a>
</h1>
<p id="rfc.section.9.p.1">At any point, the application can set and query the properties of a Connection. Depending on the phase the connection is in, the connection properties will include different information.</p>
<pre>
connectionProperties := Connection.getProperties()
</pre>
<pre>
Connection.setProperties()
</pre>
<p id="rfc.section.9.p.2">Connection properties may include:</p>
<p></p>

<ul>
<li>The status of the Connection, which can be one of the following: Establishing, Established, Closed. [TASK: can connections be in a Closing state? (csp)]</li>
<li>Transport Features of the protocols that conform to the Required and Prohibited Transport Preferences, which might be selected by the transport system during Establishment. These features correspond to the properties given in <a href="#transport-params" class="xref">Section 5.2</a> and can only be queried.</li>
<li>Transport Features of the protocols that were selected, once the Connection has been established. These features correspond to the properties given in <a href="#transport-params" class="xref">Section 5.2</a> and can only be queried.</li>
<li>Protocol Properties of the protocols in use, once the Connection has been established. These properties correspond to the properties given <a href="#protocol-props" class="xref">Section 5.2.2</a> and can be set and queried.</li>
<li>Path Properties of the path(s) in use, once the Connection has been established. These properties can be derived from the local provisioning domain, measurements by the protocol stack, or other sources. They can only be queried.</li>
</ul>
<p><a href="#appendix-specify-query-params" class="xref">Appendix B.2</a> gives a more detailed overview of the different types of properties that can be set and queried at different times.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.10.p.1">Close terminates a Connection after satisfying all the requirements that were specified regarding the delivery of Content that the application has already given to the transport system. For example, if reliable delivery was requested for Content handed over before calling Close, the transport system will ensure that such Content is indeed delivered. If the peer still has data to send, it cannot be received after this call.</p>
<p id="rfc.section.10.p.2">Connection.Close()</p>
<p id="rfc.section.10.p.3">The Closed event can inform the application that the peer has closed the Connection; however, there is no guarantee that a remote close will be signaled.</p>
<p id="rfc.section.10.p.4">Connection -&gt; Closed&lt;&gt;</p>
<p id="rfc.section.10.p.5">Abort terminates a Connection without delivering remaining data:</p>
<p id="rfc.section.10.p.6">Connection.Abort()</p>
<p id="rfc.section.10.p.7">A ConnectionError can inform the application that the other side has aborted the Connection; however, there is no guarantee that an abort will be signaled:</p>
<p id="rfc.section.10.p.8">Connection -&gt; ConnectionError&lt;&gt;</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#event-and-error-handling" id="event-and-error-handling">Event and Error Handling</a>
</h1>
<p id="rfc.section.11.p.1">[NOTE: point out that events and errors may be handled differently, although they are the modeled the same in this specification.]</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.12.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.12.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.13.p.1">This document describes a generic API for interacting with a transport services (TAPS) system.  Part of this API includes configuration details for transport security protocols, as discussed in Section <a href="#security-parameters" class="xref">Section 5.3</a>. It does not recommend use (or disuse) of specific algorithms or protocols. Any API-compatible transport security protocol should work in a TAPS system.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.14.p.1">This work has received funding from the European Union&#8217;s Horizon 2020 research and innovation programme under grant agreements No. 644334 (NEAT) and No. 688421 (MAMI).</p>
<p id="rfc.section.14.p.2">This work has been supported by Leibniz Prize project funds of DFG - German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).</p>
<p id="rfc.section.14.p.3">Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.</p>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">15.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-rtcweb-qos">[I-D.ietf-tsvwg-rtcweb-qos]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Dhesikan, S.</a>, <a>Jennings, C.</a> and <a>D. Druta</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">DSCP Packet Markings for WebRTC QoS</a>", Internet-Draft draft-ietf-tsvwg-rtcweb-qos-18, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-sctp-ndata">[I-D.ietf-tsvwg-sctp-ndata]</b></td>
<td class="top">
<a>Stewart, R.</a>, <a>Tuexen, M.</a>, <a>Loreto, S.</a> and <a>R. Seggelmann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13">Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</a>", Internet-Draft draft-ietf-tsvwg-sctp-ndata-13, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-ARCH">[TAPS-ARCH]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Trammell, B.</a>, <a>Brunstrom, A.</a>, <a>Fairhurst, G.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a>An Architecture for Transport Services</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">15.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.pauly-taps-transport-security">[I-D.pauly-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Rose, K.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-pauly-taps-transport-security-01">A Survey of Transport Security Protocols</a>", Internet-Draft draft-pauly-taps-transport-security-01, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="https://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-MINSET">[TAPS-MINSET]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-01">A Minimal Set of Transport Services for TAPS Systems</a>", Internet-Draft draft-ietf-taps-minset-01, February 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#appendix-api-sketch" id="appendix-api-sketch">Sample API definition in Go</a>
</h1>
<p id="rfc.section.A.p.1">This document defines an abstract interface. To illustrate how this would map concretely into a programming language, this appendix contains an API interface definition in Go, using callbacks for event handling. The documentation for the API sketch is available online at https://godoc.org/github.com/mami-project/postsocket.</p>
<pre>
package postsocket

import (
  "crypto"
  "crypto/tls"
  "io"
  "net"
  "time"
)

type TransportContext interface {
  NewTransportParameters() TransportParameters
  NewSecurityParameters() SecurityParameters
  NewRemote() Remote
  NewLocal() Local
  DefaultSendParameters() SendParameters

  SetEventHandler(evh EventHandler)
  SetFramingHandler(fh FramingHandler)

  Preconnect(evh EventHandler, fh FramingHandler,
             rem Remote, loc Local,
             tp TransportParameters,
             sp SecurityParameters) (Preconnection, error)

  Initiate(rem Remote, loc Local,
           tp TransportParameters,
           sp SecurityParameters) (Connection, error)
  Rendezvous(rem Remote, loc Local,
             tp TransportParameters,
             sp SecurityParameters) (Connection, error)
  Listen(loc Local,
         tp TransportParameters,
         sp SecurityParameters) (Connection, error)
}

type Remote interface {
  WithHostname(hostname string) Remote
  WithAddress(address net.IP) Remote
  WithPort(port uint16) Remote
  WithServiceName(svc string) Remote
}

type Local interface {
  WithInterface(iface string) Local
  WithHostname(hostname string) Local
  WithAddress(address net.IP) Local
  WithPort(port uint16) Local
  WithServiceName(svc string) Local
}

type ParameterIdentifier int

const (
  TransportFullyReliable = iota
  // ... and so on
)

type TransportParameters interface {
  Require(p ParameterIdentifier, v int) TransportParameters
  Prefer(p ParameterIdentifier, v int) TransportParameters
  Avoid(p ParameterIdentifier, v int) TransportParameters
  Prohibit(p ParameterIdentifier, v int) TransportParameters
}

type SecurityMetadata struct {
  cert tls.Certificate
  // ... and so on
}

const (
  SecurityCallbackResultSuccess = 0x00
  SecurityCallbackResultFailure = 0x01
  SecurityCallbackResultPending = 0x02
)

type SecurityCallbackResult int

type SecurityParameters interface {
  AddIdentity(c tls.Certificate) SecurityParameters
  AddPrivateKey(sk crypto.PrivateKey, pk crypto.PublicKey) SecurityParameters
  AddPreSharedKey(key []byte, identity string) SecurityParameters
  AddSupportedGroup(g uint16) SecurityParameters
  AddCiphersuite(cs uint16) SecurityParameters
  AddSignatureAlgorithm(cs uint16) SecurityParameters
  SetSessionCacheCapacity(c int) SecurityParameters
  SetSessionCacheLifetime(t int) SecurityParameters
  SetSessionCacheReuse(c int) SecurityParameters
  VerifyTrustWith(func(m SecurityMetadata) (bool, error)) SecurityCallbackResult
  HandleChallengeWith(func(m SecurityMetadata) (bool, error)) SecurityCallbackResult
  Require(p ParameterIdentifier, v interface{} SecurityParameters
  Prefer(p ParameterIdentifier, v interface{}) SecurityParameters
  Avoid(p ParameterIdentifier, v interface{}) SecurityParameters
  Prohibit(p ParameterIdentifier, v interface{}) SecurityParameters
}

type SendParameters struct {
  Lifetime time.Duration
  Niceness uint
  Ordered bool
  Immediate bool
  Idempotent bool
  CorruptionProtection int
  AckImmediate bool
}

type Preconnection interface {
  AddSpecifier(rem Remote, loc Local,
               tp TransportParameters, sp SecurityParameters)
  Initiate() (Connection, error)
  InitialSend(content interface{}, sp SendParameters) (Connection, error)
  Rendezvous() (Connection, error)
  Listen() (Connection, error)
}

type Connection interface {
  Send(content interface{}, contentref interface{}, sp SendParameters) error

  Clone() (Connection, error)
  Close() error

  GetEventHandler() EventHandler
  SetEventHandler(evh EventHandler)

  GetFramingHandler() FramingHandler
  SetFramingHandler(fh FramingHandler)
}

type Content interface {
  Bytes() []byte
  GetMetadata(key string) interface{}
}

// EventHandler defines the interface for connection event handlers.
type EventHandler interface {
  Ready(conn Connection, ante Connection)
  Received(content Content, conn Connection)
  Sent(conn Connection, contentref interface{})
  Expired(conn Connection, contentref interface{})
  Closed(conn Connection, err error)
  // note that errors are coalesced into a single handler; the err parameter
  // contains the type of error, and contentref is nil for all but send errors.
  Error(conn Connection, contentref interface{}, err error)
}

type FramingHandler interface {
  Frame(content interface{}) ([]byte, error)
  Deframe(in io.Reader) (Content, error)
}
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#appendix-transport-params" id="appendix-transport-params">Transport Parameters</a>
</h1>
<p id="rfc.section.B.p.1">This appendix provides details about the usage of the Transport Parameters specified in <a href="#transport-params" class="xref">Section 5.2</a>. It clarifies what preference levels an application can set for which Transport Parameter, and during which phase an application can specify and query what kinds of Transport Parameters.</p>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#appendix-preferences" id="appendix-preferences">Application Preferences</a>
</h1>
<p id="rfc.section.B.1.p.1">As described in <a href="#transport-params" class="xref">Section 5.2</a>, an application can specify its preference regarding a Transport Parameter, i.e., whether a certain property is required, preferred, to be avoided, prohibited, or an intention. If an application does not set its preference regarding a Transport Parameter, default preference levels apply as specified in the following table. A default preference of &#8220;None&#8221; means that the transport system assumes that an application does not have any preference regarding the corresponding Transport Parameter and may not take this parameter into account for protocol and path selection.</p>
<p id="rfc.section.B.1.p.2">Not every Transport Parameter can be meaningfully assigned every preference level. For example, if an application explicitly prohibits selecting a transport protocol that allows to suggest a timeout to the peer, this restriction will unnecessarily limit transport protocol selection. Instead, the application could simply not use this feature if it is present in the selected transport protocol.</p>
<p id="rfc.section.B.1.p.3">The following table illustrates which Transport Parameter has which default preference level and which alternative preference levels an application may set.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Transport Parameter</th>
<th class="left">Require</th>
<th class="left">Prefer</th>
<th class="left">Avoid</th>
<th class="left">Prohibit</th>
<th class="left">Default</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Reliable Data Transfer</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Preserve Data Ordering</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Configure Reliability per Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Request immediate ACK</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use 0-RTT with Idempotent Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use Connection Groups with priorities</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Suggest timeout to peer</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Notification of special errors</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Control checksum coverage</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use a certain network interface type</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Application Intents</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Intend</td>
</tr>
</tbody>
</table>
<p id="rfc.section.B.1.p.4">[List individual Intents? Reformulate some of them as preferences?]</p>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#appendix-specify-query-params" id="appendix-specify-query-params">Specifying and Querying Parameters</a>
</h1>
<p id="rfc.section.B.2.p.1">In this appendix we give an overview of the different types of properties, the objects to which they apply, and at what time an application can query them.</p>
<p id="rfc.section.B.2.p.2">During the Pre-Establishment phase, an application may specify Transport Parameters for a Connection as described in <a href="#transport-params" class="xref">Section 5.2</a>.  Specifically, Protocol Selection Properties, Path Selection Properties, and Application Intents for the Connection MUST be specified during Pre-Establishment, as protocol and path selection occur during connection establishment. An application may query the Transport Parameters that were specified for a Connection at all times.</p>
<p id="rfc.section.B.2.p.3">Transport Features represent the actual capabilities of specific Protocol Stacks. They are expressed in the same vocabulary as Protocol Selection Properties, but have a Boolean value expressing whether a Protocol Stack support the given Transport Feature or not. An application may query the Transport Features of Protocol Stacks at all times. Once a Connection is established, an application may query the Transport Features of the actually chosen protocols, the Protocol Stack Instances, for this Connection.</p>
<p id="rfc.section.B.2.p.4">Note that it is possible that the Protocol Stack Instances actually chosen by the transport system do not fully reflect the Transport Parameters that were originally set. For example, a certain Protocol Selection Property that an application specified as Preferred may not actually be present in the chosen Protocol Stack Instances because none of the currently available transport protocols had this feature.</p>
<p id="rfc.section.B.2.p.5">Protocol Stacks and Protocol Stack Instances also have Protocol Properties, which represent the specific configuration of a transport protocol. Their default values can be queried at all times, and an application can override these defaults for a specific Connection by specifying Protocol Properties either during pre-establishment or later in the lifetime of a Connection. This configuration is applied on the Protocol Stack Instance once it is bound to the Connection.</p>
<p id="rfc.section.B.2.p.6">Note that some Protocol Properties set during Pre-Establishment may not apply to the actually chosen protocol later, and consequently not be set in the resulting Protocol Stack Instance. However, it is beneficial for an application to set these properties as early as possible, so the transport system can use them to optimize.</p>
<p id="rfc.section.B.2.p.7">Finally, an application may query the properties of the available paths and the properties of the path(s) chosen for a Connection at all times.</p>
<p id="rfc.section.B.2.p.8">An application may also specify Send Properties per individual Content, as specified in <a href="#send-params" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.B.2.p.9">The following table shows the types of existing properties and what an application can do with them during what phase:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Property Type</th>
<th class="left">Applies to</th>
<th class="left">Pre-Establishment</th>
<th class="left">Established</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Transport Parameters</td>
<td class="left">Connection</td>
<td class="left">Set, Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Features</td>
<td class="left">ProtocolStack, ProtocolStackInstance</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Property defaults</td>
<td class="left">ProtocolStack</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Properties</td>
<td class="left">ProtocolStackInstance</td>
<td class="left">Set</td>
<td class="left">Set, Query</td>
</tr>
<tr>
<td class="left">Path Properties</td>
<td class="left">Path</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Send Properties</td>
<td class="left">Content</td>
<td class="left">Set</td>
<td class="left">Set</td>
</tr>
</tbody>
</table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael Welzl</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Welzl</span>
	  </span>
	</span>
	<span class="org vcardline">University of Oslo</span>
	<span class="adr">
	  <span class="vcardline">PO Box 1080 Blindern</span>

	  <span class="vcardline">
		<span class="locality">0316  Oslo</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Norway</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michawe@ifi.uio.no">michawe@ifi.uio.no</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Gorry Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
