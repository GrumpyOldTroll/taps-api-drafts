<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>An Abstract Application Layer Interface to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology and Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 Interface Design Principles">
<link href="#rfc.section.4" rel="Chapter" title="4 API Summary">
<link href="#rfc.section.5" rel="Chapter" title="5 Pre-Establishment Phase">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Specifying Endpoints">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Specifying Transport Parameters">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Transport Parameters Object">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Specifying Security Parameters and Callbacks">
<link href="#rfc.section.6" rel="Chapter" title="6 Establishing Connections">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Active Open: Initiate">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Passive Open: Listen">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Peer-to-Peer Establishment: Rendezvous">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Connection Groups">
<link href="#rfc.section.7" rel="Chapter" title="7 Sending Data">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Send Parameters">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Message Properties">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Sender-side Framing">
<link href="#rfc.section.8" rel="Chapter" title="8 Receiving Data">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Receiver-side De-framing over Stream Protocols">
<link href="#rfc.section.9" rel="Chapter" title="9 Setting and Querying of Connection Properties">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Protocol Properties">
<link href="#rfc.section.10" rel="Chapter" title="10 Connection Termination">
<link href="#rfc.section.11" rel="Chapter" title="11 Event and Error Handling">
<link href="#rfc.section.12" rel="Chapter" title="12 IANA Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 Security Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Additional Properties">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Protocol and Path Selection Properties">
<link href="#rfc.appendix.A.1.1" rel="Chapter" title="A.1.1 Application Intents">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Send Parameters">
<link href="#rfc.appendix.B" rel="Chapter" title="B Sample API definition in Go">
<link href="#rfc.appendix.C" rel="Chapter" title="C Transport Parameters">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Application Preferences">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Specifying and Querying Parameters">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Ed., Welzl, M., Ed., Enghardt, T., Fairhurst, G., Kuehlewind, M., Perkins, C., Tiesel, P., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-taps-interface-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-02-26" />
  <meta name="dct.abstract" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />
  <meta name="description" content="This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">M. Welzl, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 30, 2018</td>
<td class="right">University of Oslo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Enghardt</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Fairhurst</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">P. Tiesel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">TU Berlin</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 26, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">An Abstract Application Layer Interface to Transport Services<br />
  <span class="filename">draft-trammell-taps-interface-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes an abstract programming interface to the transport layer, following the Transport Services Architecture. It supports the asynchronous, atomic transmission of messages over transport protocols and network paths dynamically selected at runtime. It is intended to replace the traditional BSD sockets API as the lowest common denominator interface to the transport layer, in an environment where endpoints have multiple interfaces and potential transport protocols to select from.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 30, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology and Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">Interface Design Principles</a>
</li>
<li>4.   <a href="#rfc.section.4">API Summary</a>
</li>
<li>5.   <a href="#rfc.section.5">Pre-Establishment Phase</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Specifying Endpoints</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Specifying Transport Parameters</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Transport Parameters Object</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Specifying Security Parameters and Callbacks</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Establishing Connections</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Active Open: Initiate</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Passive Open: Listen</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Peer-to-Peer Establishment: Rendezvous</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Connection Groups</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Sending Data</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Send Parameters</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Message Properties</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Sender-side Framing</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Receiving Data</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Receiver-side De-framing over Stream Protocols</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Setting and Querying of Connection Properties</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Protocol Properties</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Connection Termination</a>
</li>
<li>11.   <a href="#rfc.section.11">Event and Error Handling</a>
</li>
<li>12.   <a href="#rfc.section.12">IANA Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">Security Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Acknowledgements</a>
</li>
<li>15.   <a href="#rfc.references">References</a>
</li>
<ul><li>15.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Additional Properties</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Protocol and Path Selection Properties</a>
</li>
<ul><li>A.1.1.   <a href="#rfc.appendix.A.1.1">Application Intents</a>
</li>
</ul><li>A.2.   <a href="#rfc.appendix.A.2">Send Parameters</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Sample API definition in Go</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Transport Parameters</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Application Preferences</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Specifying and Querying Parameters</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design principles of a new approach, which we outline in <a href="#principles" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.3">As a first step to realizing this design, <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a> describes a high-level architecture for transport services. This document builds a modern abstract programming interface atop this architecture, deriving specific path and protocol selection properties and supported transport features from the analysis provided in <a href="#RFC8095" class="xref">[RFC8095]</a> and <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology-and-notation" id="terminology-and-notation">Terminology and Notation</a>
</h1>
<p id="rfc.section.2.p.1">This API is described in terms of Objects, which an application can interact with; Actions the application can perform on these objects; Events, which an object can send to an application asynchronously; and Parameters associated with these Actions and Events.</p>
<p id="rfc.section.2.p.2">The following notations, which can be combined, are used in this document:</p>
<p></p>

<ul><li>Object := Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action creates an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object.Action()</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action is performed on an Object.</li></ul></li></ul>
<p></p>

<ul><li>Object -&gt; Event&lt;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Object sends an Event.</li></ul></li></ul>
<p></p>

<ul><li>Action(parameter, parameter, &#8230;) / Event&lt;parameter, parameter, &#8230;&gt;</li></ul>
<p></p>

<ul class="empty"><li><ul class="empty"><li>An Action takes a set of Parameters; an Event contains a set of Parameters.</li></ul></li></ul>
<p id="rfc.section.2.p.11">Actions associated with no object are Actions on the abstract interface itself; they are equivalent to actions on a per-application global context.</p>
<p id="rfc.section.2.p.12">How these abstract concepts map into concrete implementations of this API in a given language on a given platform is largely dependent on the features of the language and the platform. Actions could be implemented as functions or method calls, for instance, and Events could be implemented via callback passing or other asynchronous calling conventions.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#principles" id="principles">Interface Design Principles</a>
</h1>
<p id="rfc.section.3.p.1">We begin with the architectural design principles defined in <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>; from these, we derive and elaborate a set of principles on which the design of the interface is based. The interface defined in this document provides:</p>
<p></p>

<ul>
<li>A single interface to a variety of transport protocols to be used in a variety of application design patterns, independent of the properties of the application and the protocol stacks that will be used at runtime, such that  all common specialized features of these protocol stacks are made available to the application as necessary in a transport-independent way, to enable applications written to a single API to make use of transport protocols in terms of the features they provide;</li>
<li>Explicit support for security properties as first-order transport features, and for long-term caching of cryptographic identities and parameters for associations among endpoints;</li>
<li>Asynchronous connection establishment, transmission, and reception, allowing most application interactions with the transport layer to be event-driven, in line with developments in modern platforms and programming languages;</li>
<li>Explicit support for multistreaming and multipath transport protocols, and the grouping of related connections into connection groups through cloning of connections, to allow applications to take full advantage of new transport protocols supporting these features; and</li>
<li>Atomic transmission of data, using application-assisted framing and deframing where the underlying transport does not provide these.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#api-summary" id="api-summary">API Summary</a>
</h1>
<p id="rfc.section.4.p.1">[EDITOR&#8217;S NOTE: write three paragraph summary here; see https://github.com/taps-api/drafts/issues/93]</p>
<p id="rfc.section.4.p.2">In the following sections, we describe the details of application interaction with Objects through Actions and Events in each phase of a connection, following the phases described in <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#pre-establishment-phase" id="pre-establishment-phase">Pre-Establishment Phase</a>
</h1>
<p id="rfc.section.5.p.1">The pre-establishment phase allows applications to specify parameters for the connections they&#8217;re about to make, or to query the API about potential connections they could make.</p>
<p id="rfc.section.5.p.2">A Preconnection object represents a potential connection. It has state that describes parameters of a Connection that might exist in the future.  This state comprises Local Endpoint and Remote Endpoint objects that denote the endpoints of the potential connection (see <a href="#endpointspec" class="xref">Section 5.1</a>), the transport parameters (see <a href="#transport-params" class="xref">Section 5.2</a>), and the security parameters (see <a href="#security-parameters" class="xref">Section 5.3</a>):</p>
<pre>
   preConnection := NewPreconnection(LocalEndpoint,
                                     RemoteEndpoint,
                                     TransportParams,
                                     SecurityParams);

</pre>
<p id="rfc.section.5.p.3">The Local Endpoint MUST be specified if the Preconnection is used to Listen() for incoming connections, but is OPTIONAL if it is used to Initiate() connections. The Remote Endpoint MUST be specified in the Preconnection is used to Initiate() connections, but is OPTIONAL if it is used to Listen() for incoming connections.</p>
<p id="rfc.section.5.p.4">Framers (see <a href="#send-framing" class="xref">Section 7.2</a>) and deframers (see <a href="#receive-framing" class="xref">Section 8.1</a>), if necessary, should be bound to the Preconnection during pre-establishment.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#endpointspec" id="endpointspec">Specifying Endpoints</a>
</h1>
<p id="rfc.section.5.1.p.1">The transport services API uses the Local Endpoint and Remote Endpoint types to refer to the endpoints of a transport connection.  Subtypes of these represent various different types of endpoint identifiers, such as IP addresses, DNS names, and interface names, as well as port numbers and service names.</p>
<pre>
remoteSpecifier := NewRemoteEndpoint()
remoteSpecifier.withHostname("example.com")
remoteSpecifier.withService("https")
</pre>
<pre>
remoteSpecifier := NewRemoteEndpoint()
remoteSpecifier.withIPv6Address(2001:db8:4920:e29d:a420:7461:7073:0a)
remoteSpecifier.withPort(443)
</pre>
<pre>
remoteSpecifier := NewRemoteEndpoint()
remoteSpecifier.withIPv4Address(192.0.2.21)
remoteSpecifier.withPort(443)
</pre>
<pre>
localSpecifier := NewLocalEndpoint()
localSpecifier.withInterface("en0")
localSpecifier.withPort(443)
</pre>
<pre>
localSpecifier := NewLocalEndpoint()
localSpecifier.withStunServer(address, port, credentials)
</pre>
<p id="rfc.section.5.1.p.2">Implementations may also support additional endpoint representations and provide a single NewEndpoint() call that takes different endpoint representations.</p>
<p id="rfc.section.5.1.p.3">Multiple endpoint identifiers can be specified for each Local Endpoint and RemoteEndoint.  For example, a Local Endpoint could be configured with two interface names, or a Remote Endpoint could be specified via both IPv4 and IPv6 addresses.  The multiple identifiers refer to the same endpoint.</p>
<p id="rfc.section.5.1.p.4">The transport services API will resolve names internally, when the Initiate(), Listen(), or Rendezvous() method is called establish a connection.  The API does not need the application to resolve names, and premature name resolution can damage performance by limiting the scope for alternate path discovery during connection establishment.  The Resolve() method is, however, provided to resolve a Local Endpoint or a Remote Endpoint in cases where this is required, for example with some NAT traversal protocols (see <a href="#rendezvous" class="xref">Section 6.3</a>).</p>
<p id="rfc.section.5.1.p.5">[NOTE: the API needs MUST be explicit about when name resolution occurs, since the act of resolving a name leaks information, and there may be security implications if this happens unexpectedly.]</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#transport-params" id="transport-params">Specifying Transport Parameters</a>
</h1>
<p id="rfc.section.5.2.p.1">A Preconnection object holds parameters reflecting the application&#8217;s requirements and preferences for the transport. These include protocol and path selection parameters, as well as Generic and Specific Protocol Properties for configuration of the detailed operation of the selected Protocol Stacks.</p>
<p id="rfc.section.5.2.p.2">All Transport Parameters are organized within a single namespace shared with Send Parameters (see <a href="#send-params" class="xref">Section 7.1</a>). All transport parameters take paremeter-specific values. Protocol and Path Selection properties additionally take one of five preference levels, though not all preference levels make sense with all such properties. Note that it is possible for a set of specified transport parameters to be internally inconsistent, or for preferences to be inconsistent with the later use of the API by the application. Application developers should reduce inconsistency by only using the most stringent preference levels when failure to meet a preference would break the application&#8217;s functionality (e.g.  the Reliable Data Transfer preference, which is a core assumption of many application protocols). Implementations of this interface should also raise errors in configuration as early as possible, to help ensure these inconsistencies are caught early in the development process.</p>
<p id="rfc.section.5.2.p.3">The protocol(s) and path(s) selected as candidates during connection establishment are determined by a set of properties. Since there could be paths over which some transport protocols are unable to operate, or remote endpoints that support only specific network addresses or transports, transport protocol selection is necessarily tied to path selection. This may involve choosing between multiple local interfaces that are connected to different access networks.</p>
<p id="rfc.section.5.2.p.4">To reflect the needs of an individual connection, they can be specified with five different preference levels:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Preference</th>
<th class="left">Effect</th>
</tr></thead>
<tbody>
<tr>
<td class="left"><samp>require </samp></td>
<td class="left">Select only protocols/paths providing the property, fail otherwise</td>
</tr>
<tr>
<td class="left"><samp>prefer  </samp></td>
<td class="left">Prefer protocols/paths providing the property, proceed otherwise</td>
</tr>
<tr>
<td class="left"><samp>ignore  </samp></td>
<td class="left">Cancel any default preference for this property</td>
</tr>
<tr>
<td class="left"><samp>avoid   </samp></td>
<td class="left">Prefer protocols/paths not providing the property, proceed otherwise</td>
</tr>
<tr>
<td class="left"><samp>prohibit</samp></td>
<td class="left">Select only protocols/paths not providing the property, fail otherwise</td>
</tr>
</tbody>
</table>
<p id="rfc.section.5.2.p.5">An implementation of this interface must provide sensible defaults for protocol and path selection properties. The defaults given for each property below represent a configuration that can be implemented over TCP. An alternate set of default Protocol Selection Properties would represent a configuration that can be implemented over UDP.</p>
<p id="rfc.section.5.2.p.6">The following properties can be used during Protocol and Path selection:</p>
<p></p>

<ul>
<li>Reliable Data Transfer: This boolean property specifies whether the application needs the transport protocol to ensure that data is received completely and without corruption on the other side. This also entails being notified when a Connection is closed or aborted. This property applies to connections and connection groups.  This is a strict requirement. The default is to enable Reliable Data Transfer.</li>
<li>Preservation of data ordering: This boolean property specifies whether the application needs the transport protocol to assure that data is received by the application on the other end in the same order as it was sent. This property applies to connections and connection groups. This is a strict requirement. The default is to preserve data ordering.</li>
<li>Configure reliability on a per-Message basis: This boolean property specifies whether an application considers it useful to indicate its reliability requirements on a per-Message basis.  This property applies to connections and connection groups. This is not a strict requirement.  The default is to not have this option.</li>
<li>Use 0-RTT session establishment with an idempotent Message: This boolean property specifies whether an application would like to supply a Message to the transport protocol before Connection establishment, which will then be reliably transferred to the other side before or during connection establishment, potentially multiple times.  See also <a href="#send-idempotent" class="xref">Section 7.1.1.4</a>.  This is a strict requirement. The default is to not have this option.</li>
<li>Efficient use of Connection Groups: This boolean property specifies whether an application considers it useful to create Connection Groups, e.g. to explicitly prioritize between Connections within a Connection Group. This property will tend to select multistreaming transport protocols, which can multiplex Connections into a Connection Group over a single flow. This is not a strict requirement. The default is to not have this option.</li>
<li>Suggest a timeout to the Remote Endpoint: This boolean property specifies whether an application considers it useful to propose a timeout until the connection is assumed to be lost.  This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</li>
<li>Notification of special errors (excessive retransmissions, ICMP error message arrival): This boolean property specifies whether an application considers it useful to be informed in case sent data was retransmitted more often than a certain threshold, or when an ICMP error message arrives. This property applies to Connections and Connection Groups. This is not a strict requirement. The default is to have this option.</li>
<li>Control checksum coverage on sending or receiving: This boolean property specifies whether the application considers it useful to enable / disable / configure a checksum when sending data, or decide whether to require a checksum or not when receiving data.  This property applies to Connections and Connection Groups. This is not a strict requirement, as it signifies a reduction in reliability. The default is full checksum coverage without being able to change it, and requiring a checksum when receiving.</li>
<li>Interface Type: This enumerated property specifies which kind of access network interface, e.g., WiFi, Ethernet, or LTE, to prefer over others for this connection, in case they are available. In general, Interface Types should be used only with the <samp>prefer</samp> and <samp>prohibit</samp> preference level. Specifically, using the <samp>require</samp> preference level for Interface Type may limit path selection in a way that is detrimental to connectivity. The default is to use the default interface configured in the system policy.</li>
<li>Capacity Profile: This enumerated property specifies the application&#8217;s expectation of the dominating traffic pattern for this connection. The Capacity Profile should only be used with the <samp>prefer</samp> preference level; other preference levels make no sense for profiles. The following values are valid for Capacity Profile:  <dl>
<dt>Default:</dt>
<dd style="margin-left: 8">The application makes no representation about its expected capacity profile. No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when selecting and configuring stacks.</dd>
<dt>Interactive/Low Latency:</dt>
<dd style="margin-left: 8">The application is interactive. Response time (latency) should be optimized at the expense of bandwidth efficiency and delay variation. This can be used by the system to disable the coalescing of multiple small Messages into larger packets (Nagle&#8217;s algorithm), to prefer lower-latency paths, signal a preference for lower-latency, higher-loss treatment, and so on.</dd>
<dt>Constant Rate:</dt>
<dd style="margin-left: 8">The application expects to send/receive data at a constant rate after connection establishment. Delay and delay variation should be optimized at the expense of bandwidth efficiency.</dd>
<dt>Scavenger/Bulk:</dt>
<dd style="margin-left: 8">The application is not interactive. It expects to send/receive a large amount of data, without any urgency. This can be used to select protocol stacks with scavenger transmission control, to signal a preference for less-than-best-effort treatment, and so on.</dd>
</dl>
</li>
</ul>
<p id="rfc.section.5.2.p.8">In addition to protocol and path selection properties, the transport parameters may also contain Generic and/or Specific Protocol Properties (see <a href="#protocol-props" class="xref">Section 9.1</a>). These properties will be passed to the selected candidate Protocol Stack(s) to configure them before candidate connection establishment.</p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#transport-parameters-object" id="transport-parameters-object">Transport Parameters Object</a>
</h1>
<p id="rfc.section.5.2.1.p.1">All transport parameters used in the pre-establishment phase are collected in a TransportParameters object that is passed to the Preconnection object.</p>
<pre>
transportParameters := NewTransportParameters()
</pre>
<p id="rfc.section.5.2.1.p.2">The Individual parameters are then added to the TransportParameters object.  While Protocol Properties and Application Intents use the <samp>add</samp> call, Transport Preferences use special calls for the levels defined in <a href="#transport-params" class="xref">Section 5.2</a>.</p>
<pre>
transportParameters.add(parameter, value)

transportParameters.require(preference)
transportParameters.prefer(preference)
transportParameters.ignore(preference)
transportParameters.avoid(preference)
transportParameters.prohibit(preference)
</pre>
<p id="rfc.section.5.2.1.p.3">For an existing connection, the Transport Parameters can be queried any time by using the following call on the Connection object:</p>
<pre>
transportParameters := connection.getTransportParameters()
</pre>
<p id="rfc.section.5.2.1.p.4">Note that most properties are only considered for connection establishment and can not be changed later on. <a href="#appendix-specify-query-params" class="xref">Appendix C.2</a> gives an overview of what Transport Parameters can be specified and queried during which phase.</p>
<p id="rfc.section.5.2.1.p.5">A Connection gets its Transport Parameters either by being explicitly configured via a Preconnection, or by inheriting them from an antecedent via cloning; see <a href="#groups" class="xref">Section 6.4</a> for more.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#security-parameters" id="security-parameters">Specifying Security Parameters and Callbacks</a>
</h1>
<p id="rfc.section.5.3.p.1">Common parameters such as TLS ciphersuites are known to implementations. Clients SHOULD use common safe defaults for these values whenever possible. However, as discussed in <a href="#I-D.pauly-taps-transport-security" class="xref">[I-D.pauly-taps-transport-security]</a>, many transport security protocols require specific security parameters and constraints from the client at the time of configuration and actively during a handshake. These configuration parameters are created as follows</p>
<pre>
securityParameters := NewSecurityParameters()
</pre>
<p id="rfc.section.5.3.p.2">Security configuration parameters and sample usage follow:</p>
<p></p>

<ul><li>Local identity and private keys: Used to perform private key operations and prove one&#8217;s identity to the Remote Endpoint. (Note, if private keys are not available, e.g., since they are stored in HSMs, handshake callbacks MUST be used. See below for details.)</li></ul>
<pre>
securityParameters.AddIdentity(identity)
securityParameters.AddPrivateKey(privateKey, publicKey)
</pre>
<p></p>

<ul><li>Supported algorithms: Used to restrict what parameters are used by underlying transport security protocols.  When not specified, these algorithms SHOULD default to known and safe defaults for the system. Parameters include: ciphersuites, supported groups, and signature algorithms.</li></ul>
<pre>
securityParameters.AddSupportedGroup(22)    // secp256k1
securityParameters.AddCiphersuite(0xCCA9)   // TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
securityParameters.AddSignatureAlgorithm(7) // ed25519
</pre>
<p></p>

<ul><li>Session cache: Used to tune cache capacity, lifetime, re-use, and eviction policies, e.g., LRU or FIFO.</li></ul>
<pre>
securityParameters.SetSessionCacheCapacity(1024)     // 1024 elements
securityParameters.SetSessionCacheLifetime(24*60*60) // 24 hours
securityParameters.SetSessionCacheReuse(1)           // One-time use
</pre>
<p></p>

<ul><li>Pre-shared keying material: Used to install pre-shared keying material established out-of-band. Each pre-shared keying material is associated with some identity that typically identifies its use or has some protocol-specific meaning to the Remote Endpoint.</li></ul>
<pre>
securityParameters.AddPreSharedKey(key, identity)
</pre>
<p id="rfc.section.5.3.p.7">Security decisions, especially pertaining to trust, are not static. Thus, once configured, parameters must also be supplied during live handshakes. These are best handled as client-provided callbacks. Security handshake callbacks include:</p>
<p></p>

<ul><li>Trust verification callback: Invoked when a Remote Endpoint&#8217;s trust must be validated before the handshake protocol can proceed.</li></ul>
<pre>
trustCallback := NewCallback({
  // Handle trust, return the result
})
securityParameters.SetTrustVerificationCallback(trustCallback)
</pre>
<p></p>

<ul><li>Identity challenge callback: Invoked when a private key operation is required, e.g., when local authentication is requested by a remote.</li></ul>
<pre>
challengeCallback := NewCallback({
  // Handle challenge
})
securityParameters.SetIdentityChallengeCallback(challengeCallback)
</pre>
<p id="rfc.section.5.3.p.10">Like transport parameters, security parameters are inherited during cloning (see <a href="#groups" class="xref">Section 6.4</a>).</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#establishing-connections" id="establishing-connections">Establishing Connections</a>
</h1>
<p id="rfc.section.6.p.1">Before a Connection can be used for data transfer, it must be established.  Establishment ends the pre-establishment phase; all transport and cryptographic parameter specification must be complete before establishment, as these parameters will be used to select candidate Paths and Protocol Stacks for the Connection. Establishment may be active, using the Initiate() Action; passive, using the Listen() Action; or simultaneous for peer-to-peer, using the Rendezvous() Action. These Actions are described in the subsections below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#initiate" id="initiate">Active Open: Initiate</a>
</h1>
<p id="rfc.section.6.1.p.1">Active open is the action of establishing a connection to a Remote Endpoint presumed to be listening for incoming connection requests. Active open is used by clients in client-server interactions. Active open is supported by this interface through the Initiate action:</p>
<pre>
Connection := Preconnection.Initiate()
</pre>
<p id="rfc.section.6.1.p.2">Before calling Initiate, the caller must have populated a Preconnection object with a Remote Endpoint specifier, optionally a Local Endpoint specifier (if not specified, the system will attempt to determine a suitable Local Endpoint), as well as all parameters necessary for candidate selection. After calling Initiate, no further parameters may be bound to the Connection. The Initiate() call consumes the Preconnection and creates a Connection object. A Preconnection can only be initiated once.</p>
<p id="rfc.section.6.1.p.3">Once Initiate is called, the candidate Protocol Stack(s) may cause one or more candidate transport-layer connections to be created to the specified remote endpoint. The caller may immediately begin sending Messages on the Connection (see <a href="#sending" class="xref">Section 7</a>) after calling Initate(); note that any idempotent data sent while the Connection is being established may be sent multiple times or on multiple candidates.</p>
<p id="rfc.section.6.1.p.4">The following events may be sent by the Connection after Initiate() is called:</p>
<pre>
Connection -&gt; Ready&amp;lt;&gt;
</pre>
<p id="rfc.section.6.1.p.5">The Ready event occurs after Initiate has established a transport-layer connection on at least one usable candidate Protocol Stack over at least one candidate Path. No Receive events (see <a href="#receiving" class="xref">Section 8</a>) will occur before the Ready event for connections established using Initiate.</p>
<pre>
Connection -&gt; InitiateError&amp;lt;&gt;
</pre>
<p id="rfc.section.6.1.p.6">An InitiateError occurs either when the set of transport and cryptographic parameters cannot be fulfilled on a connection for initiation (e.g. the set of available Paths and/or Protocol Stacks meeting the constraints is empty) or reconciled with the local and/or remote endpoints; when the remote specifier cannot be resolved; or when no transport-layer connection can be established to the remote endpoint (e.g. because the remote endpoint is not accepting connections, or the application is prohibited from opening a connection by the operating system).</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#listen" id="listen">Passive Open: Listen</a>
</h1>
<p id="rfc.section.6.2.p.1">Passive open is the action of waiting for connections from remote endpoints, commonly used by servers in client-server interactions. Passive open is supported by this interface through the Listen action:</p>
<pre>
Preconnection.Listen()
</pre>
<p id="rfc.section.6.2.p.2">Before calling Listen, the caller must have initialized the Preconnection during the pre-establishment phase with a Local Endpoint specifier, as well as all parameters necessary for Protocol Stack selection. A Remote Endpoint may optionally be specified, to constrain what connections are accepted.  The Listen() action consumes the Preconnection. Once Listen() has been called, no further parameters may be bound to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<pre>
Preconnection -&gt; ConnectionReceived&amp;lt;Connection&gt;
</pre>
<p id="rfc.section.6.2.p.3">The ConnectionReceived event occurs when a Remote Endpoint has established a transport-layer connection to this Preconnection (for connection-oriented transport protocols), or when the first Message has been received from the Remote Endpoint (for connectionless protocols), causing a new Connection to be created. The resulting Connection is contained within the ConnectionReceived event, and is ready to use as soon as it is passed to the application via the event.</p>
<pre>
Preconnection -&gt; ListenError&amp;lt;&gt;
</pre>
<p id="rfc.section.6.2.p.4">A ListenError occurs either when the Preconnection cannot be fulfilled for listening, when the Local Endpoint (or Remote Endpoint, if specified) cannot be resolved, or when the application is prohibited from listening by policy.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#rendezvous" id="rendezvous">Peer-to-Peer Establishment: Rendezvous</a>
</h1>
<p id="rfc.section.6.3.p.1">Simultaneous peer-to-peer connection establishment is supported by the Rendezvous() action:</p>
<pre>
Preconnection.Rendezvous()
</pre>
<p id="rfc.section.6.3.p.2">The Preconnection object must be specified with both a Local Endpoint and a Remote Endpoint, and also the transport and security parameters needed for protocol stack selection. The Rendezvous() action causes the Preconnection to listen on the Local Endpoint for an incoming connection from the Remote Endpoint, while simultaneously trying to establish a connection from the Local Endpoint to the Remote Endpoint.  This corresponds to a TCP simultaneous open, for example.</p>
<p id="rfc.section.6.3.p.3">The Rendezvous() action consumes the Preconnection. Once Rendezvous() has been called, no further parameters may be bound to the Preconnection, and no subsequent establishment call may be made on the Preconnection.</p>
<pre>
Preconnection -&gt; RendezvousDone&amp;lt;Connection&gt;
</pre>
<p id="rfc.section.6.3.p.4">The RendezvousDone&lt;&gt; event occurs when a connection is established with the Remote Endpoint. For connection-oriented transports, this occurs when the transport-layer connection is established; for connectionless transports, it occurs when the first Message is received from the Remote Endpoint. The resulting Connection is contained within the RendezvousDone&lt;&gt; event, and is ready to use as soon as it is passed to the application via the event.</p>
<pre>
Preconnection -&gt; RendezvousError&amp;lt;msgRef, error&gt;
</pre>
<p id="rfc.section.6.3.p.5">An RendezvousError occurs either when the Preconnection cannot be fulfilled for listening, when the Local Endpoint or Remote Endpoint cannot be resolved, when no transport-layer connection can be established to the Remote Endpoint, or when the application is prohibited from rendezvous by policy.</p>
<p id="rfc.section.6.3.p.6">When using some NAT traversal protocols, e.g., ICE <a href="#RFC5245" class="xref">[RFC5245]</a>, it is expected that the Local Endpoint will be configured with some method of discovering NAT bindings, e.g., a STUN server. In this case, the Local Endpoint may resolve to a mixture of local and server reflexive addresses. The Resolve() method on the Preconnection can be used to discover these bindings:</p>
<pre>
PreconnectionBindings := Preconnection.Resolve()
</pre>
<p id="rfc.section.6.3.p.7">The Resolve() call returns a list of Preconnection objects, that represent the concrete addresses, local and server reflexive, on which a Rendezvous() for the Preconnection will listen for incoming connections. This list can be passed to a peer via a signalling protocol, such as SIP or WebRTC, to configure the remote.</p>
<p id="rfc.section.6.3.p.8">[NOTE: This API is sufficient for TCP-style simultaneous open, but should be considered experimental for ICE-like protocols.]</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#groups" id="groups">Connection Groups</a>
</h1>
<p id="rfc.section.6.4.p.1">Groups of Connections can be created using Clone action:</p>
<pre>
Connection := Connection.Clone()
</pre>
<p id="rfc.section.6.4.p.2">Calling this once yields a group of two Connections: the parent Connection &#8211; whose Clone action was called &#8211; and the resulting clone. Calling Clone on any of these two Connections adds a third Connection to the group, and so on.  All Connections in a group are entangled. This means that they automatically share all properties: changing a parameter for one of them also changes the parameter for all others.</p>
<p id="rfc.section.6.4.p.3">There is only one Protocol Property that is not entangled, i.e., it is a separate per-Connection Property for individual Connections in the group: a priority.  This priority, which can be represented as a non-negative integer or float, expresses a desired share of the Connection Group&#8217;s available network capacity, such that an ideal transport system implementation would assign the Connection the capacity share P x C/sum_P, where P = priority, C = total available capacity and sum_P = sum of all priority values that are used for the Connections in the same Connection Group.  The priority setting is purely advisory; no guarantees are given.</p>
<p id="rfc.section.6.4.p.4">Connection Groups should be created by cloning as as early as possible in order to aid the Transport System in choosing and configuring the right protocols (see also <a href="#transport-params" class="xref">Section 5.2</a>).</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sending" id="sending">Sending Data</a>
</h1>
<p id="rfc.section.7.p.1">Once a Connection has been established, it can be used for sending data. Data is sent by passing a Message object and additional parameters <a href="#send-params" class="xref">Section 7.1</a> to the Send action on an established connection:</p>
<pre>
Connection.Send(Message, sendParameters)
</pre>
<p id="rfc.section.7.p.2">The type of the Message to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. It may itself contain an array of octets to be transmitted in the transport protocol payload, or be transformable to an array of octets by a sender-side framer (see <a href="#send-framing" class="xref">Section 7.2</a>).</p>
<p id="rfc.section.7.p.3">Messages may be arbitrarily large; however, there may be system and Protocol Stack dependent limits on the size of a data object which can be transmitted atomically. For that reason, the Message object passed to the Send action may also be a partial Message, either representing the whole data object and information about the range of bytes to send from it, or an object referring back to the larger whole Message. The details of partial Message sending are implementation-dependent.</p>
<p id="rfc.section.7.p.4">If Send is called on a Connection which has not yet been established, an Initiate action will be implicitly performed simultaneously with the Send.  Used together with the Idempotent property (see <a href="#send-idempotent" class="xref">Section 7.1.1.4</a>), this can be used to send data during establishment for 0-RTT session resumption on Protocol Stacks that support it.</p>
<p id="rfc.section.7.p.5">Like all Actions in this interface, the Send action is asynchronous.</p>
<pre>
Connection -&gt; Sent&amp;lt;msgRef&gt;
</pre>
<p id="rfc.section.7.p.6">The Sent event occurs when a previous Send action has completed, i.e., when the data derived from the Message has been passed down or through the underlying Protocol Stack and is no longer the responsibility of the implementation of this interface. The exact disposition of the Message when the Sent event occurs is specific to the implementation and the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Sent event contains an implementation-specific reference to the Message to which it applies.</p>
<p id="rfc.section.7.p.7">Sent events allow an application to obtain an understanding of the amount of buffering it creates. That is, if an application calls the Send action multiple times without waiting for a Sent event, it has created more buffer inside the transport system than an application that only issues a Send after this event fires.</p>
<pre>
Connection -&gt; Expired&amp;lt;msgRef&gt;
</pre>
<p id="rfc.section.7.p.8">The Expired event occurs when a previous Send action expired before completion; i.e. when the Message was not sent before its Lifetime (see <a href="#send-lifetime" class="xref">Section 7.1.1.1</a>) expired. This is separate from SendError, as it is an expected behavior for partially reliable transports. The Expired event contains an implementation-specific reference to the Message to which it applies.</p>
<pre>
Connection -&gt; SendError&amp;lt;msgRef&gt;
</pre>
<p id="rfc.section.7.p.9">A SendError occurs when a Message could not be sent due to an error condition: an attempt to send a non-partial Message which is too large for the system and Protocol Stack to handle, some failure of the underlying Protocol Stack, or a set of send parameters not consistent with the Connection&#8217;s transport parameters. The SendError contains an implementation-specific reference to the Message to which it applies.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#send-params" id="send-params">Send Parameters</a>
</h1>
<p id="rfc.section.7.1.p.1">The Send action takes per-Message send parameters which control how the contents will be sent down to the underlying Protocol Stack and transmitted.</p>
<p id="rfc.section.7.1.p.2">If Send Parameters should be overridden for a specific Message, an empty sent parameter Object can be acquired and all desired Send Parameters can be added to that object. A sendParameters object can be reused for sending multiple contents with the same properties.</p>
<pre>
sendParameters := NewSendParameters()
sendParameters.add(parameter, value)
</pre>
<p id="rfc.section.7.1.p.3">The Send Parameters are organized in <em>Message Properties</em> and <em>Application Intents</em>.  The Send Parameters share a single namespace with the Transport Parameters (see <a href="#transport-params" class="xref">Section 5.2</a>). This allows to specify Protocol Properties and that can be overridden on a per-Message basis or Application Intents that apply to a specific Message.  See <a href="#appendix-specify-query-params" class="xref">Appendix C.2</a> for an overview.</p>
<p id="rfc.section.7.1.p.4">Send Parameters may be inconsistent with the properties of the Protocol Stacks underlying the Connection on which a given Message is sent. For example, infinite Lifetime is not possible on a Message over a Connection not providing reliability. Sending a Message with Send Properties inconsistent with the Transport Preferences on the connection yields an error.</p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#message-properties" id="message-properties">Message Properties</a>
</h1>
<h1 id="rfc.section.7.1.1.1">
<a href="#rfc.section.7.1.1.1">7.1.1.1.</a> <a href="#send-lifetime" id="send-lifetime">Lifetime</a>
</h1>
<p id="rfc.section.7.1.1.1.p.1">Lifetime specifies how long a particular Message can wait to be sent to the remote endpoint before it is irrelevant and no longer needs to be (re-)transmitted. When a Message&#8217;s Lifetime is infinite, it must be transmitted reliably. The type and units of Lifetime are implementation-specific.</p>
<h1 id="rfc.section.7.1.1.2">
<a href="#rfc.section.7.1.1.2">7.1.1.2.</a> <a href="#send-niceness" id="send-niceness">Niceness</a>
</h1>
<p id="rfc.section.7.1.1.2.p.1">Niceness represents an unbounded hierarchy of priorities of Messages, relative to other Messages sent over the same Connection and/or Connection Group (see <a href="#groups" class="xref">Section 6.4</a>). It is most naturally represented as a non-negative integer.  A Message with Niceness 0 will yield to a Message with Niceness 1, which will yield to a Message with Niceness 2, and so on. Niceness may be used as a sender-side scheduling construct only, or be used to specify priorities on the wire for Protocol Stacks supporting prioritization.</p>
<p id="rfc.section.7.1.1.2.p.2">Note that this inversion of normal schemes for expressing priority has a convenient property: priority increases as both Niceness and Lifetime decrease.</p>
<h1 id="rfc.section.7.1.1.3">
<a href="#rfc.section.7.1.1.3">7.1.1.3.</a> <a href="#send-ordered" id="send-ordered">Ordered</a>
</h1>
<p id="rfc.section.7.1.1.3.p.1">Ordered is a boolean property. If true, this Message should be delivered after the last Message passed to the same Connection via the Send action; if false, this Message may be delivered out of order.</p>
<h1 id="rfc.section.7.1.1.4">
<a href="#rfc.section.7.1.1.4">7.1.1.4.</a> <a href="#send-idempotent" id="send-idempotent">Idempotent</a>
</h1>
<p id="rfc.section.7.1.1.4.p.1">Idempotent is a boolean property. If true, the application-layer entity in the Message is safe to send to the remote endpoint more than once for a single Send action. It is used to mark data safe for certain 0-RTT establishment techniques, where retransmission of the 0-RTT data may cause the remote application to receive the Message multiple times.</p>
<h1 id="rfc.section.7.1.1.5">
<a href="#rfc.section.7.1.1.5">7.1.1.5.</a> <a href="#send-checksum" id="send-checksum">Corruption Protection Length</a>
</h1>
<p id="rfc.section.7.1.1.5.p.1">This numeric property specifies the length of the section of the Message, starting from byte 0, that the application assumes will be received without corruption due to lower layer errors. It is used to specify options for simple integrity protection via checksums. By default, the entire Message is protected by checksum. A value of 0 means that no checksum is required, and a special value (e.g. -1) can be used to indicate the default. Only full coverage is guaranteed, any other requests are advisory.</p>
<h1 id="rfc.section.7.1.1.6">
<a href="#rfc.section.7.1.1.6">7.1.1.6.</a> <a href="#send-ackimmed" id="send-ackimmed">Immediate Acknowledgement</a>
</h1>
<p id="rfc.section.7.1.1.6.p.1">This boolean property specifies, if true, that an application wants this Message to be acknowledged immediately by the receiver. In case of reliable transmission, this informs the transport protocol on the sender side faster that it can remove the Message from its buffer; therefore this property can be useful for latency-critical applications that maintain tight control over the send buffer (see <a href="#sending" class="xref">Section 7</a>).</p>
<h1 id="rfc.section.7.1.1.7">
<a href="#rfc.section.7.1.1.7">7.1.1.7.</a> <a href="#instantaneous-capacity-profile" id="instantaneous-capacity-profile">Instantaneous Capacity Profile</a>
</h1>
<p id="rfc.section.7.1.1.7.p.1">This enumerated property specifies the application&#8217;s preferred tradeoffs for sending this Message; it is a per-Message override of the Capacity Profile protocol and path selection property (see <a href="#transport-params" class="xref">Section 5.2</a>).</p>
<p id="rfc.section.7.1.1.7.p.2">The following values are valid for Instantaneous Capacity Profile:</p>
<p></p>

<dl>
<dt>Default:</dt>
<dd style="margin-left: 8">No special optimizations of the tradeoff between delay, delay variation, and bandwidth efficiency should be made when sending this message.</dd>
<dt>Interactive/Low Latency:</dt>
<dd style="margin-left: 8">Response time (latency) should be optimized at the expense of bandwidth efficiency and delay variation when sending this message.  This can be used by the system to disable the coalescing of multiple small Messages into larger packets (Nagle&#8217;s algorithm), to signal a preference for lower-latency, higher-loss treatment, and so on.</dd>
<dt>Constant Rate:</dt>
<dd style="margin-left: 8">Delay and delay variation should be optimized at the expense of bandwidth efficiency.</dd>
<dt>Scavenger/Bulk:</dt>
<dd style="margin-left: 8">This Message may be sent at the system&#8217;s leisure. This can be used to signal a preference for less-than-best-effort treatment, to delay sending until lower-cost paths are available, and so on.</dd>
</dl>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#send-framing" id="send-framing">Sender-side Framing</a>
</h1>
<p id="rfc.section.7.2.p.1">Sender-side framing allows a caller to provide the interface with a function that takes a Message of an appropriate application-layer type and returns an array of octets, the on-the-wire representation of the Message to be handed down to the Protocol Stack. It consists of a Framer object with a single Action, Frame. Since the Framer depends on the protocol used at the application layer, it is bound to the Preconnection during the pre-establishment phase:</p>
<pre>
Preconnection.FrameWith(Framer)

OctetArray := Framer.Frame(Message)
</pre>
<p id="rfc.section.7.2.p.2">Sender-side framing is a convenience feature of the interface, for parity with receiver-side framing (see <a href="#receive-framing" class="xref">Section 8.1</a>).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#receiving" id="receiving">Receiving Data</a>
</h1>
<p id="rfc.section.8.p.1">Once a Connection is established, Messages may be received on it. The application can indicate that it is ready to receive Messages by calling Receive() on the connection.</p>
<pre>
Connection.Receive(ReceiveHandler)
</pre>
<p id="rfc.section.8.p.2">Receive takes a single object, a ReceiveHandler which can handle the Received event and the ReceiveError error. Each call to Receive will result in at most one Received event being sent to the handler, though implementations may provide convenience functions to indicate readiness to receive a larger but finite number of Messages with a single call. This allows an application to provide backpressure to the transport stack when it is temporarily not ready to receive messages.</p>
<pre>
Connection -&gt; Received&amp;lt;Message&gt;
</pre>
<p id="rfc.section.8.p.3">As with sending, the type of the Message to be passed is dependent on the implementation, and on the constraints on the Protocol Stacks implied by the Connection&#8217;s transport parameters. The Message may also contain metadata from protocols in the Protocol Stack; which metadata is available is Protocol Stack dependent. In particular, when this information is available, the value of the Explicit Congestion Notification (ECN) field is contained in such metadata.  This information can be used for logging and debugging purposes, and for building applications which need access to information about the transport internals for their own operation.</p>
<p id="rfc.section.8.p.4">The Message object must provide some method to retrieve an octet array containing application data, corresponding to a single message within the underlying Protocol Stack&#8217;s framing.  See <a href="#receive-framing" class="xref">Section 8.1</a> for handling framing in situations where the Protocol Stack provides octet-stream transport only.</p>
<p id="rfc.section.8.p.5">Note that as with sending, the Message object passed to Received may represent a partial message, larger than the maximum message size than can be received atomically. In this case, the Message object passed contains an indication that the object received is partial, a reference to the full Message it belongs to, as well as the byte range of the data content within the partial Message.</p>
<pre>
Connection -&gt; ReceiveError&amp;lt;&gt;
</pre>
<p id="rfc.section.8.p.6">A ReceiveError occurs when data is received by the underlying Protocol Stack that cannot be fully retrieved or deframed, or when some other indication is received that reception has failed. Such conditions that irrevocably lead the the termination of the Connection are signaled using ConnectionError instead (see <a href="#termination" class="xref">Section 10</a>).</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#receive-framing" id="receive-framing">Receiver-side De-framing over Stream Protocols</a>
</h1>
<p id="rfc.section.8.1.p.1">The Receive event is intended to be fired once per application-layer Message sent by the remote endpoint; i.e., it is a desired property of this interface that a Send at one end of a Connection maps to exactly one Receive on the other end. This is possible with Protocol Stacks that provide message boundary preservation, but is not the case over Protocol Stacks that provide a simple octet stream transport.</p>
<p id="rfc.section.8.1.p.2">For preserving message boundaries over stream transports, this interface provides receiver-side de-framing. This facility is based on the observation that, since many of our current application protocols evolved over TCP, which does not provide message boundary preservation, and since many of these protocols require message boundaries to function, each application layer protocol has defined its own framing. A Deframer allows an application to push this de-framing down into the interface, in order to transform an octet stream into a sequence of Messages.</p>
<p id="rfc.section.8.1.p.3">Concretely, receiver-side de-framing allows a caller to provide the interface with a function that takes an octet stream, as provided by the underlying Protocol Stack, reads and returns a single Message of an appropriate type for the application and platform, and leaves the octet stream at the start of the next Message to deframe. It consists of a Deframer object with a single Action, Deframe. Since the Deframer depends on the protocol used at the application layer, it is bound to the Preconnection during the pre-establishment phase:</p>
<pre>
Preconnection.DeframeWith(Deframer)

Message := Deframer.Deframe(OctetStream, ...)
</pre>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#introspection" id="introspection">Setting and Querying of Connection Properties</a>
</h1>
<p id="rfc.section.9.p.1">At any point, the application can set and query the properties of a Connection. Depending on the phase the connection is in, the connection properties will include different information.</p>
<pre>
connectionProperties := Connection.getProperties()
</pre>
<pre>
Connection.setProperties()
</pre>
<p id="rfc.section.9.p.2">Connection properties include:</p>
<p></p>

<ul>
<li>The status of the Connection, which can be one of the following: Establishing, Established, Closing, or Closed.</li>
<li>Transport Features of the protocols that conform to the Required and Prohibited Transport Preferences, which might be selected by the transport system during Establishment. These features correspond to the properties given in <a href="#transport-params" class="xref">Section 5.2</a> and can only be queried.</li>
<li>Transport Features of the protocols that were selected, once the Connection has been established. These features correspond to the properties given in <a href="#transport-params" class="xref">Section 5.2</a> and can only be queried.</li>
<li>Protocol Properties of the Protocol Stack in use (see <a href="#protocol-props" class="xref">Section 9.1</a> below). These can be set or queried. Certain specific procotol queries may be read-only, on a protocol and property specific basis.</li>
<li>Path Properties of the path(s) in use, once the Connection has been established. These  properties can be derived from the local provisioning domain, measurements by the protocol stack, or other sources. They can only be queried.</li>
</ul>
<p><a href="#appendix-specify-query-params" class="xref">Appendix C.2</a> gives a more detailed overview of the different types of properties that can be set and queried at different times.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#protocol-props" id="protocol-props">Protocol Properties</a>
</h1>
<p id="rfc.section.9.1.p.1">Protocol Properties represent the configuration of the selected Protocol Stacks backing a connection. Some properties apply generically across multiple transport protocols, while other properties only apply to specific protocols.  The default settings of these properties will vary based on the specific protocols being used and the system&#8217;s configuration.</p>
<p id="rfc.section.9.1.p.2">Note that Protocol Properties are also set during pre-establishment, as transport parameters, to preconfigure Protocol Stacks during establishment.</p>
<p id="rfc.section.9.1.p.3">Generic Protocol Properties include:</p>
<p></p>

<ul>
<li>Timeout for aborting Connection: This numeric property specifies how long to wait before aborting a Connection during establishment, or after a connection has failed after establishment. It is given in seconds.</li>
<li>Abort timeout to suggest to the Remote Endpoint: This numeric property specifies the timeout to propose to the Remote Endpoint. It is given in seconds.</li>
<li>Retransmission threshold before excessive retransmission notification: This numeric property specifies after how many retransmissions to inform the application about &#8220;Excessive Retransmissions&#8221;.</li>
<li>Required minimum coverage of the checksum for receiving: This numeric property specifies the part of the received data that needs to be covered by a checksum. It is given in Bytes. A value of 0 means that no checksum is required, and a special value (e.g., -1) indicates full checksum coverage.</li>
<li>Connection group transmission scheduler: This enumerated property specifies which scheduler should be used among Connections within a Connection Group. It applies to connection groups; the set of schedulers can be taken from <a href="#I-D.ietf-tsvwg-sctp-ndata" class="xref">[I-D.ietf-tsvwg-sctp-ndata]</a>.</li>
<li>Maximum message size concurrent with connection establishment: This numeric property represents the maximum Message size that can be sent before or during Connection establishment, see also <a href="#send-idempotent" class="xref">Section 7.1.1.4</a>.  It is given in Bytes. This property is read-only.</li>
<li>Maximum Message size before fragmentation or segmentation: This numeric property, if applicable, represents the maximum Message size that can be sent without incurring network-layer fragmentation and/or transport layer segmentation at the sender. This property is read-only.</li>
<li>Maximum non-partial Message size on send: This numeric property represents the maximum Message size that can be sent as a non-partial Message. This property is read-only.</li>
<li>Maximum non-partial Message size on receive: This numeric property represents the maximum Message size that can be received as a non-partial Message. This property is read-only.</li>
</ul>
<p id="rfc.section.9.1.p.5">In order to specify Specific Protocol Properties, Transport System implementations may offer applications to attach a set of options to the Preconnection object, associated with a specific protocol. For example, an application could specify a set of TCP Options to use if and only if TCP is selected by the system. Such properties must not be assumed to apply across different protocols. Attempts to set specific protocol properties on a protocol stack not containing that specific protocol are simply ignored, and do not raise an error..</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#termination" id="termination">Connection Termination</a>
</h1>
<p id="rfc.section.10.p.1">Close terminates a Connection after satisfying all the requirements that were specified regarding the delivery of Messages that the application has already given to the transport system. For example, if reliable delivery was requested for a Message handed over before calling Close, the transport system will ensure that this Message is indeed delivered. If the Remote Endpoint still has data to send, it cannot be received after this call.</p>
<pre>
Connection.Close()
</pre>
<p id="rfc.section.10.p.2">The Closed event can inform the application that the Remote Endpoint has closed the Connection; however, there is no guarantee that a remote close will be signaled.</p>
<pre>
Connection -&gt; Closed&amp;lt;&gt;
</pre>
<p id="rfc.section.10.p.3">Abort terminates a Connection without delivering remaining data:</p>
<pre>
Connection.Abort()
</pre>
<p id="rfc.section.10.p.4">A ConnectionError can inform the application that the other side has aborted the Connection; however, there is no guarantee that an abort will be signaled:</p>
<pre>
Connection -&gt; ConnectionError&amp;lt;&gt;
</pre>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#event-and-error-handling" id="event-and-error-handling">Event and Error Handling</a>
</h1>
<p id="rfc.section.11.p.1">[EDITOR&#8217;S NOTE: point out that events and errors may be handled differently, although they are the modeled the same in this specification.]</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.12.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.12.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.13.p.1">This document describes a generic API for interacting with a transport services (TAPS) system.  Part of this API includes configuration details for transport security protocols, as discussed in Section <a href="#security-parameters" class="xref">Section 5.3</a>. It does not recommend use (or disuse) of specific algorithms or protocols. Any API-compatible transport security protocol should work in a TAPS system.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.14.p.1">This work has received funding from the European Union&#8217;s Horizon 2020 research and innovation programme under grant agreements No. 644334 (NEAT) and No. 688421 (MAMI).</p>
<p id="rfc.section.14.p.2">This work has been supported by Leibniz Prize project funds of DFG - German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).</p>
<p id="rfc.section.14.p.3">Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work. Thanks to Laurent Chuat and Jason Lee for initial work on the Post Sockets interface, from which this work has evolved.</p>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">15.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-taps-minset">[I-D.ietf-taps-minset]</b></td>
<td class="top">
<a>Welzl, M.</a> and <a>S. Gjessing</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-minset-01">A Minimal Set of Transport Services for TAPS Systems</a>", Internet-Draft draft-ietf-taps-minset-01, February 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-rtcweb-qos">[I-D.ietf-tsvwg-rtcweb-qos]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Dhesikan, S.</a>, <a>Jennings, C.</a> and <a>D. Druta</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rtcweb-qos-18">DSCP Packet Markings for WebRTC QoS</a>", Internet-Draft draft-ietf-tsvwg-rtcweb-qos-18, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tsvwg-sctp-ndata">[I-D.ietf-tsvwg-sctp-ndata]</b></td>
<td class="top">
<a>Stewart, R.</a>, <a>Tuexen, M.</a>, <a>Loreto, S.</a> and <a>R. Seggelmann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13">Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</a>", Internet-Draft draft-ietf-tsvwg-sctp-ndata-13, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="TAPS-ARCH">[TAPS-ARCH]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Trammell, B.</a>, <a>Brunstrom, A.</a>, <a>Fairhurst, G.</a>, <a>Perkins, C.</a>, <a>Tiesel, P.</a> and <a>C. Wood</a>, "<a>An Architecture for Transport Services</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">15.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.pauly-taps-transport-security">[I-D.pauly-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a>, <a>Rose, K.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-pauly-taps-transport-security-01">A Survey of Transport Security Protocols</a>", Internet-Draft draft-pauly-taps-transport-security-01, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="https://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8095">[RFC8095]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/rfc8095">Services Provided by IETF Transport Protocols and Congestion Control Mechanisms</a>", RFC 8095, DOI 10.17487/RFC8095, March 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#appendix-non-consensus" id="appendix-non-consensus">Additional Properties</a>
</h1>
<p id="rfc.section.A.p.1">The interface specified by this document represents the minimal common interface to an endpoint in the transport services architecture <a href="#TAPS-ARCH" class="xref">[TAPS-ARCH]</a>, based upon that architecture and on the minimal set of transport service features elaborated in <a href="#I-D.ietf-taps-minset" class="xref">[I-D.ietf-taps-minset]</a>. However, the interface has been designed with extension points to allow the implementation of features beyond those in the minimal common interface: Protocol Selection Properties, Path Selection Properties, and options on Message send are open sets. Implementations of the interface are free to extend these sets to provide additional expressiveness to applications written on top of them.</p>
<p id="rfc.section.A.p.2">This appendix enumerates a few additional parameters and properties that could be used to enhance transport protocol and/or path selection, or the transmission of messages given a Protocol Stack that implements them. These are not part of the interface, and may be removed from the final document, but are presented here to support discussion within the TAPS working group as to whether they should be added to a future revision of the base specification.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#protocol-and-path-selection-properties" id="protocol-and-path-selection-properties">Protocol and Path Selection Properties</a>
</h1>
<p id="rfc.section.A.1.p.1">The following protocol and path selection properties might be made available in addition to those specified in <a href="#transport-params" class="xref">Section 5.2</a>:</p>
<p></p>

<ul><li>Request not to delay acknowledgment of Message: This boolean property specifies whether an application considers it useful to request for Message that its acknowledgment be sent out as early as possible instead of potentially being bundled with other acknowledgments. This property applies to connections and connection groups. This is not a strict requirement. The default is to not have this option.</li></ul>
<h1 id="rfc.appendix.A.1.1">
<a href="#rfc.appendix.A.1.1">A.1.1.</a> <a href="#intents" id="intents">Application Intents</a>
</h1>
<p id="rfc.section.A.1.1.p.1">Application Intents are a group of transport properties expressing what an application wants to achieve, knows, assumes or prefers regarding its communication. They are not strict requirements. In particular, they should not be used to express any Quality of Service expectations that an application might have. Instead, an application should express its intentions and its expected traffic characteristics in order to help the transport system make decisions that best match it, but on a best-effort basis. Even though Application Intents do not represent Quality of Service requirements, a transport system may use them to determine a DSCP value, e.g. similar to Table 1 in <a href="#I-D.ietf-tsvwg-rtcweb-qos" class="xref">[I-D.ietf-tsvwg-rtcweb-qos]</a>.</p>
<p id="rfc.section.A.1.1.p.2">Application Intents can influence protocol selection, protocol configuration, path selection, and endpoint selection. For example, setting the &#8220;Timeliness&#8221; Intent to &#8220;Interactive&#8221; may lead the transport system to disable the Nagle algorithm for a connection, while setting the &#8220;Timeliness&#8221; to &#8220;Background&#8221; may lead it to setting the DSCP value to &#8220;scavenger&#8221;. If the &#8220;Size to be Sent&#8221; Intent is set on an individual Message, it may influence path selection.</p>
<p id="rfc.section.A.1.1.p.3">Specifying Application Intents is not mandatory. An application can specify any combination of Application Intents. If specified, Application Intents are defined as parameters passed to the Preconnection object, and may influence the Connection established from that Preconnection. If a Connection is cloned to form a Connection Group, and associated Application Intents are cloned along with the other transport parameters. Some Intents have also corresponding Message Properties, similar to the properties in <a href="#send-params" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.A.1.1.p.4">Application Intents can be added to this interface as Transport Preferences with the &#8220;prefer&#8221; preference level.</p>
<h1 id="rfc.appendix.A.1.1.1">
<a href="#rfc.appendix.A.1.1.1">A.1.1.1.</a> <a href="#traffic-category" id="traffic-category">Traffic Category</a>
</h1>
<p id="rfc.section.A.1.1.1.p.1">This Intent specifies what the application expect the dominating traffic pattern to be.</p>
<p id="rfc.section.A.1.1.1.p.2">Possible Category values are:</p>
<p></p>

<dl>
<dt>Query:</dt>
<dd style="margin-left: 8">Single request / response style workload, latency bound</dd>
<dt>Control:</dt>
<dd style="margin-left: 8">Long lasting low bandwidth control channel, not bandwidth bound</dd>
<dt>Stream:</dt>
<dd style="margin-left: 8">Stream of data with steady data rate</dd>
<dt>Bulk:</dt>
<dd style="margin-left: 8">Bulk transfer of large Messages, presumably bandwidth bound</dd>
</dl>
<p id="rfc.section.A.1.1.1.p.4">The default is to not assume any particular traffic pattern. Most categories suggest the use of other intents to further describe the traffic pattern anticipated, e.g., the bulk category suggesting the use of the Message Size intents or the stream category suggesting the Stream Bitrate and Duration intents.</p>
<h1 id="rfc.appendix.A.1.1.2">
<a href="#rfc.appendix.A.1.1.2">A.1.1.2.</a> <a href="#size-to-be-sent-received" id="size-to-be-sent-received">Size to be Sent / Received</a>
</h1>
<p id="rfc.section.A.1.1.2.p.1">This Intent specifies what the application expects the size of a transfer to be.  It is a numeric property and given in Bytes.</p>
<h1 id="rfc.appendix.A.1.1.3">
<a href="#rfc.appendix.A.1.1.3">A.1.1.3.</a> <a href="#duration" id="duration">Duration</a>
</h1>
<p id="rfc.section.A.1.1.3.p.1">This Intent specifies what the application expects the lifetime of a transfer to be. It is a numeric property and given in milliseconds.</p>
<h1 id="rfc.appendix.A.1.1.4">
<a href="#rfc.appendix.A.1.1.4">A.1.1.4.</a> <a href="#send-receive-bit-rate" id="send-receive-bit-rate">Send / Receive Bit-rate</a>
</h1>
<p id="rfc.section.A.1.1.4.p.1">This Intent specifies what the application expects the bit-rate of a transfer to be. It is a numeric property and given in Bytes per second.</p>
<h1 id="rfc.appendix.A.1.1.5">
<a href="#rfc.appendix.A.1.1.5">A.1.1.5.</a> <a href="#cost-preferences" id="cost-preferences">Cost Preferences</a>
</h1>
<p id="rfc.section.A.1.1.5.p.1">This Intent describes what an application prefers regarding monetary costs, e.g., whether it considers it acceptable to utilize limited data volume. It provides hints to the transport system on how to handle trade-offs between cost and performance or reliability. This Intent can also apply to an individual Messages.</p>
<p></p>

<dl>
<dt>No Expense:</dt>
<dd style="margin-left: 8">Avoid transports associated with monetary cost</dd>
<dt>Optimize Cost:</dt>
<dd style="margin-left: 8">Prefer inexpensive transports and accept service degradation</dd>
<dt>Balance Cost:</dt>
<dd style="margin-left: 8">Use system policy to balance cost and other criteria</dd>
<dt>Ignore Cost:</dt>
<dd style="margin-left: 8">Ignore cost, choose transport solely based on other criteria</dd>
</dl>
<p id="rfc.section.A.1.1.5.p.3">The default is &#8220;Balance Cost&#8221;.</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#send-parameters" id="send-parameters">Send Parameters</a>
</h1>
<p id="rfc.section.A.2.p.1">The following send parameters might be made available in addition to those specified in <a href="#send-params" class="xref">Section 7.1</a>:</p>
<p></p>

<ul>
<li>Immediate: Immediate is a boolean property. If true, the caller prefers immediacy to efficient capacity usage for this Message. For example, this means that the Message should not be bundled with other Message into the same transmission by the underlying Protocol Stack.</li>
<li>Send Bitrate: This numeric property in Bytes per second specifies at what bitrate the application wishes the Message to be sent. A transport supporting this feature will not exceed the requested Send Bitrate even if flow-control and congestion control allow higher bitrates. This helps to avid bursty traffic pattern on busy video streaming servers.</li>
</ul>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#appendix-api-sketch" id="appendix-api-sketch">Sample API definition in Go</a>
</h1>
<p id="rfc.section.B.p.1">[EDITOR&#8217;S NOTE: rewrite following discussion and copy back here; see https://github.com/taps-api/drafts/issues/39]</p>
<p id="rfc.section.B.p.2">This document defines an abstract interface. To illustrate how this would map concretely into a programming language, this appendix contains an API interface definition in Go, using callbacks for event handling. The documentation for the API sketch is available online at https://godoc.org/github.com/mami-project/postsocket.</p>
<pre>
package postsocket

import (
  "crypto"
  "crypto/tls"
  "io"
  "net"
  "time"
)

type TransportContext interface {
  NewTransportParameters() TransportParameters
  NewSecurityParameters() SecurityParameters
  NewRemote() Remote
  NewLocal() Local
  DefaultSendParameters() SendParameters

  SetEventHandler(evh EventHandler)
  SetFramingHandler(fh FramingHandler)

  Preconnect(evh EventHandler, fh FramingHandler,
             rem Remote, loc Local,
             tp TransportParameters,
             sp SecurityParameters) (Preconnection, error)

  Initiate(rem Remote, loc Local,
           tp TransportParameters,
           sp SecurityParameters) (Connection, error)
  Rendezvous(rem Remote, loc Local,
             tp TransportParameters,
             sp SecurityParameters) (Connection, error)
  Listen(loc Local,
         tp TransportParameters,
         sp SecurityParameters) (Connection, error)
}

type Remote interface {
  WithHostname(hostname string) Remote
  WithAddress(address net.IP) Remote
  WithPort(port uint16) Remote
  WithServiceName(svc string) Remote
}

type Local interface {
  WithInterface(iface string) Local
  WithHostname(hostname string) Local
  WithAddress(address net.IP) Local
  WithPort(port uint16) Local
  WithServiceName(svc string) Local
}

type ParameterIdentifier int

const (
  TransportFullyReliable = iota
  // ... and so on
)

type TransportParameters interface {
  Require(p ParameterIdentifier, v int) TransportParameters
  Prefer(p ParameterIdentifier, v int) TransportParameters
  Avoid(p ParameterIdentifier, v int) TransportParameters
  Prohibit(p ParameterIdentifier, v int) TransportParameters
}

type SecurityMetadata struct {
  cert tls.Certificate
  // ... and so on
}

const (
  SecurityCallbackResultSuccess = 0x00
  SecurityCallbackResultFailure = 0x01
  SecurityCallbackResultPending = 0x02
)

type SecurityCallbackResult int

type SecurityParameters interface {
  AddIdentity(c tls.Certificate) SecurityParameters
  AddPrivateKey(sk crypto.PrivateKey, pk crypto.PublicKey) SecurityParameters
  AddPreSharedKey(key []byte, identity string) SecurityParameters
  AddSupportedGroup(g uint16) SecurityParameters
  AddCiphersuite(cs uint16) SecurityParameters
  AddSignatureAlgorithm(cs uint16) SecurityParameters
  SetSessionCacheCapacity(c int) SecurityParameters
  SetSessionCacheLifetime(t int) SecurityParameters
  SetSessionCacheReuse(c int) SecurityParameters
  VerifyTrustWith(func(m SecurityMetadata) (bool, error)) SecurityCallbackResult
  HandleChallengeWith(func(m SecurityMetadata) (bool, error)) SecurityCallbackResult
  Require(p ParameterIdentifier, v interface{} SecurityParameters
  Prefer(p ParameterIdentifier, v interface{}) SecurityParameters
  Avoid(p ParameterIdentifier, v interface{}) SecurityParameters
  Prohibit(p ParameterIdentifier, v interface{}) SecurityParameters
}

type SendParameters struct {
  Lifetime time.Duration
  Niceness uint
  Ordered bool
  Immediate bool
  Idempotent bool
  CorruptionProtection int
  AckImmediate bool
}

type Preconnection interface {
  AddSpecifier(rem Remote, loc Local,
               tp TransportParameters, sp SecurityParameters)
  Initiate() (Connection, error)
  InitialSend(content interface{}, sp SendParameters) (Connection, error)
  Rendezvous() (Connection, error)
  Listen() (Connection, error)
}

type Connection interface {
  Send(content interface{}, msgRef interface{}, sp SendParameters) error

  Clone() (Connection, error)
  Close() error

  GetEventHandler() EventHandler
  SetEventHandler(evh EventHandler)

  GetFramingHandler() FramingHandler
  SetFramingHandler(fh FramingHandler)
}

type Content interface {
  Bytes() []byte
  GetMetadata(key string) interface{}
}

// EventHandler defines the interface for connection event handlers.
type EventHandler interface {
  Ready(conn Connection, ante Connection)
  Received(content Content, conn Connection)
  Sent(conn Connection, msgRef interface{})
  Expired(conn Connection, msgRef interface{})
  Closed(conn Connection, err error)
  // note that errors are coalesced into a single handler; the err parameter
  // contains the type of error, and msgRef is nil for all but send errors.
  Error(conn Connection, msgRef interface{}, err error)
}

type FramingHandler interface {
  Frame(content interface{}) ([]byte, error)
  Deframe(in io.Reader) (Content, error)
}
</pre>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#appendix-transport-params" id="appendix-transport-params">Transport Parameters</a>
</h1>
<p id="rfc.section.C.p.1">[EDITOR&#8217;S NOTE: move into main document as necessary; find a way to move the rest into Appendix A or cut it; see https://github.com/taps-api/drafts/issues/69]</p>
<p id="rfc.section.C.p.2">This appendix provides details about the usage of the Transport Parameters specified in <a href="#transport-params" class="xref">Section 5.2</a>. It clarifies what preference levels an application can set for which Transport Parameter, and during which phase an application can specify and query what kinds of Transport Parameters.</p>
<h1 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#appendix-preferences" id="appendix-preferences">Application Preferences</a>
</h1>
<p id="rfc.section.C.1.p.1">As described in <a href="#transport-params" class="xref">Section 5.2</a>, an application can specify its preference regarding a Transport Parameter, i.e., whether a certain property is required, preferred, to be avoided, prohibited, or an intention. If an application does not set its preference regarding a Transport Parameter, default preference levels apply as specified in the following table. A default preference of &#8220;None&#8221; means that the transport system assumes that an application does not have any preference regarding the corresponding Transport Parameter and may not take this parameter into account for protocol and path selection.</p>
<p id="rfc.section.C.1.p.2">Not every Transport Parameter can be meaningfully assigned every preference level. For example, if an application explicitly prohibits selecting a transport protocol that allows to suggest a timeout to the Remote Endpoint, this restriction will unnecessarily limit transport protocol selection. Instead, the application could simply not use this feature if it is present in the selected transport protocol.</p>
<p id="rfc.section.C.1.p.3">The following table illustrates which Transport Parameter has which default preference level and which alternative preference levels an application may set.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Transport Parameter</th>
<th class="left">Require</th>
<th class="left">Prefer</th>
<th class="left">Avoid</th>
<th class="left">Prohibit</th>
<th class="left">Default</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Reliable Data Transfer</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Preserve Data Ordering</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Require</td>
</tr>
<tr>
<td class="left">Configure Reliability per Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Request immediate ACK</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use 0-RTT with Idempotent Content</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use Connection Groups with priorities</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Suggest timeout to Remote Endpoint</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Notification of special errors</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Control checksum coverage</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Use a certain network interface type</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">None</td>
</tr>
<tr>
<td class="left">Application Intents</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Intend</td>
</tr>
</tbody>
</table>
<p id="rfc.section.C.1.p.4">[List individual Intents? Reformulate some of them as preferences?]</p>
<h1 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#appendix-specify-query-params" id="appendix-specify-query-params">Specifying and Querying Parameters</a>
</h1>
<p id="rfc.section.C.2.p.1">In this appendix we give an overview of the different types of properties, the objects to which they apply, and at what time an application can query them.</p>
<p id="rfc.section.C.2.p.2">During the Pre-Establishment phase, an application may specify Transport Parameters for a Connection as described in <a href="#transport-params" class="xref">Section 5.2</a>.  Specifically, Protocol Selection Properties, Path Selection Properties, and Application Intents for the Connection MUST be specified during Pre-Establishment, as protocol and path selection occur during connection establishment. An application may query the Transport Parameters that were specified for a Connection at all times.</p>
<p id="rfc.section.C.2.p.3">Transport Features represent the actual capabilities of specific Protocol Stacks. They are expressed in the same vocabulary as Protocol Selection Properties, but have a Boolean value expressing whether a Protocol Stack support the given Transport Feature or not. An application may query the Transport Features of Protocol Stacks at all times. Once a Connection is established, an application may query the Transport Features of the actually chosen protocols, the Protocol Stack Instances, for this Connection.</p>
<p id="rfc.section.C.2.p.4">Note that it is possible that the Protocol Stack Instances actually chosen by the transport system do not fully reflect the Transport Parameters that were originally set. For example, a certain Protocol Selection Property that an application specified as Preferred may not actually be present in the chosen Protocol Stack Instances because none of the currently available transport protocols had this feature.</p>
<p id="rfc.section.C.2.p.5">Protocol Stacks and Protocol Stack Instances also have Protocol Properties, which represent the specific configuration of a transport protocol. Their default values can be queried at all times, and an application can override these defaults for a specific Connection by specifying Protocol Properties either during pre-establishment or later in the lifetime of a Connection. This configuration is applied on the Protocol Stack Instance once it is bound to the Connection.</p>
<p id="rfc.section.C.2.p.6">Note that some Protocol Properties set during Pre-Establishment may not apply to the actually chosen protocol later, and consequently not be set in the resulting Protocol Stack Instance. However, it is beneficial for an application to set these properties as early as possible, so the transport system can use them to optimize.</p>
<p id="rfc.section.C.2.p.7">Finally, an application may query the properties of the available paths and the properties of the path(s) chosen for a Connection at all times.</p>
<p id="rfc.section.C.2.p.8">An application may also specify Send Properties per individual Content, as specified in <a href="#send-params" class="xref">Section 7.1</a>.</p>
<p id="rfc.section.C.2.p.9">The following table shows the types of existing properties and what an application can do with them during what phase:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Property Type</th>
<th class="left">Applies to</th>
<th class="left">Pre-Establishment</th>
<th class="left">Established</th>
</tr></thead>
<tbody>
<tr>
<td class="left">Transport Parameters</td>
<td class="left">Connection</td>
<td class="left">Set, Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Features</td>
<td class="left">ProtocolStack, ProtocolStackInstance</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Property defaults</td>
<td class="left">ProtocolStack</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Protocol Properties</td>
<td class="left">ProtocolStackInstance</td>
<td class="left">Set</td>
<td class="left">Set, Query</td>
</tr>
<tr>
<td class="left">Path Properties</td>
<td class="left">Path</td>
<td class="left">Query</td>
<td class="left">Query</td>
</tr>
<tr>
<td class="left">Send Properties</td>
<td class="left">Content</td>
<td class="left">Set</td>
<td class="left">Set</td>
</tr>
</tbody>
</table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael Welzl</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Welzl</span>
	  </span>
	</span>
	<span class="org vcardline">University of Oslo</span>
	<span class="adr">
	  <span class="vcardline">PO Box 1080 Blindern</span>

	  <span class="vcardline">
		<span class="locality">0316  Oslo</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Norway</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michawe@ifi.uio.no">michawe@ifi.uio.no</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Theresa Enghardt</span> 
	  <span class="n hidden">
		<span class="family-name">Enghardt</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:theresa@inet.tu-berlin.de">theresa@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Godred Fairhurst</span> 
	  <span class="n hidden">
		<span class="family-name">Fairhurst</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  <span class="vcardline">Fraser Noble Building</span>

	  <span class="vcardline">
		<span class="locality">Aberdeen, AB24 3UE</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Scotland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:gorry@erg.abdn.ac.uk">gorry@erg.abdn.ac.uk</a></span>

<span class="vcardline">URI: <a href="http://www.erg.abdn.ac.uk/">http://www.erg.abdn.ac.uk/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Philipp S. Tiesel</span> 
	  <span class="n hidden">
		<span class="family-name">Tiesel</span>
	  </span>
	</span>
	<span class="org vcardline">TU Berlin</span>
	<span class="adr">
	  <span class="vcardline">Marchstra&#223;e 23</span>

	  <span class="vcardline">
		<span class="locality">10587 Berlin</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:philipp@inet.tu-berlin.de">philipp@inet.tu-berlin.de</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
