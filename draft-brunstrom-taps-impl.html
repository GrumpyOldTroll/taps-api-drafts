<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Implementing Interfaces to Transport Services</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 550px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 55px;
    overflow: auto;
    overscroll-behavior: contain;
  }
  ul.toc, #rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 140px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 16px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 36px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 18px;
  line-height: 27px%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Implementing Transport Objects">
<link href="#rfc.section.3" rel="Chapter" title="3 Implementing Pre-Establishment">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Configuration-time errors">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Role of system policy">
<link href="#rfc.section.4" rel="Chapter" title="4 Implementing Connection Establishment">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Candidate Gathering">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Structuring Options as a Tree">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Branch Types">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Branching Order-of-Operations">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Candidate Racing">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Delayed Racing">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Failover">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Completing Establishment">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Determining Successful Establishment">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Establishing multiplexed connections">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Handling racing with &#8220;unconnected&#8221; protocols">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Implementing listeners">
<link href="#rfc.section.5" rel="Chapter" title="5 Implementing Data Transfer">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Data transfer for streams, datagrams, and frames">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Sending content">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Receiving content">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Handling of data for fast-open protocols">
<link href="#rfc.section.6" rel="Chapter" title="6 Implementing Maintenance Events">
<link href="#rfc.section.7" rel="Chapter" title="7 Implementing Termination">
<link href="#rfc.section.8" rel="Chapter" title="8 Cached State">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Protocol caches">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Performance caches">
<link href="#rfc.section.9" rel="Chapter" title="9 Specific Transport Protocol Considerations">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 TCP">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 UDP">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 SCTP">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 QUIC">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 HTTP over TLS as a pseudotransport">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 HTTP/2 transport">
<link href="#rfc.section.10" rel="Chapter" title="10 Rendezvous and Environment Discovery">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 ICE and STUN">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Considerations for Candidate Gathering">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Considerations for Candidate Racing">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.5 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Brunstrom, A., Ed., Pauly, T., Ed., Grinnemo, K-J., Jones, T., and C. Perkins" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-brunstrom-taps-impl-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-2-06" />
  <meta name="dct.abstract" content="The Transport Services architecture " />
  <meta name="description" content="The Transport Services architecture " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">A. Brunstrom, Ed.</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right"></td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">T. Pauly, Ed.</td>
</tr>
<tr>
<td class="left">Expires: August 10, 2018</td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">K-J. Grinnemo</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Karlstad University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Jones</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Aberdeen</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 06, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Implementing Interfaces to Transport Services<br />
  <span class="filename">draft-brunstrom-taps-impl-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The Transport Services architecture <a href="#I-D.pauly-taps-arch" class="xref">[I-D.pauly-taps-arch]</a> defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build a system that provides such an interface.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 10, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Implementing Transport Objects</a>
</li>
<li>3.   <a href="#rfc.section.3">Implementing Pre-Establishment</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Configuration-time errors</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Role of system policy</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Implementing Connection Establishment</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Candidate Gathering</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Structuring Options as a Tree</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Branch Types</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Branching Order-of-Operations</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Candidate Racing</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Delayed Racing</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Failover</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Completing Establishment</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">Determining Successful Establishment</a>
</li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Establishing multiplexed connections</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Handling racing with &#8220;unconnected&#8221; protocols</a>
</li>
<li>4.7.   <a href="#rfc.section.4.7">Implementing listeners</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Implementing Data Transfer</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Data transfer for streams, datagrams, and frames</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Sending content</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Receiving content</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Handling of data for fast-open protocols</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Implementing Maintenance Events</a>
</li>
<li>7.   <a href="#rfc.section.7">Implementing Termination</a>
</li>
<li>8.   <a href="#rfc.section.8">Cached State</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Protocol caches</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Performance caches</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Specific Transport Protocol Considerations</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">TCP</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">UDP</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">SCTP</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">QUIC</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">HTTP over TLS as a pseudotransport</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">HTTP/2 transport</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Rendezvous and Environment Discovery</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">ICE and STUN</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Considerations for Candidate Gathering</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Considerations for Candidate Racing</a>
</li>
</ul><li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The Transport Services architecture <a href="#I-D.pauly-taps-arch" class="xref">[I-D.pauly-taps-arch]</a> defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build a system that provides such an interface. The terminology used in this document is based on the Architecture.</p>
<p id="rfc.section.1.p.2">The interface exposed to applications is defined as the Transport Services API <a href="#I-D.trammell-taps-interface" class="xref">[I-D.trammell-taps-interface]</a>. This API is designed to be generic across multiple transport protocols and sets of protocols features. It is the job of an implementation of a Transport Services system to turn the requests of an application into decisions on how to establish connections, and how to transfer data over those connections once established.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#implementing-transport-objects" id="implementing-transport-objects">Implementing Transport Objects</a>
</h1>
<p id="rfc.section.2.p.1">What is the basic handle an application interacts with?</p>
<p></p>

<ul>
<li>A flow of data in either direction</li>
<li>For TCP, one connection is a Connection object</li>
<li>For UDP, one set of fully-specified local and remote endpoints is a Connection object</li>
<li>For QUIC, one stream is a Connection object</li>
<li>For SCTP&#8230;</li>
</ul>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#implementing-pre-establishment" id="implementing-pre-establishment">Implementing Pre-Establishment</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#configuration-time-errors" id="configuration-time-errors">Configuration-time errors</a>
</h1>
<p id="rfc.section.3.1.p.1">Invalid or impossible combinations properties should error out quickly to avoid unexpected results</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#role-of-system-policy" id="role-of-system-policy">Role of system policy</a>
</h1>
<p id="rfc.section.3.2.p.1">How do the implementation&#8217;s default policy, a dynamic system policy, and application preferences interact.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#implementing-connection-establishment" id="implementing-connection-establishment">Implementing Connection Establishment</a>
</h1>
<p id="rfc.section.4.p.1">The process of establishing a network connection begins when an application expresses intent to communicate with a remote endpoint (along with any constraints or requirements it may have on the connection). The process can be considered complete once there is at least one set of network protocols that have completed any required setup to the point that it can transmit and receive the application&#8217;s data.</p>
<p id="rfc.section.4.p.2">Connection establishment is divided into two top-level steps: Candidate Gathering, to identify the paths, protocols, and endpoints to use, and Candidate Racing, in which the necessary protocol handshakes are conducted in order to select which set to use.</p>
<p id="rfc.section.4.p.3">The most simple example of this process might involve identifying the single IP address to which the implementation wishes to connect, using the system&#8217;s current default interface or path, and starting a TCP handshake to establish a stream to the specified IP address. However, each step may also vary depending on the requirements of the connection: if the endpoint is defined as a hostname and port, then there may be multiple resolved addresses that are available; there may also be multiple interfaces or paths available, other than the default system interface; and some protocols may not need any transport handshake to be considered &#8220;established&#8221; (such as UDP), while other connections may utilize layered protocol handshakes, such as TLS over TCP.</p>
<p id="rfc.section.4.p.4">Whenever an implementation has multiple options for connection establishment, it can view the set of all individual connection establishment options as a single, aggregate connection establishment. The aggregate set conceptually includes every valid combination of endpoints, paths, and protocols. As an example, consider an implementation that initiates a TCP connection to a hostname + port endpoint, and has two valid interfaces available (Wi-Fi and LTE). The hostname resolves to a single IPv4 address on the Wi-Fi network, and resolves to the same IPv4 address on the LTE network, as well as a single IPv6 address. The aggregate set of connection establishment options can be viewed as follows:</p>
<pre>
Aggregate [Endpoint: www.example.com:80] [Interface: Any]   [Protocol: TCP]
|-&gt; [Endpoint: 192.0.2.1:80]       [Interface: Wi-Fi] [Protocol: TCP]
|-&gt; [Endpoint: 192.0.2.1:80]       [Interface: LTE]   [Protocol: TCP]
|-&gt; [Endpoint: 2001:DB8::1.80]     [Interface: LTE]   [Protocol: TCP]
</pre>
<p id="rfc.section.4.p.5">Any one of these sub-entries on the aggregate connection attempt would satisfy the original application intent. The concern of this document is the algorithm defining which of these options to try, when, and in what order.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#candidate-gathering" id="candidate-gathering">Candidate Gathering</a>
</h1>
<p id="rfc.section.4.1.p.1">The step of gathering candidates involves identifying which paths, protocols, and endpoints may be used for a given Connection. This list is determined by the requirements, prohibitions, and preferences of the application as specified in the Path Selection Properties and Protocol Selection Properties.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#structuring-options-as-a-tree" id="structuring-options-as-a-tree">Structuring Options as a Tree</a>
</h1>
<p id="rfc.section.4.1.1.p.1">When an implementation responsible for connection establishment needs to consider multiple options, it SHOULD logically structure these options as a hierarchical tree. Each leaf node of the tree represents a single, coherent connection attempt, with an Endpoint, a Path, and a set of protocols that can directly negotiate and send data on the network. Each node in the tree that is not a leaf represents a connection attempt that is either underspecified, or else includes multiple distinct options. For example. when connecting on an IP network, a connection attempt to a hostname and port is underspecified, because the connection attempt requires a resolved IP address as its remote endpoint. In this case, the node represented by the connection attempt to the hostname is a parent node, with child nodes for each IP address. Similarly, an implementation that is allowed to connect using multiple interfaces will have a parent node of the tree for the decision between the paths, with a branch for each interface.</p>
<p id="rfc.section.4.1.1.p.2">The example aggregate connection attempt above can be drawn as a tree by grouping the addresses resolved on the same interface into branches:</p>
<pre>
                             ||
                +==========================+
                |  www.example.com:80/Any  |
                +==========================+
                  //                    \\
+==========================+       +==========================+
| www.example.com:80/Wi-Fi |       |  www.example.com:80/LTE  |
+==========================+       +==========================+
             ||                      //                    \\
  +====================+  +====================+  +======================+
  | 192.0.2.1:80/Wi-Fi |  |  192.0.2.1:80/LTE  |  |  2001:DB8::1.80/LTE  |
  +====================+  +====================+  +======================+
</pre>
<p id="rfc.section.4.1.1.p.3">The rest of this section will use a notation scheme to represent this tree. The parent (or trunk) node of the tree will be represented by a single integer, such as &#8220;1&#8221;. Each child of that node will have an integer that identifies it, from 1 to the number of children. That child node will be uniquely identified by concatenating its integer to it&#8217;s parents identifier with a dot in between, such as &#8220;1.1&#8221; and &#8220;1.2&#8221;. Each node will be summarized by a tuple of three elements: Endpoint, Path, and Protocol. The above example can now be written more succinctly as:</p>
<pre>
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
    1.2.1 [192.0.2.1:80, LTE, TCP]
    1.2.2 [2001:DB8::1.80, LTE, TCP]
</pre>
<p id="rfc.section.4.1.1.p.4">When an implementation views this aggregate set of connection attempts as a single connection establishment, it only will use one of the leaf nodes to transfer data. Thus, when a single leaf node becomes ready to use, then the entire connection attempt is ready to use by the application. Another way to represent this is that every leaf node updates the state of its parent node when it becomes ready, until the trunk node of the tree is ready, which then notifies the application that the connection as a whole is ready to use.</p>
<p id="rfc.section.4.1.1.p.5">A connection establishment tree may be degenerate, and only have a single leaf node, such as a connection attempt to an IP address over a single interface with a single protocol.</p>
<pre>
1 [192.0.2.1:80, Wi-Fi, TCP]
</pre>
<p id="rfc.section.4.1.1.p.6">A parent node may also only have one child (or leaf) node, such as a when a hostname resolves to only a single IP address.</p>
<pre>
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
</pre>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#branch-types" id="branch-types">Branch Types</a>
</h1>
<p id="rfc.section.4.1.2.p.1">There are three types of branching from a parent node into one or more child nodes. Any parent node of the tree MUST only use one type of branching.</p>
<h1 id="rfc.section.4.1.2.1">
<a href="#rfc.section.4.1.2.1">4.1.2.1.</a> <a href="#derived-endpoints" id="derived-endpoints">Derived Endpoints</a>
</h1>
<p id="rfc.section.4.1.2.1.p.1">If a connection originally targets a single endpoint, there may be multiple endpoints of different types that can be derived from the original. The connection library should order the derived endpoints according to application preference and expected performance.</p>
<p id="rfc.section.4.1.2.1.p.2">DNS hostname-to-address resolution is the most common method of endpoint derivation. When trying to connect to a hostname endpoint on a traditional IP network, the implementation SHOULD send DNS queries for both A (IPv4) and AAAA (IPv6) records if both are supported on the local link. The algorithm for ordering and racing these addresses SHOULD follow the recommendations in Happy Eyeballs <a href="#RFC8305" class="xref">[RFC8305]</a>.</p>
<pre>
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [2001:DB8::1.80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, Wi-Fi, TCP]
  1.3 [2001:DB8::2.80, Wi-Fi, TCP]
  1.4 [2001:DB8::3.80, Wi-Fi, TCP]
</pre>
<p id="rfc.section.4.1.2.1.p.3">DNS-Based Service Discovery can also provide an endpoint derivation step. When trying to connect to a named service, the client may discover one or more hostname and port pairs on the local network using multicast DNS. These hostnames should each be treated as a branch which can be attempted independently from other hostnames. Each of these hostnames may also resolve to one or more addresses, thus creating multiple layers of branching.</p>
<pre>
1 [term-printer._ipp._tcp.meeting.ietf.org, Wi-Fi, TCP]
  1.1 [term-printer.meeting.ietf.org:631, Wi-Fi, TCP]
    1.1.1 [31.133.160.18.631, Wi-Fi, TCP]
</pre>
<h1 id="rfc.section.4.1.2.2">
<a href="#rfc.section.4.1.2.2">4.1.2.2.</a> <a href="#alternate-paths" id="alternate-paths">Alternate Paths</a>
</h1>
<p id="rfc.section.4.1.2.2.p.1">If a client has multiple network interfaces available to it, such as mobile client with both Wi-Fi and Cellular connectivity, it can attempt a connection over either interface. This represents a branch point in the connection establishment. Like with derived endpoints, the interfaces should be ranked based on preference, system policy, and performance. Attempts should be started on one interface, and then on other interfaces successively after delays based on expected round-trip-time or other available metrics.</p>
<pre>
1 [192.0.2.1:80, Any, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, LTE, TCP]
</pre>
<p id="rfc.section.4.1.2.2.p.2">This same approach applies to any situation in which the client is aware of multiple links or views of the network. Multiple Paths, each with a coherent set of addresses, routes, DNS server, and more, may share a single interface. A path may also represent a virtual interface service such as a Virtual Private Network (VPN).</p>
<p id="rfc.section.4.1.2.2.p.3">The list of available paths should be constrained by any requirements or prohibitions the application sets, as well as system policy.</p>
<h1 id="rfc.section.4.1.2.3">
<a href="#rfc.section.4.1.2.3">4.1.2.3.</a> <a href="#protocol-options" id="protocol-options">Protocol Options</a>
</h1>
<p id="rfc.section.4.1.2.3.p.1">Differences in possible protocol compositions and options can also provide a branching point in connection establishment. This allows clients to be resilient to situations in which a certain protocol is not functioning on a server or network.</p>
<p id="rfc.section.4.1.2.3.p.2">This approach is commonly used for connections with optional proxy server configurations. A single connection may be allowed to use an HTTP-based proxy, a SOCKS-based proxy, or connect directly. These options should be ranked and attempted in succession.</p>
<pre>
1 [www.example.com:80, Any, HTTP/TCP]
  1.1 [192.0.2.8:80, Any, HTTP/HTTP Proxy/TCP]
  1.2 [192.0.2.7:10234, Any, HTTP/SOCKS/TCP]
  1.3 [www.example.com:80, Any, HTTP/TCP]
    1.3.1 [192.0.2.1:80, Any, HTTP/TCP]
</pre>
<p id="rfc.section.4.1.2.3.p.3">This approach also allows a client to attempt different sets of application and transport protocols that may provide preferable characteristics when available. For example, the protocol options could involve QUIC <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a> over UDP on one branch, and HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a> over TLS over TCP on the other:</p>
<pre>
1 [www.example.com:443, Any, Any HTTP]
  1.1 [www.example.com:443, Any, QUIC/UDP]
    1.1.1 [192.0.2.1:443, Any, QUIC/UDP]
  1.2 [www.example.com:443, Any, HTTP2/TLS/TCP]
    1.2.1 [192.0.2.1:443, Any, HTTP2/TLS/TCP]
</pre>
<p id="rfc.section.4.1.2.3.p.4">Another example is racing SCTP with TCP:</p>
<pre>
1 [www.example.com:80, Any, Any Stream]
  1.1 [www.example.com:80, Any, SCTP]
         1.1.1 [192.0.2.1:80, Any, SCTP]
  1.2 [www.example.com:80, Any, TCP]
    1.2.1 [192.0.2.1:80, Any, TCP]
</pre>
<p id="rfc.section.4.1.2.3.p.5">Implementations that support racing protocols and protocol options SHOULD maintain a history of which protocols and protocol options successfully established, on a per-network basis. This information can influence future racing decisions to prioritize or prune branches.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#branching-order-of-operations" id="branching-order-of-operations">Branching Order-of-Operations</a>
</h1>
<p id="rfc.section.4.2.p.1">Branch types must occur in a specific order relative to one another to avoid creating leaf nodes with invalid or incompatible settings. In the example above, it would be invalid to branch for derived endpoints (the DNS results for www.example.com) before branching between interface paths, since usable DNS results on one network may not necessarily be the same as DNS results on another network due to local network entities, supported address families, or enterprise network configurations. Implementations must be careful to branch in an order that results in usable leaf nodes whenever there are multiple branch types that could be used from a single node.</p>
<p id="rfc.section.4.2.p.2">The order of operations for branching, where lower numbers are acted upon first, SHOULD be:</p>
<p></p>

<ol>
<li>Alternate Paths</li>
<li>Protocol Options</li>
<li>Derived Endpoints</li>
</ol>
<p id="rfc.section.4.2.p.4">Branching between paths is the first in the list because results across multiple interfaces are likely not related to one another: endpoint resolution may return different results, especially when using locally resolved host and service names, and which protocols are supported and preferred may differ across interfaces. Thus, if multiple paths are attempted, the overall connection can be seen as a race between the available paths or interfaces.</p>
<p id="rfc.section.4.2.p.5">Protocol options are checked next in order. Whether or not a set of protocol, or protocol-specific options, can successfully connect is generally not dependent on which specific IP address is used. Furthermore, the protocol stacks being attempted may influence or altogether change the endpoints being used. Adding a proxy to a connection&#8217;s branch will change the endpoint to the proxy&#8217;s IP address or hostname. Choosing an alternate protocol may also modify the ports that should be selected.</p>
<p id="rfc.section.4.2.p.6">Branching for derived endpoints is the final step, and may have multiple layers of derivation or resolution, such as DNS service resolution and DNS hostname resolution.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#candidate-racing" id="candidate-racing">Candidate Racing</a>
</h1>
<p id="rfc.section.4.3.p.1">The primary goal of the Candidate Racing process is to successfully negotiate a protocol stack to an endpoint over an interface&#8212;to connect a single leaf node of the tree&#8212;with as little delay and as few unnecessary connections attempts as possible. Optimizing these two factors improves the user experience, while minimizing network load.</p>
<p id="rfc.section.4.3.p.2">This section covers the dynamic aspect of connection establishment. While the tree described above is a useful conceptual and architectural model, an implementation does not know what the full tree may become up front, nor will many of the possible branches be used in the common case.</p>
<p id="rfc.section.4.3.p.3">There are three different approaches to racing the attempts for different nodes of the connection establishment tree:</p>
<p></p>

<ol>
<li>Immediate</li>
<li>Delayed</li>
<li>Failover</li>
</ol>
<p id="rfc.section.4.3.p.5">Each approach is appropriate in different use-cases and branch types. However, to avoid consuming unnecessary network resources, implementations SHOULD NOT use immediate racing as a default approach.</p>
<p id="rfc.section.4.3.p.6">The timing algorithms for racing SHOULD remain independent across branches of the tree. Any timers or racing logic is isolated to a given parent node, and is not ordered precisely with regards to other children of other nodes.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#delayed-racing" id="delayed-racing">Delayed Racing</a>
</h1>
<p id="rfc.section.4.3.1.p.1">Delayed racing can be used whenever a single node of the tree has multiple child nodes. Based on the order determined when building the tree, the first child node will be initiated immediately, followed by the next child node after some delay. Once that second child node is initiated, the third child node (if present) will begin after another delay, and so on until all child nodes have been initiated, or one of the child nodes successfully completes its negotiation.</p>
<p id="rfc.section.4.3.1.p.2">Delayed racing attempts occur in parallel. Implementations SHOULD NOT terminate an earlier child connection attempt upon starting a secondary child.</p>
<p id="rfc.section.4.3.1.p.3">The delay between starting child nodes SHOULD be based on the properties of the previously started child node. For example, if the first child represents an IP address with a known route, and the second child represents another IP address, the delay between starting the first and second IP addresses can be based on the expected retransmission cadence for the first child&#8217;s connection (derived from historical round-trip-time). Alternatively, if the first child represents a branch on a Wi-Fi interface, and the second child represents a branch on an LTE interface, the delay should be based on the expected time in which the branch for the first interface would be able to establish a connection, based on link quality and historical round-trip-time.</p>
<p id="rfc.section.4.3.1.p.4">Any delay SHOULD have a defined minimum and maximum value based on the branch type. Generally, branches between paths and protocols should have longer delays than branches between derived endpoints. The maximum delay should be considered with regards to how long a user is expected to wait for the connection to complete.</p>
<p id="rfc.section.4.3.1.p.5">If a child node fails to connect before the delay timer has fired for the next child, the next child SHOULD be started immediately.</p>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> <a href="#failover" id="failover">Failover</a>
</h1>
<p id="rfc.section.4.3.2.p.1">If an implementation or application has a strong preference for one branch over another, the branching node may choose to wait until one child has failed before starting the next. Failure of a leaf node is determined by its protocol negotiation failing or timing out; failure of a parent branching node is determined by all of its children failing.</p>
<p id="rfc.section.4.3.2.p.2">An example in which failover is recommended is a race between a protocol stack that uses a proxy and a protocol stack that bypasses the proxy. Failover is useful in case the proxy is down or misconfigured, but any more aggressive type of racing may end up unnecessarily avoiding a proxy that was preferred by policy.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#completing-establishment" id="completing-establishment">Completing Establishment</a>
</h1>
<p id="rfc.section.4.4.p.1">The process of connection establishment completes when one leaf node of the tree has completed negotiation with the remote endpoint successfully, or else all nodes of the tree have failed to connect. The first leaf node to complete its connection is then used by the application to send and receive data.</p>
<p id="rfc.section.4.4.p.2">It is useful to process success and failure throughout the tree by child nodes reporting to their parent nodes (towards the trunk of the tree). For example, in the following case, if 1.1.1 fails to connect, it reports the failure to 1.1. Since 1.1 has no other child nodes, it also has failed and reports that failure to 1. Because 1.2 has not yet failed, 1 is not considered to have failed. Since 1.2 has not yet started, it is started and the process continues. Similarly, if 1.1.1 successfully connects, then it marks 1.1 as connected, which propagates to the trunk node 1. At this point, the connection as a whole is considered to be successfully connected and ready to process application data</p>
<pre>
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
...
</pre>
<p id="rfc.section.4.4.p.3">If a leaf node has successfully completed its connection, all other attempts SHOULD be made ineligible for use by the application for the original request. New connection attempts that involve transmitting data on the network SHOULD NOT be started after another leaf node has completed successfully, as the connection as a whole has been established. An implementation MAY choose to let certain handshakes and negotiations complete in order to gather metrics to influence future connections. Similarly, an implementation MAY choose to hold onto fully established leaf nodes that were not the first to establish for use in future connections, but this approach is not recommended since those attempts were slower to connect and may exhibit less desirable properties.</p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#determining-successful-establishment" id="determining-successful-establishment">Determining Successful Establishment</a>
</h1>
<p id="rfc.section.4.4.1.p.1">Implementations may select the criteria by which a leaf node is considered to be successfully connected differently on a per-protocol basis. If the only protocol being used is a transport protocol with a clear handshake, like TCP, then the obvious choice is to declare that node &#8220;connected&#8221; when the last packet of the three-way handshake has been received. If the only protocol being used is an &#8220;unconnected&#8221; protocol, like UDP, the implementation may consider the node fully &#8220;connected&#8221; the moment it determines a route is present, before sending any packets on the network.</p>
<p id="rfc.section.4.4.1.p.2">For protocol stacks with multiple handshakes, the decision becomes more nuanced. If the protocol stack involves both TLS and TCP, an implementation MAY determine that a leaf node is connected after the TCP handshake is complete, or it MAY wait for the TLS handshake to complete as well. The benefit of declaring completion when the TCP handshake finishes, and thus stopping the race for other branches of the tree, is that there will be less burden on the network from other connection attempts. On the other hand, by waiting until the TLS handshake is complete, an implementation avoids the scenario in which a TCP handshake completes quickly, but TLS negotiation is either very slow or fails altogether in particular network conditions or to a particular endpoint.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#establishing-multiplexed-connections" id="establishing-multiplexed-connections">Establishing multiplexed connections</a>
</h1>
<p id="rfc.section.4.5.p.1">How to create a new stream on an existing connection.</p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#handling-racing-with-unconnected-protocols" id="handling-racing-with-unconnected-protocols">Handling racing with &#8220;unconnected&#8221; protocols</a>
</h1>
<p id="rfc.section.4.6.p.1">How to handle UDP, and allowing the application or anothe protocol to cause the next option to be tried.</p>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> <a href="#implementing-listeners" id="implementing-listeners">Implementing listeners</a>
</h1>
<p id="rfc.section.4.7.p.1">How to passively wait for incoming connections, and what that means for protocols with and without handshakes.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#implementing-data-transfer" id="implementing-data-transfer">Implementing Data Transfer</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#data-transfer-for-streams-datagrams-and-frames" id="data-transfer-for-streams-datagrams-and-frames">Data transfer for streams, datagrams, and frames</a>
</h1>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#sending-content" id="sending-content">Sending content</a>
</h1>
<p id="rfc.section.5.1.1.p.1">How to handle sending data onto examples like TCP, UDP, and a basic Length-Value protocol.</p>
<p id="rfc.section.5.1.1.p.2">How to handle and notify errors when sending.</p>
<h1 id="rfc.section.5.1.1.1">
<a href="#rfc.section.5.1.1.1">5.1.1.1.</a> <a href="#send-completion" id="send-completion">Send Completion</a>
</h1>
<p id="rfc.section.5.1.1.1.p.1">How to determine when a send is effectively complete</p>
<h1 id="rfc.section.5.1.1.2">
<a href="#rfc.section.5.1.1.2">5.1.1.2.</a> <a href="#batching-sends" id="batching-sends">Batching Sends</a>
</h1>
<p id="rfc.section.5.1.1.2.p.1">Improve efficiency by handling multiple send operations at once for datagram or frame based protocols</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#receiving-content" id="receiving-content">Receiving content</a>
</h1>
<p id="rfc.section.5.1.2.p.1">How to handle sending data in examples like TCP, UDP, and a basic Length-Value protocol.</p>
<p id="rfc.section.5.1.2.p.2">Waiting for frame boundaries when necessary.</p>
<p id="rfc.section.5.1.2.p.3">How to handle and notify errors when receiving.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#fastopen" id="fastopen">Handling of data for fast-open protocols</a>
</h1>
<p id="rfc.section.5.2.p.1">Several protocols allow sending higher-level protocol or application data within the first packet of their protocol establishment, such as TCP Fast Open <a href="#RFC7413" class="xref">[RFC7413]</a> and TLS 1.3 <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a>. This approach is referred to as sending Zero-RTT (0-RTT) data. This is a desirable property, but poses challenges to an implementation that uses racing during connection establishment.</p>
<p id="rfc.section.5.2.p.2">If the application has 0-RTT data to send in any protocol handshakes, it needs to provide this data before the handshakes have begun. When racing, this means that the data SHOULD be provided before the process of connection establishment has begun. If the API allows the application to send 0-RTT data, it MUST provide an interface that identifies this data as idempotent data. In general, 0-RTT data may be replayed (for example, if a TCP SYN contains data, and the SYN is retransmitted, the data will be retransmitted as well), but racing means that different leaf nodes have the opportunity to send the same data independently. If data is truly idempotent, this should be permissible.</p>
<p id="rfc.section.5.2.p.3">Once the application has provided its 0-RTT data, an implementation SHOULD keep a copy of this data and provide it to each new leaf node that is started and for which a 0-RTT protocol is being used.</p>
<p id="rfc.section.5.2.p.4">It is also possible that protocol stacks within a particular leaf node use 0-RTT handshakes without any idempotent application data. For example, TCP Fast Open could use a Client Hello from a TLS as its 0-RTT data, shortening the cumulative handshake time.</p>
<p id="rfc.section.5.2.p.5">0-RTT handshakes often rely on previous state, such as TCP Fast Open cookies, previously established TLS tickets, or out-of-band distributed pre-shared keys (PSKs). Implementations should be aware of security concerns around using these tokens across multiple addresses or paths when racing. In the case of TLS, any given ticket or PSK SHOULD only be used on one leaf node. If implementations have multiple tickets available from a previous connection, each leaf node attempt MUST use a different ticket. In effect, each leaf node will send the same early application data, yet encoded (encrypted) differently on the wire.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#implementing-maintenance-events" id="implementing-maintenance-events">Implementing Maintenance Events</a>
</h1>
<p id="rfc.section.6.p.1">Implications of a network change on a protocol</p>
<p></p>

<ul>
<li>Multipath or migratable protocols</li>
<li>Single-path protocols</li>
</ul>
<p id="rfc.section.6.p.3">Quality changes</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#implementing-termination" id="implementing-termination">Implementing Termination</a>
</h1>
<p id="rfc.section.7.p.1">How to handle termination requested by application:</p>
<p></p>

<ul>
<li>How gracefully to tear down at various protocol layers</li>
<li>How much to tear down for multiplexed protocols, or protocols capable of multiplexing</li>
</ul>
<p id="rfc.section.7.p.3">How to handle a failure generated by protocols</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#cached-state" id="cached-state">Cached State</a>
</h1>
<p id="rfc.section.8.p.1">Beyond a single connection&#8217;s lifetime, it is useful to keep state and history.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#protocol-caches" id="protocol-caches">Protocol caches</a>
</h1>
<p id="rfc.section.8.1.p.1">Caching for DNS, TLS, etc. Associated with sets of endpoints for future use.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#performance-caches" id="performance-caches">Performance caches</a>
</h1>
<p id="rfc.section.8.2.p.1">Caching of round trip time (RTT), success rate with various protocols and features.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#specific-transport-protocol-considerations" id="specific-transport-protocol-considerations">Specific Transport Protocol Considerations</a>
</h1>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#tcp" id="tcp">TCP</a>
</h1>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#udp" id="udp">UDP</a>
</h1>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#sctp" id="sctp">SCTP</a>
</h1>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#quic" id="quic">QUIC</a>
</h1>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#http-over-tls-as-a-pseudotransport" id="http-over-tls-as-a-pseudotransport">HTTP over TLS as a pseudotransport</a>
</h1>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#http2-transport" id="http2-transport">HTTP/2 transport</a>
</h1>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#rendezvous-and-environment-discovery" id="rendezvous-and-environment-discovery">Rendezvous and Environment Discovery</a>
</h1>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#ice-and-stun" id="ice-and-stun">ICE and STUN</a>
</h1>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">RFC-EDITOR: Please remove this section before publication.</p>
<p id="rfc.section.11.p.2">This document has no actions for IANA.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#considerations-for-candidate-gathering" id="considerations-for-candidate-gathering">Considerations for Candidate Gathering</a>
</h1>
<p id="rfc.section.12.1.p.1">Implementations should avoid downgrade attacks that allow network interference to cause the implementation to select less secure, or entirely insecure, combinations of paths and protocols.</p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#considerations-for-candidate-racing" id="considerations-for-candidate-racing">Considerations for Candidate Racing</a>
</h1>
<p id="rfc.section.12.2.p.1">See <a href="#fastopen" class="xref">Section 5.2</a> for security considerations around racing with 0-RTT data.</p>
<p id="rfc.section.12.2.p.2">An attacker that knows a particular device is racing several options during connection establishment may be able to block packets for the first connection attempt, thus inducing the device to fall back to a secondary attempt. This is a problem if the secondary attempts have worse security properties that enable further attacks. Implementations should ensure that all options have equivalent security properties to avoid incentivizing attacks.</p>
<p id="rfc.section.12.2.p.3">Since results from the network can determine how a connection attempt tree is built, such as when DNS returns a list of resolved endpoints, it is possible for the network to cause an implementation to consume significant on-device resources. Implementations SHOULD limit the maximum amount of state allowed for any given node, including the number of child nodes, especially when the state is based on results from the network.</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.pauly-taps-arch">[I-D.pauly-taps-arch]</b></td>
<td class="top">"<a>An Architecture for Transport Services</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="I-D.trammell-taps-interface">[I-D.trammell-taps-interface]</b></td>
<td class="top">"<a>An Abstract Application Layer Interface to Transport Services</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-09">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-09, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-23">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-23, January 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7413">[RFC7413]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="https://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8305">[RFC8305]</b></td>
<td class="top">
<a>Schinazi, D.</a> and <a>T. Pauly</a>, "<a href="https://tools.ietf.org/html/rfc8305">Happy Eyeballs Version 2: Better Connectivity Using Concurrency</a>", RFC 8305, DOI 10.17487/RFC8305, December 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Anna Brunstrom</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Brunstrom</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:anna.brunstrom@kau.se">anna.brunstrom@kau.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tommy Pauly</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Pauly</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tpauly@apple.com">tpauly@apple.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Karl-Johan Grinnemo</span> 
	  <span class="n hidden">
		<span class="family-name">Grinnemo</span>
	  </span>
	</span>
	<span class="org vcardline">Karlstad University</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:karl-johan.grinnemo@kau.se">karl-johan.grinnemo@kau.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tom Jones</span> 
	  <span class="n hidden">
		<span class="family-name">Jones</span>
	  </span>
	</span>
	<span class="org vcardline">University of Aberdeen</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tom@erg.abdn.ac.uk">tom@erg.abdn.ac.uk</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div>

</body>
</html>
