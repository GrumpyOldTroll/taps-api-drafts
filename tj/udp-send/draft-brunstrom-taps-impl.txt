



TAPS Working Group                                     A. Brunstrom, Ed.
Internet-Draft
Intended status: Informational                             T. Pauly, Ed.
Expires: August 25, 2018                                      Apple Inc.
                                                             T. Enghardt
                                                               TU Berlin
                                                           K-J. Grinnemo
                                                     Karlstad University
                                                                T. Jones
                                                  University of Aberdeen
                                                               P. Tiesel
                                                               TU Berlin
                                                              C. Perkins
                                                   University of Glasgow
                                                       February 21, 2018


             Implementing Interfaces to Transport Services
                    draft-brunstrom-taps-impl-latest

Abstract

   The Transport Services architecture [I-D.pauly-taps-arch] defines a
   system that allows applications to use transport networking protocols
   flexibly.  This document serves as a guide to implementation on how
   to build a system that provides such an interface.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on August 25, 2018.








Brunstrom, et al.        Expires August 25, 2018                [Page 1]

Internet-Draft             TAPS Implementation             February 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Implementing Transport Objects  . . . . . . . . . . . . . . .   3
   3.  Implementing Pre-Establishment  . . . . . . . . . . . . . . .   4
     3.1.  Configuration-time errors . . . . . . . . . . . . . . . .   4
     3.2.  Role of system policy . . . . . . . . . . . . . . . . . .   5
   4.  Implementing Connection Establishment . . . . . . . . . . . .   6
     4.1.  Candidate Gathering . . . . . . . . . . . . . . . . . . .   7
       4.1.1.  Structuring Options as a Tree . . . . . . . . . . . .   7
       4.1.2.  Branch Types  . . . . . . . . . . . . . . . . . . . .   8
     4.2.  Branching Order-of-Operations . . . . . . . . . . . . . .  11
     4.3.  Candidate Racing  . . . . . . . . . . . . . . . . . . . .  12
       4.3.1.  Delayed Racing  . . . . . . . . . . . . . . . . . . .  12
       4.3.2.  Failover  . . . . . . . . . . . . . . . . . . . . . .  13
     4.4.  Completing Establishment  . . . . . . . . . . . . . . . .  13
       4.4.1.  Determining Successful Establishment  . . . . . . . .  14
     4.5.  Establishing multiplexed connections  . . . . . . . . . .  15
     4.6.  Handling racing with "unconnected" protocols  . . . . . .  15
     4.7.  Implementing listeners  . . . . . . . . . . . . . . . . .  16
   5.  Implementing Data Transfer  . . . . . . . . . . . . . . . . .  16
     5.1.  Data transfer for streams, datagrams, and frames  . . . .  16
       5.1.1.  Sending content . . . . . . . . . . . . . . . . . . .  16
       5.1.2.  Receiving content . . . . . . . . . . . . . . . . . .  16
     5.2.  Handling of data for fast-open protocols  . . . . . . . .  17
   6.  Implementing Maintenance  . . . . . . . . . . . . . . . . . .  18
     6.1.  Changing Protocol Properties  . . . . . . . . . . . . . .  18
     6.2.  Maintenance Events  . . . . . . . . . . . . . . . . . . .  18
   7.  Implementing Termination  . . . . . . . . . . . . . . . . . .  18
   8.  Cached State  . . . . . . . . . . . . . . . . . . . . . . . .  19
     8.1.  Protocol state caches . . . . . . . . . . . . . . . . . .  20
     8.2.  Performance caches  . . . . . . . . . . . . . . . . . . .  20
   9.  Specific Transport Protocol Considerations  . . . . . . . . .  21



Brunstrom, et al.        Expires August 25, 2018                [Page 2]

Internet-Draft             TAPS Implementation             February 2018


     9.1.  TCP . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
     9.2.  UDP . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
     9.3.  SCTP  . . . . . . . . . . . . . . . . . . . . . . . . . .  21
     9.4.  QUIC  . . . . . . . . . . . . . . . . . . . . . . . . . .  22
     9.5.  HTTP over TLS as a pseudotransport  . . . . . . . . . . .  22
     9.6.  HTTP/2 transport  . . . . . . . . . . . . . . . . . . . .  22
   10. Rendezvous and Environment Discovery  . . . . . . . . . . . .  22
     10.1.  ICE and STUN . . . . . . . . . . . . . . . . . . . . . .  22
   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  22
   12. Security Considerations . . . . . . . . . . . . . . . . . . .  22
     12.1.  Considerations for Candidate Gathering . . . . . . . . .  22
     12.2.  Considerations for Candidate Racing  . . . . . . . . . .  22
   13. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  23
   14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  23
     14.1.  Normative References . . . . . . . . . . . . . . . . . .  23
     14.2.  Informative References . . . . . . . . . . . . . . . . .  23
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  24

1.  Introduction

   The Transport Services architecture [I-D.pauly-taps-arch] defines a
   system that allows applications to use transport networking protocols
   flexibly.  This document serves as a guide to implementation on how
   to build a system that provides such an interface.  The terminology
   used in this document is based on the Architecture.

   The interface exposed to applications is defined as the Transport
   Services API [I-D.trammell-taps-interface].  This API is designed to
   be generic across multiple transport protocols and sets of protocols
   features.  It is the job of an implementation of a Transport Services
   system to turn the requests of an application into decisions on how
   to establish connections, and how to transfer data over those
   connections once established.

2.  Implementing Transport Objects

   What is the basic handle an application interacts with?

   o  A flow of data in either direction

   o  For TCP, one connection is a Connection object

   o  For UDP, one set of fully-specified local and remote endpoints is
      a Connection object

   o  For QUIC, one stream is a Connection object

   o  For SCTP, one stream is a Connection object



Brunstrom, et al.        Expires August 25, 2018                [Page 3]

Internet-Draft             TAPS Implementation             February 2018


3.  Implementing Pre-Establishment

3.1.  Configuration-time errors

   When an application creates a new Connection, it specifies Transport
   Parameters reflecting its preferences regarding Protocol and Path
   Selection.

   The transport system should have a list of supported protocols
   available, which each have Transport Features reflecting the
   capabilities of the protocol.  Once an application specifies
   Transport Paratemeters, the transport system should match the
   required and prohibited properties against the Transport Features of
   the available protocols.

   In the following cases the NewConnection() call should fail
   immediately:

   o  The application requested Transport Parameters which include
      requirements or prohibitions that cannot be satisfied by any of
      the available protocols.  For example, if an application requires
      "Option to configure reliability for individual Content", but no
      such protocol is available on the host running the transport
      system, e.g., because SCTP is not supported by the operating
      system, this should result in an error.

   o  The application requested Transport Parameters which exclude each
      other, i.e., the required and prohibited properties cannot be
      satisfied by the same protocol.  For example, if an application
      prohibits "Reliable Data Transfer" but then requires "Configure
      Reliability per Content", this mismatch should result in an error.

   It is important to fail as early as possible in such cases in order
   to avoid allocating resources, e.g., to endpoint resolution, only to
   find out later that there is no protocol that satisfies the
   requirements.

   [The following probably belongs in later sections.]

   Some errors will only become apparent after Initiate() has been
   called and Candidate Gathering and Racing has started or after it is
   complete.

   In the following cases the Initiate() call should fail or the
   transport system should notify the application with an Error:

   o  During Candidate Gathering, the transport system finds that there
      are no usable Candidates to Race.



Brunstrom, et al.        Expires August 25, 2018                [Page 4]

Internet-Draft             TAPS Implementation             February 2018


   o  During Candidate Racing, the transport system finds that none of
      the configurations that satisfy all requirements given in the
      Transport Parameters actually work over the available paths.

   In the following cases the transport system should notify the
   application with a Warning:

   o  At any point, the application attempts to set a Protocol Property
      which does not apply to the actually chosen protocol.  In this
      case, the transport system should fail gracefully, i.e., give a
      warning to the application, but not terminate the Connection.

3.2.  Role of system policy

   The implementation is responsible for combining and reconciling
   several different sources of protocol and path selection preferences
   when establishing Connections.  These include, but are not
   necessarily limited to:

   1.  Application preferences specified during pre-establishment

   2.  Dynamic system policy

   3.  Default implementation policy

   In general, any protocol or path used for a connection must conform
   to all three sources of constraints.  Any violation of any of the
   layers should cause a protocol or path to be considered ineligble for
   use.  For an example of application preferences leading to
   constraints, an application may prohibit the use of metered network
   interfaces for a given Connection to avoid user cost.  Similarly, the
   system policy at a given time may prohibit the use of such a metered
   network interface from the application's process.  Lastly, the
   implementation itself may default to disallowing certain network
   interfaces unless explicitly requested by the application and allowed
   by the system.

   It is expected that the database of system policies and the method of
   looking up these policies will vary across various platforms.  An
   implementation SHOULD attempt to look up the relevant policies for
   the system in a dynamic way to make sure it is reflecting a fresh
   version of the system policy, since the system's policy regarding the
   application's traffic may change over time due to user or
   administrative changes.







Brunstrom, et al.        Expires August 25, 2018                [Page 5]

Internet-Draft             TAPS Implementation             February 2018


4.  Implementing Connection Establishment

   The process of establishing a network connection begins when an
   application expresses intent to communicate with a remote endpoint
   (along with any constraints or requirements it may have on the
   connection).  The process can be considered complete once there is at
   least one set of network protocols that have completed any required
   setup to the point that it can transmit and receive the application's
   data.

   Connection establishment is divided into two top-level steps:
   Candidate Gathering, to identify the paths, protocols, and endpoints
   to use, and Candidate Racing, in which the necessary protocol
   handshakes are conducted in order to select which set to use.

   The most simple example of this process might involve identifying the
   single IP address to which the implementation wishes to connect,
   using the system's current default interface or path, and starting a
   TCP handshake to establish a stream to the specified IP address.
   However, each step may also vary depending on the requirements of the
   connection: if the endpoint is defined as a hostname and port, then
   there may be multiple resolved addresses that are available; there
   may also be multiple interfaces or paths available, other than the
   default system interface; and some protocols may not need any
   transport handshake to be considered "established" (such as UDP),
   while other connections may utilize layered protocol handshakes, such
   as TLS over TCP.

   Whenever an implementation has multiple options for connection
   establishment, it can view the set of all individual connection
   establishment options as a single, aggregate connection
   establishment.  The aggregate set conceptually includes every valid
   combination of endpoints, paths, and protocols.  As an example,
   consider an implementation that initiates a TCP connection to a
   hostname + port endpoint, and has two valid interfaces available (Wi-
   Fi and LTE).  The hostname resolves to a single IPv4 address on the
   Wi-Fi network, and resolves to the same IPv4 address on the LTE
   network, as well as a single IPv6 address.  The aggregate set of
   connection establishment options can be viewed as follows:

Aggregate [Endpoint: www.example.com:80] [Interface: Any]   [Protocol: TCP]
|-> [Endpoint: 192.0.2.1:80]       [Interface: Wi-Fi] [Protocol: TCP]
|-> [Endpoint: 192.0.2.1:80]       [Interface: LTE]   [Protocol: TCP]
|-> [Endpoint: 2001:DB8::1.80]     [Interface: LTE]   [Protocol: TCP]

   Any one of these sub-entries on the aggregate connection attempt
   would satisfy the original application intent.  The concern of this




Brunstrom, et al.        Expires August 25, 2018                [Page 6]

Internet-Draft             TAPS Implementation             February 2018


   document is the algorithm defining which of these options to try,
   when, and in what order.

4.1.  Candidate Gathering

   The step of gathering candidates involves identifying which paths,
   protocols, and endpoints may be used for a given Connection.  This
   list is determined by the requirements, prohibitions, and preferences
   of the application as specified in the Path Selection Properties and
   Protocol Selection Properties.

4.1.1.  Structuring Options as a Tree

   When an implementation responsible for connection establishment needs
   to consider multiple options, it SHOULD logically structure these
   options as a hierarchical tree.  Each leaf node of the tree
   represents a single, coherent connection attempt, with an Endpoint, a
   Path, and a set of protocols that can directly negotiate and send
   data on the network.  Each node in the tree that is not a leaf
   represents a connection attempt that is either underspecified, or
   else includes multiple distinct options.  For example. when
   connecting on an IP network, a connection attempt to a hostname and
   port is underspecified, because the connection attempt requires a
   resolved IP address as its remote endpoint.  In this case, the node
   represented by the connection attempt to the hostname is a parent
   node, with child nodes for each IP address.  Similarly, an
   implementation that is allowed to connect using multiple interfaces
   will have a parent node of the tree for the decision between the
   paths, with a branch for each interface.

   The example aggregate connection attempt above can be drawn as a tree
   by grouping the addresses resolved on the same interface into
   branches:

                             ||
                +==========================+
                |  www.example.com:80/Any  |
                +==========================+
                  //                    \\
+==========================+       +==========================+
| www.example.com:80/Wi-Fi |       |  www.example.com:80/LTE  |
+==========================+       +==========================+
             ||                      //                    \\
  +====================+  +====================+  +======================+
  | 192.0.2.1:80/Wi-Fi |  |  192.0.2.1:80/LTE  |  |  2001:DB8::1.80/LTE  |
  +====================+  +====================+  +======================+





Brunstrom, et al.        Expires August 25, 2018                [Page 7]

Internet-Draft             TAPS Implementation             February 2018


   The rest of this section will use a notation scheme to represent this
   tree.  The parent (or trunk) node of the tree will be represented by
   a single integer, such as "1".  Each child of that node will have an
   integer that identifies it, from 1 to the number of children.  That
   child node will be uniquely identified by concatenating its integer
   to it's parents identifier with a dot in between, such as "1.1" and
   "1.2".  Each node will be summarized by a tuple of three elements:
   Endpoint, Path, and Protocol.  The above example can now be written
   more succinctly as:

   1 [www.example.com:80, Any, TCP]
     1.1 [www.example.com:80, Wi-Fi, TCP]
       1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
     1.2 [www.example.com:80, LTE, TCP]
       1.2.1 [192.0.2.1:80, LTE, TCP]
       1.2.2 [2001:DB8::1.80, LTE, TCP]

   When an implementation views this aggregate set of connection
   attempts as a single connection establishment, it only will use one
   of the leaf nodes to transfer data.  Thus, when a single leaf node
   becomes ready to use, then the entire connection attempt is ready to
   use by the application.  Another way to represent this is that every
   leaf node updates the state of its parent node when it becomes ready,
   until the trunk node of the tree is ready, which then notifies the
   application that the connection as a whole is ready to use.

   A connection establishment tree may be degenerate, and only have a
   single leaf node, such as a connection attempt to an IP address over
   a single interface with a single protocol.

   1 [192.0.2.1:80, Wi-Fi, TCP]

   A parent node may also only have one child (or leaf) node, such as a
   when a hostname resolves to only a single IP address.

   1 [www.example.com:80, Wi-Fi, TCP]
     1.1 [192.0.2.1:80, Wi-Fi, TCP]

4.1.2.  Branch Types

   There are three types of branching from a parent node into one or
   more child nodes.  Any parent node of the tree MUST only use one type
   of branching.








Brunstrom, et al.        Expires August 25, 2018                [Page 8]

Internet-Draft             TAPS Implementation             February 2018


4.1.2.1.  Derived Endpoints

   If a connection originally targets a single endpoint, there may be
   multiple endpoints of different types that can be derived from the
   original.  The connection library should order the derived endpoints
   according to application preference and expected performance.

   DNS hostname-to-address resolution is the most common method of
   endpoint derivation.  When trying to connect to a hostname endpoint
   on a traditional IP network, the implementation SHOULD send DNS
   queries for both A (IPv4) and AAAA (IPv6) records if both are
   supported on the local link.  The algorithm for ordering and racing
   these addresses SHOULD follow the recommendations in Happy Eyeballs
   [RFC8305].

   1 [www.example.com:80, Wi-Fi, TCP]
     1.1 [2001:DB8::1.80, Wi-Fi, TCP]
     1.2 [192.0.2.1:80, Wi-Fi, TCP]
     1.3 [2001:DB8::2.80, Wi-Fi, TCP]
     1.4 [2001:DB8::3.80, Wi-Fi, TCP]

   DNS-Based Service Discovery can also provide an endpoint derivation
   step.  When trying to connect to a named service, the client may
   discover one or more hostname and port pairs on the local network
   using multicast DNS.  These hostnames should each be treated as a
   branch which can be attempted independently from other hostnames.
   Each of these hostnames may also resolve to one or more addresses,
   thus creating multiple layers of branching.

   1 [term-printer._ipp._tcp.meeting.ietf.org, Wi-Fi, TCP]
     1.1 [term-printer.meeting.ietf.org:631, Wi-Fi, TCP]
       1.1.1 [31.133.160.18.631, Wi-Fi, TCP]

4.1.2.2.  Alternate Paths

   If a client has multiple network interfaces available to it, such as
   mobile client with both Wi-Fi and Cellular connectivity, it can
   attempt a connection over either interface.  This represents a branch
   point in the connection establishment.  Like with derived endpoints,
   the interfaces should be ranked based on preference, system policy,
   and performance.  Attempts should be started on one interface, and
   then on other interfaces successively after delays based on expected
   round-trip-time or other available metrics.

   1 [192.0.2.1:80, Any, TCP]
     1.1 [192.0.2.1:80, Wi-Fi, TCP]
     1.2 [192.0.2.1:80, LTE, TCP]




Brunstrom, et al.        Expires August 25, 2018                [Page 9]

Internet-Draft             TAPS Implementation             February 2018


   This same approach applies to any situation in which the client is
   aware of multiple links or views of the network.  Multiple Paths,
   each with a coherent set of addresses, routes, DNS server, and more,
   may share a single interface.  A path may also represent a virtual
   interface service such as a Virtual Private Network (VPN).

   The list of available paths should be constrained by any requirements
   or prohibitions the application sets, as well as system policy.

4.1.2.3.  Protocol Options

   Differences in possible protocol compositions and options can also
   provide a branching point in connection establishment.  This allows
   clients to be resilient to situations in which a certain protocol is
   not functioning on a server or network.

   This approach is commonly used for connections with optional proxy
   server configurations.  A single connection may be allowed to use an
   HTTP-based proxy, a SOCKS-based proxy, or connect directly.  These
   options should be ranked and attempted in succession.

   1 [www.example.com:80, Any, HTTP/TCP]
     1.1 [192.0.2.8:80, Any, HTTP/HTTP Proxy/TCP]
     1.2 [192.0.2.7:10234, Any, HTTP/SOCKS/TCP]
     1.3 [www.example.com:80, Any, HTTP/TCP]
       1.3.1 [192.0.2.1:80, Any, HTTP/TCP]

   This approach also allows a client to attempt different sets of
   application and transport protocols that may provide preferable
   characteristics when available.  For example, the protocol options
   could involve QUIC [I-D.ietf-quic-transport] over UDP on one branch,
   and HTTP/2 [RFC7540] over TLS over TCP on the other:

   1 [www.example.com:443, Any, Any HTTP]
     1.1 [www.example.com:443, Any, QUIC/UDP]
       1.1.1 [192.0.2.1:443, Any, QUIC/UDP]
     1.2 [www.example.com:443, Any, HTTP2/TLS/TCP]
       1.2.1 [192.0.2.1:443, Any, HTTP2/TLS/TCP]

   Another example is racing SCTP with TCP:

   1 [www.example.com:80, Any, Any Stream]
     1.1 [www.example.com:80, Any, SCTP]
       1.1.1 [192.0.2.1:80, Any, SCTP]
     1.2 [www.example.com:80, Any, TCP]
       1.2.1 [192.0.2.1:80, Any, TCP]





Brunstrom, et al.        Expires August 25, 2018               [Page 10]

Internet-Draft             TAPS Implementation             February 2018


   Implementations that support racing protocols and protocol options
   SHOULD maintain a history of which protocols and protocol options
   successfully established, on a per-network basis.  This information
   can influence future racing decisions to prioritize or prune
   branches.

4.2.  Branching Order-of-Operations

   Branch types must occur in a specific order relative to one another
   to avoid creating leaf nodes with invalid or incompatible settings.
   In the example above, it would be invalid to branch for derived
   endpoints (the DNS results for www.example.com) before branching
   between interface paths, since usable DNS results on one network may
   not necessarily be the same as DNS results on another network due to
   local network entities, supported address families, or enterprise
   network configurations.  Implementations must be careful to branch in
   an order that results in usable leaf nodes whenever there are
   multiple branch types that could be used from a single node.

   The order of operations for branching, where lower numbers are acted
   upon first, SHOULD be:

   1.  Alternate Paths

   2.  Protocol Options

   3.  Derived Endpoints

   Branching between paths is the first in the list because results
   across multiple interfaces are likely not related to one another:
   endpoint resolution may return different results, especially when
   using locally resolved host and service names, and which protocols
   are supported and preferred may differ across interfaces.  Thus, if
   multiple paths are attempted, the overall connection can be seen as a
   race between the available paths or interfaces.

   Protocol options are checked next in order.  Whether or not a set of
   protocol, or protocol-specific options, can successfully connect is
   generally not dependent on which specific IP address is used.
   Furthermore, the protocol stacks being attempted may influence or
   altogether change the endpoints being used.  Adding a proxy to a
   connection's branch will change the endpoint to the proxy's IP
   address or hostname.  Choosing an alternate protocol may also modify
   the ports that should be selected.

   Branching for derived endpoints is the final step, and may have
   multiple layers of derivation or resolution, such as DNS service
   resolution and DNS hostname resolution.



Brunstrom, et al.        Expires August 25, 2018               [Page 11]

Internet-Draft             TAPS Implementation             February 2018


4.3.  Candidate Racing

   The primary goal of the Candidate Racing process is to successfully
   negotiate a protocol stack to an endpoint over an interface--to
   connect a single leaf node of the tree--with as little delay and as
   few unnecessary connections attempts as possible.  Optimizing these
   two factors improves the user experience, while minimizing network
   load.

   This section covers the dynamic aspect of connection establishment.
   While the tree described above is a useful conceptual and
   architectural model, an implementation does not know what the full
   tree may become up front, nor will many of the possible branches be
   used in the common case.

   There are three different approaches to racing the attempts for
   different nodes of the connection establishment tree:

   1.  Immediate

   2.  Delayed

   3.  Failover

   Each approach is appropriate in different use-cases and branch types.
   However, to avoid consuming unnecessary network resources,
   implementations SHOULD NOT use immediate racing as a default
   approach.

   The timing algorithms for racing SHOULD remain independent across
   branches of the tree.  Any timers or racing logic is isolated to a
   given parent node, and is not ordered precisely with regards to other
   children of other nodes.

4.3.1.  Delayed Racing

   Delayed racing can be used whenever a single node of the tree has
   multiple child nodes.  Based on the order determined when building
   the tree, the first child node will be initiated immediately,
   followed by the next child node after some delay.  Once that second
   child node is initiated, the third child node (if present) will begin
   after another delay, and so on until all child nodes have been
   initiated, or one of the child nodes successfully completes its
   negotiation.

   Delayed racing attempts occur in parallel.  Implementations SHOULD
   NOT terminate an earlier child connection attempt upon starting a
   secondary child.



Brunstrom, et al.        Expires August 25, 2018               [Page 12]

Internet-Draft             TAPS Implementation             February 2018


   The delay between starting child nodes SHOULD be based on the
   properties of the previously started child node.  For example, if the
   first child represents an IP address with a known route, and the
   second child represents another IP address, the delay between
   starting the first and second IP addresses can be based on the
   expected retransmission cadence for the first child's connection
   (derived from historical round-trip-time).  Alternatively, if the
   first child represents a branch on a Wi-Fi interface, and the second
   child represents a branch on an LTE interface, the delay should be
   based on the expected time in which the branch for the first
   interface would be able to establish a connection, based on link
   quality and historical round-trip-time.

   Any delay SHOULD have a defined minimum and maximum value based on
   the branch type.  Generally, branches between paths and protocols
   should have longer delays than branches between derived endpoints.
   The maximum delay should be considered with regards to how long a
   user is expected to wait for the connection to complete.

   If a child node fails to connect before the delay timer has fired for
   the next child, the next child SHOULD be started immediately.

4.3.2.  Failover

   If an implementation or application has a strong preference for one
   branch over another, the branching node may choose to wait until one
   child has failed before starting the next.  Failure of a leaf node is
   determined by its protocol negotiation failing or timing out; failure
   of a parent branching node is determined by all of its children
   failing.

   An example in which failover is recommended is a race between a
   protocol stack that uses a proxy and a protocol stack that bypasses
   the proxy.  Failover is useful in case the proxy is down or
   misconfigured, but any more aggressive type of racing may end up
   unnecessarily avoiding a proxy that was preferred by policy.

4.4.  Completing Establishment

   The process of connection establishment completes when one leaf node
   of the tree has completed negotiation with the remote endpoint
   successfully, or else all nodes of the tree have failed to connect.
   The first leaf node to complete its connection is then used by the
   application to send and receive data.

   It is useful to process success and failure throughout the tree by
   child nodes reporting to their parent nodes (towards the trunk of the
   tree).  For example, in the following case, if 1.1.1 fails to



Brunstrom, et al.        Expires August 25, 2018               [Page 13]

Internet-Draft             TAPS Implementation             February 2018


   connect, it reports the failure to 1.1.  Since 1.1 has no other child
   nodes, it also has failed and reports that failure to 1.  Because 1.2
   has not yet failed, 1 is not considered to have failed.  Since 1.2
   has not yet started, it is started and the process continues.
   Similarly, if 1.1.1 successfully connects, then it marks 1.1 as
   connected, which propagates to the trunk node 1.  At this point, the
   connection as a whole is considered to be successfully connected and
   ready to process application data

   1 [www.example.com:80, Any, TCP]
     1.1 [www.example.com:80, Wi-Fi, TCP]
       1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
     1.2 [www.example.com:80, LTE, TCP]
   ...

   If a leaf node has successfully completed its connection, all other
   attempts SHOULD be made ineligible for use by the application for the
   original request.  New connection attempts that involve transmitting
   data on the network SHOULD NOT be started after another leaf node has
   completed successfully, as the connection as a whole has been
   established.  An implementation MAY choose to let certain handshakes
   and negotiations complete in order to gather metrics to influence
   future connections.  Similarly, an implementation MAY choose to hold
   onto fully established leaf nodes that were not the first to
   establish for use in future connections, but this approach is not
   recommended since those attempts were slower to connect and may
   exhibit less desirable properties.

4.4.1.  Determining Successful Establishment

   Implementations may select the criteria by which a leaf node is
   considered to be successfully connected differently on a per-protocol
   basis.  If the only protocol being used is a transport protocol with
   a clear handshake, like TCP, then the obvious choice is to declare
   that node "connected" when the last packet of the three-way handshake
   has been received.  If the only protocol being used is an
   "unconnected" protocol, like UDP, the implementation may consider the
   node fully "connected" the moment it determines a route is present,
   before sending any packets on the network Section 4.6.

   For protocol stacks with multiple handshakes, the decision becomes
   more nuanced.  If the protocol stack involves both TLS and TCP, an
   implementation MAY determine that a leaf node is connected after the
   TCP handshake is complete, or it MAY wait for the TLS handshake to
   complete as well.  The benefit of declaring completion when the TCP
   handshake finishes, and thus stopping the race for other branches of
   the tree, is that there will be less burden on the network from other
   connection attempts.  On the other hand, by waiting until the TLS



Brunstrom, et al.        Expires August 25, 2018               [Page 14]

Internet-Draft             TAPS Implementation             February 2018


   handshake is complete, an implementation avoids the scenario in which
   a TCP handshake completes quickly, but TLS negotiation is either very
   slow or fails altogether in particular network conditions or to a
   particular endpoint.

4.5.  Establishing multiplexed connections

   Multiplexing data streams over a connection of a single transport
   Protocol Instance requires, at minimum, two things: 1) the transport
   Protocol Instance must be able to know the beginning and the end of
   messages, in order to know what to assign and multiplex /
   demultiplex; 2) there must be an identifier that allows to decide
   which stream a message is assigned to.  When a new stream is
   multiplexed on an already existing connection, there is no need for a
   connection establishment procedure - every stream can be assumed to
   immediately be available.

   When the Connections that are offered to an application by the
   Transport System are multiplexed, the Transport System may implement
   the establishment of a new Connection by simply beginning to use a
   new stream of an already established transport connection.  This,
   then, means that there may not be any "establishment" message (like a
   TCP SYN), but the application can simply start sending or receiving.
   Therefore, when a Transport System's "Initiate" Action is called
   without Content being handed over, it cannot be guaranteed that the
   other endpoint will have any way to know about this, and hence a
   passive endpoint's ConnectionReceived event may not be called upon an
   active endpoint's Inititate.  Instead, calling the ConnectionReceived
   event may be delayed until the first Content arrives.

4.6.  Handling racing with "unconnected" protocols

   While protocols that use an explicit handshake to validate a
   Connection to a peer can be used for racing multiple establishment
   attempts in parallel, "unconnected" protocols such as raw UDP do not
   offer a way to validate the presence of a peer or the usability of a
   Connection without application feedback.  An implementation SHOULD
   consider such a protocol stack to be established as soon as a local
   route to the peer endpoint is confirmed.

   However, if a peer is not reachable over the network using the
   unconnected protocol, or content cannot be exchanged for any other
   reason, the application may want to attempt using another candidate
   Protocol Stack.  The implementation SHOULD maintain the list of other
   candidate Protocol Stacks that were eligible to use.  In the case
   that the application signals that the initial Protocol Stack is
   failing for some reason and that another option should be attempted,
   the Connection can be updated to point to the next candidate Protocol



Brunstrom, et al.        Expires August 25, 2018               [Page 15]

Internet-Draft             TAPS Implementation             February 2018


   Stack.  This can be viewed as an application-driven form of Protocol
   Stack racing.

4.7.  Implementing listeners

   How to passively wait for incoming connections, and what that means
   for protocols with and without handshakes.

5.  Implementing Data Transfer

5.1.  Data transfer for streams, datagrams, and frames

5.1.1.  Sending content

   How to handle sending data onto examples like TCP, UDP, and a basic
   Length-Value protocol.

   How to handle and notify errors when sending.

5.1.1.1.  Sending content with UDP

   The UDP Send Primitives described in section 3.1 of [RFC8304] allow
   applications to send data with either an explicit destination for
   each packet or the option to bind the destination address for each
   send call to a single host.  The UDP send primitive also offers
   applications the ability to set a range of IP options which are
   required to build applications that can use the network effectivly.
   Implementation MUST expose these mechanisms or provide services to
   implement their transport features.

   Implementations should consider the advice in the UDP Usage Guidlines
   (RFC8085) and create a 'connect' style for each UDP Connection
   object.

5.1.1.2.  Send Completion

   How to determine when a send is effectively complete

5.1.1.3.  Batching Sends

   Improve efficiency by handling multiple send operations at once for
   datagram or frame based protocols

5.1.2.  Receiving content

   How to handle sending data in examples like TCP, UDP, and a basic
   Length-Value protocol.




Brunstrom, et al.        Expires August 25, 2018               [Page 16]

Internet-Draft             TAPS Implementation             February 2018


   Waiting for frame boundaries when necessary.

   How to handle and notify errors when receiving.

5.2.  Handling of data for fast-open protocols

   Several protocols allow sending higher-level protocol or application
   data within the first packet of their protocol establishment, such as
   TCP Fast Open [RFC7413] and TLS 1.3 [I-D.ietf-tls-tls13].  This
   approach is referred to as sending Zero-RTT (0-RTT) data.  This is a
   desirable property, but poses challenges to an implementation that
   uses racing during connection establishment.

   If the application has 0-RTT data to send in any protocol handshakes,
   it needs to provide this data before the handshakes have begun.  When
   racing, this means that the data SHOULD be provided before the
   process of connection establishment has begun.  If the API allows the
   application to send 0-RTT data, it MUST provide an interface that
   identifies this data as idempotent data.  In general, 0-RTT data may
   be replayed (for example, if a TCP SYN contains data, and the SYN is
   retransmitted, the data will be retransmitted as well), but racing
   means that different leaf nodes have the opportunity to send the same
   data independently.  If data is truly idempotent, this should be
   permissible.

   Once the application has provided its 0-RTT data, an implementation
   SHOULD keep a copy of this data and provide it to each new leaf node
   that is started and for which a 0-RTT protocol is being used.

   It is also possible that protocol stacks within a particular leaf
   node use 0-RTT handshakes without any idempotent application data.
   For example, TCP Fast Open could use a Client Hello from a TLS as its
   0-RTT data, shortening the cumulative handshake time.

   0-RTT handshakes often rely on previous state, such as TCP Fast Open
   cookies, previously established TLS tickets, or out-of-band
   distributed pre-shared keys (PSKs).  Implementations should be aware
   of security concerns around using these tokens across multiple
   addresses or paths when racing.  In the case of TLS, any given ticket
   or PSK SHOULD only be used on one leaf node.  If implementations have
   multiple tickets available from a previous connection, each leaf node
   attempt MUST use a different ticket.  In effect, each leaf node will
   send the same early application data, yet encoded (encrypted)
   differently on the wire.







Brunstrom, et al.        Expires August 25, 2018               [Page 17]

Internet-Draft             TAPS Implementation             February 2018


6.  Implementing Maintenance

6.1.  Changing Protocol Properties

   Appendix A.1 of [I-D.ietf-taps-minset] explains, using primitives
   that are described in [RFC8303] and [RFC8304], how to implement
   changing the following protocol properties of an established
   connection with the TCP and UDP.  Below, we amend this description
   for other protocols (if applicable): * Set timeout for aborting
   Connection: for SCTP, this can be done using the primitive
   CHANGE_TIMEOUT.SCTP described in section 4 of [RFC8303].  * Set
   timeout to suggest to the peer * Set retransmissions before
   "Excessive Retransmissions" * Set required minimum coverage of the
   checksum for receiving: for UDP-Lite, this can be done using the
   primitive SET_MIN_CHECKSUM_COVERAGE.UDP-Lite described in section 4
   of [RFC8303].  * Set scheduler for connections in a group: for SCTP,
   this can be done using the primitive SET_STREAM_SCHEDULER.SCTP
   described in section 4 of [RFC8303].  * Set priority for a connection
   in a group: for SCTP, this can be done using the primitive
   CONFIGURE_STREAM_SCHEDULER.SCTP described in section 4 of [RFC8303].

6.2.  Maintenance Events

   Implications of a network change on a protocol

   o  Multipath or migratable protocols

   o  Single-path protocols

   Quality changes

7.  Implementing Termination

   How to handle termination requested by application:

   o  How gracefully to tear down at various protocol layers

   With TCP, when an application closes a connection, this means that it
   has no more data to send (but expects all data that has been handed
   over to be reliably delivered).  However, with TCP only, "close" does
   not mean that the application will stop receiving data.  This is
   related to TCP's ability to support half-closed connections.

   SCTP is an example of a protocol that does not support such half-
   closed connections.  Hence, with SCTP, the meaning of "close" is
   stricter: an application has no more data to send (but expects all
   data that has been handed over to be reliably delivered), and will
   also not receive any more data.



Brunstrom, et al.        Expires August 25, 2018               [Page 18]

Internet-Draft             TAPS Implementation             February 2018


   Implementing a protocol independent transport system means that the
   exposed semantics must be the strictest subset of the semantics of
   all supported protocols.  Hence, as is common with all reliable
   transport protocols, after a Close action, the application can expect
   to have its reliability requirements honored regarding the data it
   has given to the Transport System - but it cannot expect to be able
   to read any more data after calling Close.

   Abort differs from Close only in that no guarantees are given
   regarding data that the application has handed over to the Tranport
   System before calling Abort.

   o  How much to tear down for multiplexed protocols, or protocols
      capable of multiplexing

   As explained in section Section 4.5, when a new stream is multiplexed
   on an already existing connection of a Transport Protocol Instance,
   there is no need for a connection establishment procedure.  Because
   the Connections that are offered by the Transport System can be
   implemented as streams that are multiplexed on a transport protocol's
   connection, it can therefore not be guaranteed that one Endpoint's
   Initiate action provokes a ConnectionReceived event at its peer.

   For Close (provoking a Finished event) and Abort (provoking a
   ConnectionError event), the same logic applies: while it is desirable
   to be informed when a peer closes or aborts a Connection, whether
   this is possible depends on the underlying protocol, and no
   guarantees can be given.  With SCTP, the transport system can use the
   stream reset procedure to cause a Finish event upon a Close action
   from the peer [NEAT-flow-mapping].

   How to handle a failure generated by protocols

8.  Cached State

   Beyond a single Connection's lifetime, it is useful for an
   implementation to keep state and history.  This cached state can help
   improve future Connection establishment due to re-using results and
   credentials, and favoring paths and protocols that performed well in
   the past.

   Cached state may be associated with different Endpoints for the same
   Connection, depending on the protocol generating the cached content.
   For example, certificates for TLS are generally associated with a
   hostname, and thus should be cached based on a Connection's hostname
   Endpoint (if applicable).  On the other hand, performance
   characteristics of a path are more likely tied to the IP address and
   subnet being used.



Brunstrom, et al.        Expires August 25, 2018               [Page 19]

Internet-Draft             TAPS Implementation             February 2018


8.1.  Protocol state caches

   Some protocols will have long-term state to be cached in association
   with Endpoints.  This state often has some time after which it is
   expired, so the implementation SHOULD allow each protocol to specify
   an expiration for cached content.

   Examples of cached protocol state include:

   o  The DNS protocol can cache resolution answers (A and AAAA queries,
      for example), associated with a Time To Live (TTL) to be used for
      future hostname resolutions without requiring asking the DNS
      resolver again.

   o  TLS caches session state and tickets based on a hostname, which
      can be used for resuming sessions with a server.

   o  TCP can cache cookies for use in TCP Fast Open

   Cached state is primarily used during Connection establishment for a
   single Protocol Stack, but may be used to influence an
   implementation's preference between several candidate Protocol
   Stacks.  For example, if two IP address Endpoints are otherwise
   equally preferred, an implementation may choose to attempt a
   connection to an address for which it has a TCP Fast Open cookie.

8.2.  Performance caches

   In addition to protocol state, Protocol Instances SHOULD provide data
   into a performance-oriented cache to help guide future protocol and
   path selection.  Some performance information can be gathered
   generically across several protocols to allow predictive comparisons
   between protocols on given paths:

   o  Observed Round Trip Time

   o  Connection Establishment latency

   o  Connection Establishment success rate

   These items can be cached on a per-address and per-subnet
   granularity, and averaged between different values.  The information
   SHOULD be cached on a per-network basis, since it is expected that
   different network attachments will have different performance
   characteristics.

   An implementation should use this information, when possible, to
   determine preference between candidate paths, endpoints, and protocol



Brunstrom, et al.        Expires August 25, 2018               [Page 20]

Internet-Draft             TAPS Implementation             February 2018


   options.  Eligible options that historically had significantly better
   performance than others SHOULD be selected first when gathering
   candidates Section 4.1 to ensure better performance for the
   application.

9.  Specific Transport Protocol Considerations

9.1.  TCP

9.2.  UDP

9.3.  SCTP

   To support sender-side stream schedulers (which are implemented on
   the sender side), a receiver-side Transport System should always
   support message interleaving [RFC8260].

   SCTP messages can be very large.  To allow the reception of large
   messages in pieces, a "partial flag" can be used to inform a (native
   SCTP) receiving application that a message is incomplete.  After
   receiving the "partial flag", this application would know that the
   next receive calls will only deliver remaining parts of the same
   message (i.e., no messages or partial messages will arrive on other
   streams until the message is complete) (see Section 8.1.20 in
   [RFC6458]).  The "partial flag" can therefore facilitate the
   implementation of the receiver buffer in the receiving application,
   at the cost of limiting multiplexing and temporarily creating head-
   of-line blocking delay at the receiver.

   When a Transport System transfers Content, it seems natural to map
   Content to SCTP messages in order to support properties such as
   "Ordered" or "Lifetime" (which maps onto partially reliable delivery
   with a SCTP_PR_SCTP_TTL policy [RFC6458]).  However, since
   multiplexing of Connections onto SCTP streams may happen, and would
   be hidden from the application, the Transport System requires a per-
   stream receiver buffer anyway, so this potential benefit is lost and
   the "partial flag" becomes unnecessary for the system.

   The problem of long messages either requiring large receiver-side
   buffers or getting in the way of multiplexing is addressed by message
   interleaving [RFC8260], which is yet another reason why a receivers-
   side transport system supporting SCTP should implement this
   mechanism.








Brunstrom, et al.        Expires August 25, 2018               [Page 21]

Internet-Draft             TAPS Implementation             February 2018


9.4.  QUIC

9.5.  HTTP over TLS as a pseudotransport

9.6.  HTTP/2 transport

10.  Rendezvous and Environment Discovery

10.1.  ICE and STUN

11.  IANA Considerations

   RFC-EDITOR: Please remove this section before publication.

   This document has no actions for IANA.

12.  Security Considerations

12.1.  Considerations for Candidate Gathering

   Implementations should avoid downgrade attacks that allow network
   interference to cause the implementation to select less secure, or
   entirely insecure, combinations of paths and protocols.

12.2.  Considerations for Candidate Racing

   See Section 5.2 for security considerations around racing with 0-RTT
   data.

   An attacker that knows a particular device is racing several options
   during connection establishment may be able to block packets for the
   first connection attempt, thus inducing the device to fall back to a
   secondary attempt.  This is a problem if the secondary attempts have
   worse security properties that enable further attacks.
   Implementations should ensure that all options have equivalent
   security properties to avoid incentivizing attacks.

   Since results from the network can determine how a connection attempt
   tree is built, such as when DNS returns a list of resolved endpoints,
   it is possible for the network to cause an implementation to consume
   significant on-device resources.  Implementations SHOULD limit the
   maximum amount of state allowed for any given node, including the
   number of child nodes, especially when the state is based on results
   from the network.







Brunstrom, et al.        Expires August 25, 2018               [Page 22]

Internet-Draft             TAPS Implementation             February 2018


13.  Acknowledgements

   This work has received funding from the European Union's Horizon 2020
   research and innovation programme under grant agreement No. 644334
   (NEAT).

   This work has been supported by Leibniz Prize project funds of DFG -
   German Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ
   FE 570/4-1).

   Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric
   Kinnear for their implementation and design efforts, including Happy
   Eyeballs, that heavily influenced this work.

14.  References

14.1.  Normative References

   [I-D.ietf-taps-minset]
              Welzl, M. and S. Gjessing, "A Minimal Set of Transport
              Services for TAPS Systems", draft-ietf-taps-minset-01
              (work in progress), February 2018.

   [I-D.pauly-taps-arch]
              "An Architecture for Transport Services", n.d..

   [I-D.trammell-taps-interface]
              "An Abstract Application Layer Interface to Transport
              Services", n.d..

14.2.  Informative References

   [I-D.ietf-quic-transport]
              Iyengar, J. and M. Thomson, "QUIC: A UDP-Based Multiplexed
              and Secure Transport", draft-ietf-quic-transport-09 (work
              in progress), January 2018.

   [I-D.ietf-tls-tls13]
              Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", draft-ietf-tls-tls13-24 (work in progress),
              February 2018.

   [NEAT-flow-mapping]
              "Transparent Flow Mapping for NEAT (in Workshop on Future
              of Internet Transport (FIT 2017))", n.d..






Brunstrom, et al.        Expires August 25, 2018               [Page 23]

Internet-Draft             TAPS Implementation             February 2018


   [RFC6458]  Stewart, R., Tuexen, M., Poon, K., Lei, P., and V.
              Yasevich, "Sockets API Extensions for the Stream Control
              Transmission Protocol (SCTP)", RFC 6458,
              DOI 10.17487/RFC6458, December 2011,
              <https://www.rfc-editor.org/info/rfc6458>.

   [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, "TCP
              Fast Open", RFC 7413, DOI 10.17487/RFC7413, December 2014,
              <https://www.rfc-editor.org/info/rfc7413>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

   [RFC8260]  Stewart, R., Tuexen, M., Loreto, S., and R. Seggelmann,
              "Stream Schedulers and User Message Interleaving for the
              Stream Control Transmission Protocol", RFC 8260,
              DOI 10.17487/RFC8260, November 2017,
              <https://www.rfc-editor.org/info/rfc8260>.

   [RFC8303]  Welzl, M., Tuexen, M., and N. Khademi, "On the Usage of
              Transport Features Provided by IETF Transport Protocols",
              RFC 8303, DOI 10.17487/RFC8303, February 2018,
              <https://www.rfc-editor.org/info/rfc8303>.

   [RFC8304]  Fairhurst, G. and T. Jones, "Transport Features of the
              User Datagram Protocol (UDP) and Lightweight UDP (UDP-
              Lite)", RFC 8304, DOI 10.17487/RFC8304, February 2018,
              <https://www.rfc-editor.org/info/rfc8304>.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https://www.rfc-editor.org/info/rfc8305>.

Authors' Addresses

   Anna Brunstrom (editor)

   Email: anna.brunstrom@kau.se










Brunstrom, et al.        Expires August 25, 2018               [Page 24]

Internet-Draft             TAPS Implementation             February 2018


   Tommy Pauly (editor)
   Apple Inc.
   1 Infinite Loop
   Cupertino, California 95014
   United States of America

   Email: tpauly@apple.com


   Theresa Enghardt
   TU Berlin
   Marchstrasse 23
   10587 Berlin
   Germany

   Email: theresa@inet.tu-berlin.de


   Karl-Johan Grinnemo
   Karlstad University

   Email: karl-johan.grinnemo@kau.se


   Tom Jones
   University of Aberdeen

   Email: tom@erg.abdn.ac.uk


   Philipp S. Tiesel
   TU Berlin
   Marchstrasse 23
   10587 Berlin
   Germany

   Email: philipp@inet.tu-berlin.de


   Colin Perkins
   University of Glasgow
   School of Computing Science
   Glasgow  G12 8QQ
   United Kingdom

   Email: csp@csperkins.org





Brunstrom, et al.        Expires August 25, 2018               [Page 25]
