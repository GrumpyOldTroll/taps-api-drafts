<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.6 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-brunstrom-taps-impl-latest" category="info">

  <front>
    <title abbrev="TAPS Implementation">Implementing Interfaces to Transport Services</title>

    <author initials="A." surname="Brunstrom" fullname="Anna Brunstrom" role="editor">
      <organization></organization>
      <address>
        <email>anna.brunstrom@kau.se</email>
      </address>
    </author>
    <author initials="T." surname="Pauly" fullname="Tommy Pauly" role="editor">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino, California 95014</city>
          <country>United States of America</country>
        </postal>
        <email>tpauly@apple.com</email>
      </address>
    </author>
    <author initials="T." surname="Enghardt" fullname="Theresa Enghardt">
      <organization>TU Berlin</organization>
      <address>
        <postal>
          <street>Marchstraße 23</street>
          <city>10587 Berlin</city>
          <country>Germany</country>
        </postal>
        <email>theresa@inet.tu-berlin.de</email>
      </address>
    </author>
    <author initials="K-J." surname="Grinnemo" fullname="Karl-Johan Grinnemo">
      <organization>Karlstad University</organization>
      <address>
        <email>karl-johan.grinnemo@kau.se</email>
      </address>
    </author>
    <author initials="T." surname="Jones" fullname="Tom Jones">
      <organization>University of Aberdeen</organization>
      <address>
        <email>tom@erg.abdn.ac.uk</email>
      </address>
    </author>
    <author initials="P." surname="Tiesel" fullname="Philipp S. Tiesel">
      <organization>TU Berlin</organization>
      <address>
        <postal>
          <street>Marchstraße 23</street>
          <city>10587 Berlin</city>
          <country>Germany</country>
        </postal>
        <email>philipp@inet.tu-berlin.de</email>
      </address>
    </author>
    <author initials="C." surname="Perkins" fullname="Colin Perkins">
      <organization>University of Glasgow</organization>
      <address>
        <postal>
          <street>School of Computing Science</street>
          <city>Glasgow G12 8QQ</city>
          <country>United Kingdom</country>
        </postal>
        <email>csp@csperkins.org</email>
      </address>
    </author>
    <author initials="M." surname="Welzl" fullname="Michael Welzl">
      <organization>University of Oslo</organization>
      <address>
        <postal>
          <street>PO Box 1080 Blindern</street>
          <city>0316  Oslo</city>
          <country>Norway</country>
        </postal>
        <email>michawe@ifi.uio.no</email>
      </address>
    </author>

    <date year="2018" month="February" day="27"/>

    <area>Transport</area>
    <workgroup>TAPS Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>The Transport Services architecture <xref target="I-D.pauly-taps-arch"/> defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build a system that provides such an interface.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The Transport Services architecture <xref target="I-D.pauly-taps-arch"/> defines a system that allows applications to use transport networking protocols flexibly. This document serves as a guide to implementation on how to build a system that provides such an interface. The terminology used in this document is based on the Architecture.</t>

<t>The interface exposed to applications is defined as the Transport Services API <xref target="I-D.trammell-taps-interface"/>. This API is designed to be generic across multiple transport protocols and sets of protocols features. It is the job of an implementation of a Transport Services system to turn the requests of an application into decisions on how to establish connections, and how to transfer data over those connections once established.</t>

</section>
<section anchor="implementing-transport-objects" title="Implementing Transport Objects">

<t>What is the basic handle an application interacts with?</t>

<t><list style="symbols">
  <t>A flow of data in either direction</t>
  <t>For TCP, one connection is a Connection object</t>
  <t>For UDP, one set of fully-specified local and remote endpoints is a Connection object</t>
  <t>For QUIC, one stream is a Connection object</t>
  <t>For SCTP, one stream is a Connection object</t>
</list></t>

</section>
<section anchor="implementing-pre-establishment" title="Implementing Pre-Establishment">

<section anchor="configuration-time-errors" title="Configuration-time errors">

<t>When an application creates a new Connection, it specifies Transport Parameters reflecting its preferences regarding Protocol and Path Selection.</t>

<t>The transport system should have a list of supported protocols available, which each have Transport Features reflecting the capabilities of the protocol. Once an application specifies Transport Paratemeters, the transport system should match the required and prohibited properties against the Transport Features of the available protocols.</t>

<t>In the following cases the NewConnection() call should fail immediately:</t>

<t><list style="symbols">
  <t>The application requested Transport Parameters which include requirements or prohibitions that cannot be satisfied by any of the available protocols. For example, if an application requires “Option to configure reliability for individual Messages”, but no such protocol is available on the host running the transport system, e.g., because SCTP is not supported by the operating system, this should result in an error.</t>
  <t>The application requested Transport Parameters which exclude each other, i.e., the required and prohibited properties cannot be satisfied by the same protocol. For example, if an application prohibits “Reliable Data Transfer” but then requires “Configure Reliability per Message”, this mismatch should result in an error.</t>
</list></t>

<t>It is important to fail as early as possible in such cases in order to avoid allocating resources, e.g., to endpoint resolution, only to find out later that there is no protocol that satisfies the requirements.</t>

<t>[The following probably belongs in later sections.]</t>

<t>Some errors will only become apparent after Initiate() has been called and Candidate Gathering and Racing has started or after it is complete.</t>

<t>In the following cases the Initiate() call should fail or the transport system should notify the application with an Error:</t>

<t><list style="symbols">
  <t>During Candidate Gathering, the transport system finds that there are no usable Candidates to Race.</t>
  <t>During Candidate Racing, the transport system finds that none of the configurations that satisfy all requirements given in the Transport Parameters actually work over the available paths.</t>
</list></t>

<t>In the following cases the transport system should notify the application with a Warning:</t>

<t><list style="symbols">
  <t>At any point, the application attempts to set a Protocol Property which does not apply to the actually chosen protocol. In this case, the transport system should fail gracefully, i.e., give a warning to the application, but not terminate the Connection.</t>
</list></t>

</section>
<section anchor="role-of-system-policy" title="Role of system policy">

<t>The implementation is responsible for combining and reconciling several different sources of preferences when establishing Connections. These include, but are not limited to:</t>

<t><list style="numbers">
  <t>Application preferences, i.e., preferences specified during the pre-establishment such as Local Endpoint, Remote Endpoint, Path Selection Properties, and Protocol Selection Properties.</t>
  <t>Dynamic system policy, i.e., policy compiled from internally and externally acquired information about available network interfaces, supported transport protocols, and current/previous Connections. Examples of ways to externally retrieve policy-support information are through OS-specific statistics/measurement tools and tools that reside on middleboxes and routers.</t>
  <t>Default implementation policy, i.e., predefined policy by OS or application.</t>
</list></t>

<t>In general, any protocol or path used for a connection must conform to all three sources of constraints. Any violation of any of the layers should cause a protocol or path to be considered ineligble for use. For an example of application preferences leading to constraints, an application may prohibit the use of metered network interfaces for a given Connection to avoid user cost. Similarly, the system policy at a given time may prohibit the use of such a metered network interface from the application’s process. Lastly, the implementation itself may default to disallowing certain network interfaces unless explicitly requested by the application and allowed by the system.</t>

<t>It is expected that the database of system policies and the method of looking up these policies will vary across various platforms. An implementation SHOULD attempt to look up the relevant policies for the system in a dynamic way to make sure it is reflecting an accurate version of the system policy, since the system’s policy regarding the application’s traffic may change over time due to user or administrative changes.</t>

</section>
</section>
<section anchor="implementing-connection-establishment" title="Implementing Connection Establishment">

<t>The process of establishing a network connection begins when an application expresses intent to communicate with a remote endpoint (along with any constraints or requirements it may have on the connection). The process can be considered complete once there is at least one set of network protocols that have completed any required setup to the point that it can transmit and receive the application’s data.</t>

<t>Connection establishment is divided into two top-level steps: Candidate Gathering, to identify the paths, protocols, and endpoints to use, and Candidate Racing, in which the necessary protocol handshakes are conducted in order to select which set to use.</t>

<t>The most simple example of this process might involve identifying the single IP address to which the implementation wishes to connect, using the system’s current default interface or path, and starting a TCP handshake to establish a stream to the specified IP address. However, each step may also vary depending on the requirements of the connection: if the endpoint is defined as a hostname and port, then there may be multiple resolved addresses that are available; there may also be multiple interfaces or paths available, other than the default system interface; and some protocols may not need any transport handshake to be considered “established” (such as UDP), while other connections may utilize layered protocol handshakes, such as TLS over TCP.</t>

<t>Whenever an implementation has multiple options for connection establishment, it can view the set of all individual connection establishment options as a single, aggregate connection establishment. The aggregate set conceptually includes every valid combination of endpoints, paths, and protocols. As an example, consider an implementation that initiates a TCP connection to a hostname + port endpoint, and has two valid interfaces available (Wi-Fi and LTE). The hostname resolves to a single IPv4 address on the Wi-Fi network, and resolves to the same IPv4 address on the LTE network, as well as a single IPv6 address. The aggregate set of connection establishment options can be viewed as follows:</t>

<figure><artwork><![CDATA[
Aggregate [Endpoint: www.example.com:80] [Interface: Any]   [Protocol: TCP]
|-> [Endpoint: 192.0.2.1:80]       [Interface: Wi-Fi] [Protocol: TCP]
|-> [Endpoint: 192.0.2.1:80]       [Interface: LTE]   [Protocol: TCP]
|-> [Endpoint: 2001:DB8::1.80]     [Interface: LTE]   [Protocol: TCP]
]]></artwork></figure>

<t>Any one of these sub-entries on the aggregate connection attempt would satisfy the original application intent. The concern of this document is the algorithm defining which of these options to try, when, and in what order.</t>

<section anchor="gathering" title="Candidate Gathering">

<t>The step of gathering candidates involves identifying which paths, protocols, and endpoints may be used for a given Connection. This list is determined by the requirements, prohibitions, and preferences of the application as specified in the Path Selection Properties and Protocol Selection Properties.</t>

<section anchor="structuring-options-as-a-tree" title="Structuring Options as a Tree">

<t>When an implementation responsible for connection establishment needs to consider multiple options, it SHOULD logically structure these options as a hierarchical tree. Each leaf node of the tree represents a single, coherent connection attempt, with an Endpoint, a Path, and a set of protocols that can directly negotiate and send data on the network. Each node in the tree that is not a leaf represents a connection attempt that is either underspecified, or else includes multiple distinct options. For example. when connecting on an IP network, a connection attempt to a hostname and port is underspecified, because the connection attempt requires a resolved IP address as its remote endpoint. In this case, the node represented by the connection attempt to the hostname is a parent node, with child nodes for each IP address. Similarly, an implementation that is allowed to connect using multiple interfaces will have a parent node of the tree for the decision between the paths, with a branch for each interface.</t>

<t>The example aggregate connection attempt above can be drawn as a tree by grouping the addresses resolved on the same interface into branches:</t>

<figure><artwork><![CDATA[
                             ||
                +==========================+
                |  www.example.com:80/Any  |
                +==========================+
                  //                    \\
+==========================+       +==========================+
| www.example.com:80/Wi-Fi |       |  www.example.com:80/LTE  |
+==========================+       +==========================+
             ||                      //                    \\
  +====================+  +====================+  +======================+
  | 192.0.2.1:80/Wi-Fi |  |  192.0.2.1:80/LTE  |  |  2001:DB8::1.80/LTE  |
  +====================+  +====================+  +======================+
]]></artwork></figure>

<t>The rest of this section will use a notation scheme to represent this tree. The parent (or trunk) node of the tree will be represented by a single integer, such as “1”. Each child of that node will have an integer that identifies it, from 1 to the number of children. That child node will be uniquely identified by concatenating its integer to it’s parents identifier with a dot in between, such as “1.1” and “1.2”. Each node will be summarized by a tuple of three elements: Endpoint, Path, and Protocol. The above example can now be written more succinctly as:</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
    1.2.1 [192.0.2.1:80, LTE, TCP]
    1.2.2 [2001:DB8::1.80, LTE, TCP]
]]></artwork></figure>

<t>When an implementation views this aggregate set of connection attempts as a single connection establishment, it only will use one of the leaf nodes to transfer data. Thus, when a single leaf node becomes ready to use, then the entire connection attempt is ready to use by the application. Another way to represent this is that every leaf node updates the state of its parent node when it becomes ready, until the trunk node of the tree is ready, which then notifies the application that the connection as a whole is ready to use.</t>

<t>A connection establishment tree may be degenerate, and only have a single leaf node, such as a connection attempt to an IP address over a single interface with a single protocol.</t>

<figure><artwork><![CDATA[
1 [192.0.2.1:80, Wi-Fi, TCP]
]]></artwork></figure>

<t>A parent node may also only have one child (or leaf) node, such as a when a hostname resolves to only a single IP address.</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
]]></artwork></figure>

</section>
<section anchor="branch-types" title="Branch Types">

<t>There are three types of branching from a parent node into one or more child nodes. Any parent node of the tree MUST only use one type of branching.</t>

<section anchor="derived-endpoints" title="Derived Endpoints">

<t>If a connection originally targets a single endpoint, there may be multiple endpoints of different types that can be derived from the original. The connection library should order the derived endpoints according to application preference and expected performance.</t>

<t>DNS hostname-to-address resolution is the most common method of endpoint derivation. When trying to connect to a hostname endpoint on a traditional IP network, the implementation SHOULD send DNS queries for both A (IPv4) and AAAA (IPv6) records if both are supported on the local link. The algorithm for ordering and racing these addresses SHOULD follow the recommendations in Happy Eyeballs <xref target="RFC8305"/>.</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Wi-Fi, TCP]
  1.1 [2001:DB8::1.80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, Wi-Fi, TCP]
  1.3 [2001:DB8::2.80, Wi-Fi, TCP]
  1.4 [2001:DB8::3.80, Wi-Fi, TCP]
]]></artwork></figure>

<t>DNS-Based Service Discovery can also provide an endpoint derivation step. When trying to connect to a named service, the client may discover one or more hostname and port pairs on the local network using multicast DNS. These hostnames should each be treated as a branch which can be attempted independently from other hostnames. Each of these hostnames may also resolve to one or more addresses, thus creating multiple layers of branching.</t>

<figure><artwork><![CDATA[
1 [term-printer._ipp._tcp.meeting.ietf.org, Wi-Fi, TCP]
  1.1 [term-printer.meeting.ietf.org:631, Wi-Fi, TCP]
    1.1.1 [31.133.160.18.631, Wi-Fi, TCP]
]]></artwork></figure>

</section>
<section anchor="alternate-paths" title="Alternate Paths">

<t>If a client has multiple network interfaces available to it, such as mobile client with both Wi-Fi and Cellular connectivity, it can attempt a connection over either interface. This represents a branch point in the connection establishment. Like with derived endpoints, the interfaces should be ranked based on preference, system policy, and performance. Attempts should be started on one interface, and then on other interfaces successively after delays based on expected round-trip-time or other available metrics.</t>

<figure><artwork><![CDATA[
1 [192.0.2.1:80, Any, TCP]
  1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [192.0.2.1:80, LTE, TCP]
]]></artwork></figure>

<t>This same approach applies to any situation in which the client is aware of multiple links or views of the network. Multiple Paths, each with a coherent set of addresses, routes, DNS server, and more, may share a single interface. A path may also represent a virtual interface service such as a Virtual Private Network (VPN).</t>

<t>The list of available paths should be constrained by any requirements or prohibitions the application sets, as well as system policy.</t>

</section>
<section anchor="protocol-options" title="Protocol Options">

<t>Differences in possible protocol compositions and options can also provide a branching point in connection establishment. This allows clients to be resilient to situations in which a certain protocol is not functioning on a server or network.</t>

<t>This approach is commonly used for connections with optional proxy server configurations. A single connection may be allowed to use an HTTP-based proxy, a SOCKS-based proxy, or connect directly. These options should be ranked and attempted in succession.</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Any, HTTP/TCP]
  1.1 [192.0.2.8:80, Any, HTTP/HTTP Proxy/TCP]
  1.2 [192.0.2.7:10234, Any, HTTP/SOCKS/TCP]
  1.3 [www.example.com:80, Any, HTTP/TCP]
    1.3.1 [192.0.2.1:80, Any, HTTP/TCP]
]]></artwork></figure>

<t>This approach also allows a client to attempt different sets of application and transport protocols that may provide preferable characteristics when available. For example, the protocol options could involve QUIC <xref target="I-D.ietf-quic-transport"/> over UDP on one branch, and HTTP/2 <xref target="RFC7540"/> over TLS over TCP on the other:</t>

<figure><artwork><![CDATA[
1 [www.example.com:443, Any, Any HTTP]
  1.1 [www.example.com:443, Any, QUIC/UDP]
    1.1.1 [192.0.2.1:443, Any, QUIC/UDP]
  1.2 [www.example.com:443, Any, HTTP2/TLS/TCP]
    1.2.1 [192.0.2.1:443, Any, HTTP2/TLS/TCP]
]]></artwork></figure>

<t>Another example is racing SCTP with TCP:</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Any, Any Stream]
  1.1 [www.example.com:80, Any, SCTP]
    1.1.1 [192.0.2.1:80, Any, SCTP]
  1.2 [www.example.com:80, Any, TCP]
    1.2.1 [192.0.2.1:80, Any, TCP]
]]></artwork></figure>

<t>Implementations that support racing protocols and protocol options SHOULD maintain a history of which protocols and protocol options successfully established, on a per-network basis. This information can influence future racing decisions to prioritize or prune branches.</t>

</section>
</section>
</section>
<section anchor="branching-order-of-operations" title="Branching Order-of-Operations">

<t>Branch types must occur in a specific order relative to one another to avoid creating leaf nodes with invalid or incompatible settings. In the example above, it would be invalid to branch for derived endpoints (the DNS results for www.example.com) before branching between interface paths, since usable DNS results on one network may not necessarily be the same as DNS results on another network due to local network entities, supported address families, or enterprise network configurations. Implementations must be careful to branch in an order that results in usable leaf nodes whenever there are multiple branch types that could be used from a single node.</t>

<t>The order of operations for branching, where lower numbers are acted upon first, SHOULD be:</t>

<t><list style="numbers">
  <t>Alternate Paths</t>
  <t>Protocol Options</t>
  <t>Derived Endpoints</t>
</list></t>

<t>Branching between paths is the first in the list because results across multiple interfaces are likely not related to one another: endpoint resolution may return different results, especially when using locally resolved host and service names, and which protocols are supported and preferred may differ across interfaces. Thus, if multiple paths are attempted, the overall connection can be seen as a race between the available paths or interfaces.</t>

<t>Protocol options are checked next in order. Whether or not a set of protocol, or protocol-specific options, can successfully connect is generally not dependent on which specific IP address is used. Furthermore, the protocol stacks being attempted may influence or altogether change the endpoints being used. Adding a proxy to a connection’s branch will change the endpoint to the proxy’s IP address or hostname. Choosing an alternate protocol may also modify the ports that should be selected.</t>

<t>Branching for derived endpoints is the final step, and may have multiple layers of derivation or resolution, such as DNS service resolution and DNS hostname resolution.</t>

</section>
<section anchor="ranking-branches" title="Ranking Branches">

<t>The transport system ranks branches in order to prioritize candidate racing.
While <xref target="I-D.trammell-taps-interface"/> allows the application to express their preferences for a new connection using Protocol and Path Selection Properties as well as Application Intents, applying these these preferences is implemented by ranking of branches.
In addition to the application provided properties, performance estimates, system policy, or other criteria also influence this ranking.</t>

<t>The Application Intents specified in <xref target="I-D.trammell-taps-interface"/> are used to rank branches in the following ways:</t>

<t><list style="symbols">
  <t>Capacity Profile:
The Capacity Profile is used to prefer paths that match the applications capacity profile:
  <list style="symbols">
      <t>Interactive/Low Latency:
Prefer paths with the lowest available latency</t>
      <t>Constant Rate:
Prefer paths that can satisfy the requested Stream Send or Stream Receive Bitrate</t>
      <t>Scavenger/Bulk:
Prefer Paths with the highest available bandwidth</t>
    </list></t>
  <t>Size to be Sent / Received:
If the application indicates the size of the Content it expects to receive,
the transport system can predict the completion time of the transfer on each of the available paths
based on current performance estimates.
It can then rank the path with the lower expected completion time higher,
so for small Content where the download is latency-bound,
the path with the lower latency estimate is tried first,
while for larger Content which is bandwidth-bound,
the path with the higher observed bitrate is tried first.
This addresses the issue that the application does not necessarily know whether it is best to optimize for low latency or high throughput at the time the application is written.
A related paper is currently under submission.</t>
  <t>Metered or expensive paths:
If the application indicates a preference to avoid expensive paths,
such paths will be ranked lower.
If the application indicates that it prohibits using expensive paths,
paths that are associated with a cost will be purged from the decision tree.</t>
</list></t>

</section>
<section anchor="candidate-racing" title="Candidate Racing">

<t>The primary goal of the Candidate Racing process is to successfully negotiate a protocol stack to an endpoint over an interface—to connect a single leaf node of the tree—with as little delay and as few unnecessary connections attempts as possible. Optimizing these two factors improves the user experience, while minimizing network load.</t>

<t>This section covers the dynamic aspect of connection establishment. While the tree described above is a useful conceptual and architectural model, an implementation does not know what the full tree may become up front, nor will many of the possible branches be used in the common case.</t>

<t>There are three different approaches to racing the attempts for different nodes of the connection establishment tree:</t>

<t><list style="numbers">
  <t>Immediate</t>
  <t>Delayed</t>
  <t>Failover</t>
</list></t>

<t>Each approach is appropriate in different use-cases and branch types. However, to avoid consuming unnecessary network resources, implementations SHOULD NOT use immediate racing as a default approach.</t>

<t>The timing algorithms for racing SHOULD remain independent across branches of the tree. Any timers or racing logic is isolated to a given parent node, and is not ordered precisely with regards to other children of other nodes.</t>

<section anchor="delayed-racing" title="Delayed Racing">

<t>Delayed racing can be used whenever a single node of the tree has multiple child nodes. Based on the order determined when building the tree, the first child node will be initiated immediately, followed by the next child node after some delay. Once that second child node is initiated, the third child node (if present) will begin after another delay, and so on until all child nodes have been initiated, or one of the child nodes successfully completes its negotiation.</t>

<t>Delayed racing attempts occur in parallel. Implementations SHOULD NOT terminate an earlier child connection attempt upon starting a secondary child.</t>

<t>The delay between starting child nodes SHOULD be based on the properties of the previously started child node. For example, if the first child represents an IP address with a known route, and the second child represents another IP address, the delay between starting the first and second IP addresses can be based on the expected retransmission cadence for the first child’s connection (derived from historical round-trip-time). Alternatively, if the first child represents a branch on a Wi-Fi interface, and the second child represents a branch on an LTE interface, the delay should be based on the expected time in which the branch for the first interface would be able to establish a connection, based on link quality and historical round-trip-time.</t>

<t>Any delay SHOULD have a defined minimum and maximum value based on the branch type. Generally, branches between paths and protocols should have longer delays than branches between derived endpoints. The maximum delay should be considered with regards to how long a user is expected to wait for the connection to complete.</t>

<t>If a child node fails to connect before the delay timer has fired for the next child, the next child SHOULD be started immediately.</t>

</section>
<section anchor="failover" title="Failover">

<t>If an implementation or application has a strong preference for one branch over another, the branching node may choose to wait until one child has failed before starting the next. Failure of a leaf node is determined by its protocol negotiation failing or timing out; failure of a parent branching node is determined by all of its children failing.</t>

<t>An example in which failover is recommended is a race between a protocol stack that uses a proxy and a protocol stack that bypasses the proxy. Failover is useful in case the proxy is down or misconfigured, but any more aggressive type of racing may end up unnecessarily avoiding a proxy that was preferred by policy.</t>

</section>
</section>
<section anchor="completing-establishment" title="Completing Establishment">

<t>The process of connection establishment completes when one leaf node of the tree has completed negotiation with the remote endpoint successfully, or else all nodes of the tree have failed to connect. The first leaf node to complete its connection is then used by the application to send and receive data.</t>

<t>It is useful to process success and failure throughout the tree by child nodes reporting to their parent nodes (towards the trunk of the tree). For example, in the following case, if 1.1.1 fails to connect, it reports the failure to 1.1. Since 1.1 has no other child nodes, it also has failed and reports that failure to 1. Because 1.2 has not yet failed, 1 is not considered to have failed. Since 1.2 has not yet started, it is started and the process continues. Similarly, if 1.1.1 successfully connects, then it marks 1.1 as connected, which propagates to the trunk node 1. At this point, the connection as a whole is considered to be successfully connected and ready to process application data</t>

<figure><artwork><![CDATA[
1 [www.example.com:80, Any, TCP]
  1.1 [www.example.com:80, Wi-Fi, TCP]
    1.1.1 [192.0.2.1:80, Wi-Fi, TCP]
  1.2 [www.example.com:80, LTE, TCP]
...
]]></artwork></figure>

<t>If a leaf node has successfully completed its connection, all other attempts SHOULD be made ineligible for use by the application for the original request. New connection attempts that involve transmitting data on the network SHOULD NOT be started after another leaf node has completed successfully, as the connection as a whole has been established. An implementation MAY choose to let certain handshakes and negotiations complete in order to gather metrics to influence future connections. Similarly, an implementation MAY choose to hold onto fully established leaf nodes that were not the first to establish for use in future connections, but this approach is not recommended since those attempts were slower to connect and may exhibit less desirable properties.</t>

<section anchor="determining-successful-establishment" title="Determining Successful Establishment">

<t>Implementations may select the criteria by which a leaf node is considered to be successfully connected differently on a per-protocol basis. If the only protocol being used is a transport protocol with a clear handshake, like TCP, then the obvious choice is to declare that node “connected” when the last packet of the three-way handshake has been received. If the only protocol being used is an “unconnected” protocol, like UDP, the implementation may consider the node fully “connected” the moment it determines a route is present, before sending any packets on the network <xref target="unconnected-racing"/>.</t>

<t>For protocol stacks with multiple handshakes, the decision becomes more nuanced. If the protocol stack involves both TLS and TCP, an implementation MAY determine that a leaf node is connected after the TCP handshake is complete, or it MAY wait for the TLS handshake to complete as well. The benefit of declaring completion when the TCP handshake finishes, and thus stopping the race for other branches of the tree, is that there will be less burden on the network from other connection attempts. On the other hand, by waiting until the TLS handshake is complete, an implementation avoids the scenario in which a TCP handshake completes quickly, but TLS negotiation is either very slow or fails altogether in particular network conditions or to a particular endpoint.</t>

</section>
<section anchor="protocol-configuration" title="Protocol Configuration">

<t>Once a connection is established and a transport protocol has been chosen, any Protocol Properties given by the application which apply to the transport protocol are configured on the transport protocol.</t>

<t>Additionally, a transport system may configure a transport protocol according to following Application Intents:</t>

<t><list style="symbols">
  <t>Traffic Category: Can be mapped to DSCP code point value, e.g., see <xref target="I-D.ietf-tsvwg-rtcweb-qos"></xref>. Furthermore, if an application indicates a preference for low latency, the transport system may disable the Nagle algorithm on a TCP connection.</t>
  <t>Bitrate to be Sent: If an application indicates a certain bitrate it wants to send on the connection, the transport system may limit the bitrate of the outgoing communication to that rate, for example by setting an upper bound for the TCP congestion window of a connection calculated from the Send Bitrate and the Round Trip Time. This helps to avoid bursty traffic patterns on video streaming servers, see <xref target="Trickle"></xref>.</t>
</list></t>

</section>
</section>
<section anchor="establish-mux" title="Establishing multiplexed connections">

<t>Multiplexing data streams over a connection of a single transport Protocol Instance requires, at minimum, two things: 1) the transport Protocol Instance must be able to know the beginning and the end of messages, in order to know what to assign and multiplex / demultiplex; 2) there must be an identifier that allows to decide which stream a message is assigned to. When a new stream is multiplexed on an already existing connection, there is no need for a connection establishment procedure – every stream can be assumed to immediately be available.</t>

<t>When the Connections that are offered to an application by the Transport System are multiplexed,
the Transport System may implement the establishment of a new Connection by simply beginning to use
a new stream of an already established transport connection. This, then, means that there may not
be any “establishment” message (like a TCP SYN), but the application can simply start sending
or receiving. Therefore, when a Transport System’s “Initiate” Action is called without Messages being
handed over, it cannot be guaranteed that the other endpoint will have any way to know about this, and hence
a passive endpoint’s ConnectionReceived event may not be called upon an active endpoint’s Inititate.
Instead, calling the ConnectionReceived event may be delayed until the first Message arrives.</t>

</section>
<section anchor="unconnected-racing" title="Handling racing with “unconnected” protocols">

<t>While protocols that use an explicit handshake to validate a Connection to a peer can be used for racing multiple establishment attempts in parallel, “unconnected” protocols such as raw UDP do not offer a way to validate the presence of a peer or the usability of a Connection without application feedback. An implementation SHOULD consider such a protocol stack to be established as soon as a local route to the peer endpoint is confirmed.</t>

<t>However, if a peer is not reachable over the network using the unconnected protocol, or data cannot be exchanged for any other reason, the application may want to attempt using another candidate Protocol Stack. The implementation SHOULD maintain the list of other candidate Protocol Stacks that were eligible to use. In the case that the application signals that the initial Protocol Stack is failing for some reason and that another option should be attempted, the Connection can be updated to point to the next candidate Protocol Stack. This can be viewed as an application-driven form of Protocol Stack racing.</t>

</section>
<section anchor="implementing-listeners" title="Implementing listeners">

<t>How to passively wait for incoming connections, and what that means for protocols with and without handshakes.</t>

<section anchor="implementing-listeners-for-unconnected-protocols" title="Implementing listeners for Unconnected Protocols">

<t>Unconnected protocols such as UDP and UDP-lite generally do not provide the same mechanisms that connected protocols do to offer Connection objects.</t>

<t>Implementations should wait for incoming packets for unconnected protocols on a listening port and should perform five-tuple matching of packets to either existing Connection objects or the creation of new Connection objects. On platforms with facilities to create a “virtual connection” for unconnected protocols implementations should use these mechanisms to minimise the handling of datagrams intended for already created Connection objects.</t>

</section>
</section>
</section>
<section anchor="implementing-data-transfer" title="Implementing Data Transfer">

<section anchor="data-transfer-for-streams-datagrams-and-frames" title="Data transfer for streams, datagrams, and frames">

<t>The most basic mapping for sending a Message is an abstraction of datagrams, in which the transport protocol naturally deals in discrete packets. Each Message here corresponds to a single datagram. Generally, these will be short enough that sending and receiving will always use a complete Message.</t>

<t>For protocols that expose byte-streams, the only delineation provided by the protocol is the end of the stream in a given direction. Each Message in this case corresponds to the entire stream of bytes in a direction. These Messages may be quite long, in which case they can be sent in multiple parts.</t>

<t>Protocols that provide the framing (such as length-value protocols, or protocols that use delimeters) provide data boundaries that may be longer than a traditional packet datagram. Each Message for framing protocols corresponds to a single frame, which may be sent either as a complete Message, or in multiple parts.</t>

<section anchor="sending-messages" title="Sending Messages">

<t>The effect of the application sending a Message is determined by the top-level protocol in the established Protocol Stack. That is, if the top-level protocol provides an abstraction of framed messages over a connection, the application will be able to send multiple Messages on that connection, even if the framing protocol is built on a byte-stream protocol like TCP.</t>

<section anchor="send-parameters" title="Send Parameters">

<t><list style="symbols">
  <t>Lifetime should be implemented by removing the Message from its queue of pending Messages after the Lifetime has expired. A queue of pending Messages within the transport system implementation that have yet to be handed to the Protocol Stack can always support this property, but once a Message has been sent into the send buffer of a protocol, only certain protocols may support de-queueing a message. For example, TCP cannot remove bytes from its send buffer, while in case of SCTP, such control over the SCTP send buffer can be exercised using the partial reliability extension <xref target="RFC8303"/>. When there is no standing queue of Messages within the system, and the Protocol Stack does not support removing a Message from its buffer, this property may be ignored.</t>
  <t>Niceness represents the ability to de-prioritize a Message in favor of other Messages. This can be implemented by the system re-ordering Messages that have yet to be handed to the Protocol Stack, or by giving relative priority hints to protocols that support priorities per Message. For example, an implementation of HTTP/2 could choose to send Messages of different niceness on streams of different priority.</t>
  <t>Ordered: when this is false, it disables the requirement of in-order-delivery for protocols that support configurable ordering.</t>
  <t>Immediate: when this is true, the Message should be sent immediately, even when this comes at the cost of using the network capacity less efficiently. For example, small messages can sometimes be bundled to fit into a single data packet for the sake of reducing header overhead; such bundling SHOULD not be used in case this parameter is true. For example, in case of TCP, the Nagle algorithm SHOULD be disabled when Immediate=true.</t>
  <t>Idempotent: when this is true, it means that the Message can be used by mechanisms that might transfer it multiple times – e.g., as a result of racing multiple transports or as part of TCP Fast Open.</t>
  <t>Corruption Protection Length: when this is set to any value other than -1, it limits the required checksum in protocols that allow limiting the checksum length (e.g. UDP-Lite).</t>
  <t>Immediate Acknowledgement: TBD</t>
  <t>Timeliness: TODO</t>
</list></t>

</section>
<section anchor="send-completion" title="Send Completion">

<t>The application should be notified whenever a Message or partial Message has been consumed by the Protocol Stack, or has failed to send. This meaning of the Message being consumed by the stack may vary depending on the protocol. For a basic datagram protocol like UDP, this may correspond to the time when the packet is sent into the interface driver. For a protocol that buffers data in queues, like TCP, this may correspond to when the data has entered the send buffer.</t>

</section>
<section anchor="batching-sends" title="Batching Sends">

<t>Since sending a Message may involve a context switch between the application and the transport system, sending patterns that involve multiple small Messages can incur high overhead if each needs to be enqueued separately. To avoid this, the application should have a way to indicate a batch of Send actions, during which time the implementation will hold off on processing Messages until the batch is complete. This can also help context switches when enqueuing data in the interface driver if the operation can be batched.</t>

</section>
</section>
<section anchor="receiving-messages" title="Receiving Messages">

<t>Similar to sending, Receiving a Message is determined by the top-level protocol in the established Protocol Stack. The main difference with Receiving is that the size and boundaries of the Message are not known beforehand. The application can communicate in its Receive action the parameters for the Message, which can help the implementation know how much data to deliver and when. For example, if the application only wants to receive a complete Message, the implementation should wait until an entire Message (datagram, stream, or frame) is read before delivering any Message content to the application. Alternatively, the application can specify the minimum number of bytes of Message content it wants to receive (which may be just a single byte) to control the flow of received data.</t>

<t>If a Connection becomes finished before a requested Receive action can be satisfied, the implementation should deliver any partial Message content outstanding, or if none is available, an indication that there will be no more received Messages.</t>

</section>
</section>
<section anchor="fastopen" title="Handling of data for fast-open protocols">

<t>Several protocols allow sending higher-level protocol or application data within the first packet of their protocol establishment, such as TCP Fast Open <xref target="RFC7413"/> and TLS 1.3 <xref target="I-D.ietf-tls-tls13"/>. This approach is referred to as sending Zero-RTT (0-RTT) data. This is a desirable property, but poses challenges to an implementation that uses racing during connection establishment.</t>

<t>If the application has 0-RTT data to send in any protocol handshakes, it needs to provide this data before the handshakes have begun. When racing, this means that the data SHOULD be provided before the process of connection establishment has begun. If the API allows the application to send 0-RTT data, it MUST provide an interface that identifies this data as idempotent data. In general, 0-RTT data may be replayed (for example, if a TCP SYN contains data, and the SYN is retransmitted, the data will be retransmitted as well), but racing means that different leaf nodes have the opportunity to send the same data independently. If data is truly idempotent, this should be permissible.</t>

<t>Once the application has provided its 0-RTT data, an implementation SHOULD keep a copy of this data and provide it to each new leaf node that is started and for which a 0-RTT protocol is being used.</t>

<t>It is also possible that protocol stacks within a particular leaf node use 0-RTT handshakes without any idempotent application data. For example, TCP Fast Open could use a Client Hello from a TLS as its 0-RTT data, shortening the cumulative handshake time.</t>

<t>0-RTT handshakes often rely on previous state, such as TCP Fast Open cookies, previously established TLS tickets, or out-of-band distributed pre-shared keys (PSKs). Implementations should be aware of security concerns around using these tokens across multiple addresses or paths when racing. In the case of TLS, any given ticket or PSK SHOULD only be used on one leaf node. If implementations have multiple tickets available from a previous connection, each leaf node attempt MUST use a different ticket. In effect, each leaf node will send the same early application data, yet encoded (encrypted) differently on the wire.</t>

</section>
</section>
<section anchor="implementing-maintenance" title="Implementing Maintenance">

<section anchor="changing-protocol-properties" title="Changing Protocol Properties">

<t>Appendix A.1 of <xref target="I-D.ietf-taps-minset"/> explains, using primitives that are described in <xref target="RFC8303"/> and <xref target="RFC8304"/>, how to implement changing the following protocol properties of an established connection with the TCP and UDP. Below, we amend this description for other protocols (if applicable):</t>

<t><list style="symbols">
  <t>Set timeout for aborting Connection: for SCTP, this can be done using the primitive CHANGE_TIMEOUT.SCTP described in section 4 of <xref target="RFC8303"/>.</t>
  <t>Set timeout to suggest to the peer</t>
  <t>Set retransmissions before “Excessive Retransmissions”</t>
  <t>Set required minimum coverage of the checksum for receiving: for UDP-Lite, this can be done using the primitive SET_MIN_CHECKSUM_COVERAGE.UDP-Lite described in section 4 of <xref target="RFC8303"/>.</t>
  <t>Set scheduler for connections in a group: for SCTP, this can be done using the primitive SET_STREAM_SCHEDULER.SCTP described in section 4 of <xref target="RFC8303"/>.</t>
  <t>Set priority for a connection in a group: for SCTP, this can be done using the primitive CONFIGURE_STREAM_SCHEDULER.SCTP described in section 4 of <xref target="RFC8303"/>.</t>
</list></t>

</section>
<section anchor="maintenance-events" title="Maintenance Events">

<t>Implications of a network change on a protocol</t>

<t><list style="symbols">
  <t>Multipath or migratable protocols</t>
  <t>Single-path protocols</t>
</list></t>

<t>Quality changes</t>

</section>
</section>
<section anchor="implementing-termination" title="Implementing Termination">

<t>How to handle termination requested by application:</t>

<t><list style="symbols">
  <t>How gracefully to tear down at various protocol layers</t>
</list></t>

<t>With TCP, when an application closes a connection, this
means that it has no more data to send (but expects all data that has been
handed over to be reliably delivered). However, with TCP only, “close” does
not mean that the application will stop receiving data. This is related to TCP’s ability to
support half-closed connections.</t>

<t>SCTP is an example of a protocol that does not support such half-closed connections.
Hence, with SCTP, the meaning of “close” is stricter: an application has no more data
to send (but expects all data that has been handed over to be reliably delivered), and will
also not receive any more data.</t>

<t>Implementing a protocol independent transport system means that the exposed
semantics must be the strictest subset of the semantics of all supported protocols.
Hence, as is common with all reliable transport protocols, after a Close action, the
application can expect to have its reliability requirements honored regarding the data
it has given to the Transport System – but it cannot expect to be able to read any
more data after calling Close.</t>

<t>Abort differs from Close only in that no guarantees are given regarding data
that the application has handed over to the Tranport System before calling Abort.</t>

<t><list style="symbols">
  <t>How much to tear down for multiplexed protocols, or protocols capable of multiplexing</t>
</list></t>

<t>As explained in section <xref target="establish-mux"/>, when a new stream is multiplexed on an already
existing connection of a Transport Protocol Instance, there is no need for a connection
establishment procedure. Because the Connections that are offered by the Transport System
can be implemented as streams that are multiplexed on a transport protocol’s connection,
it can therefore not be guaranteed that one Endpoint’s Initiate action
provokes a ConnectionReceived event at its peer.</t>

<t>For Close (provoking a Finished event) and Abort (provoking a ConnectionError event), the
same logic applies: while it is desirable to be informed when a peer closes or aborts a
Connection, whether this is possible depends on the underlying protocol, and no guarantees
can be given. With SCTP, the transport system can use the stream reset procedure to cause
a Finish event upon a Close action from the peer <xref target="NEAT-flow-mapping"/>.</t>

<!-- How to handle a failure generated by protocols -->

</section>
<section anchor="cached-state" title="Cached State">

<t>Beyond a single Connection’s lifetime, it is useful for an implementation to keep state and history. This cached
state can help improve future Connection establishment due to re-using results and credentials, and favoring paths and protocols that performed well in the past.</t>

<t>Cached state may be associated with different Endpoints for the same Connection, depending on the protocol generating the cached content.
For example, session tickets for TLS are associated with specific endpoints, and thus SHOULD be cached based on a Connection’s
hostname Endpoint (if applicable). On the other hand, performance characteristics of a path are more likely tied to the IP address
and subnet being used.</t>

<section anchor="protocol-state-caches" title="Protocol state caches">

<t>Some protocols will have long-term state to be cached in association with Endpoints. This state often has some time after which
it is expired, so the implementation SHOULD allow each protocol to specify an expiration for cached content.</t>

<t>Examples of cached protocol state include:</t>

<t><list style="symbols">
  <t>The DNS protocol can cache resolution answers (A and AAAA queries, for example), associated with a Time To Live (TTL) to
be used for future hostname resolutions without requiring asking the DNS resolver again.</t>
  <t>TLS caches session state and tickets based on a hostname, which can be used for resuming sessions with a server.</t>
  <t>TCP can cache cookies for use in TCP Fast Open.</t>
</list></t>

<t>Cached protocol state is primarily used during Connection establishment for a single Protocol Stack, but may be used to influence an
implementation’s preference between several candidate Protocol Stacks. For example, if two IP address Endpoints are otherwise
equally preferred, an implementation may choose to attempt a connection to an address for which it has a TCP Fast Open cookie.</t>

<t>Applications must have a way to flush protocol cache state if desired. This may be necessary, for example, if
application-layer identifiers rotate and clients wish to avoid linkability via trackable TLS tickets or TFO cookies.</t>

</section>
<section anchor="performance-caches" title="Performance caches">

<t>In addition to protocol state, Protocol Instances SHOULD provide data into a performance-oriented cache to help guide future protocol and path selection. Some performance information can be gathered generically across several protocols to allow predictive comparisons between protocols on given paths:</t>

<t><list style="symbols">
  <t>Observed Round Trip Time</t>
  <t>Connection Establishment latency</t>
  <t>Connection Establishment success rate</t>
</list></t>

<t>These items can be cached on a per-address and per-subnet granularity, and averaged between different values. The information SHOULD be cached on a per-network basis, since it is expected that different network attachments will have different performance characteristics. Besides Protocol Instances, other system entities may also provide data into performance-oriented caches. This could for instance be signal strength information reported by radio modems like Wi-Fi and mobile broadband or information about the battery-level of the device.</t>

<t>An implementation should use this information, when possible, to determine preference between candidate paths, endpoints, and protocol options. Eligible options that historically had significantly better performance than others SHOULD be selected first when gathering candidates <xref target="gathering"/> to ensure better performance for the application.</t>

</section>
</section>
<section anchor="specific-transport-protocol-considerations" title="Specific Transport Protocol Considerations">

<section anchor="tcp" title="TCP">

<t>Connection lifetime for TCP translates fairly simply into the the abstraction presented to an application. When the TCP three-way handshake is complete, its layer of the Protocol Stack can be considered Ready (established). This event will cause racing of Protocol Stack options to complete if TCP is the top-level protocol, at which point the application can be notified that the Connection is Ready to send and receive.</t>

<t>If the application sends a Close, that can translate to a graceful termination of the TCP connection, which is performed by sending a FIN to the remote endpoint. If the application sends an Abort, then the TCP state can be closed abruptly, leading to a RST being sent to the peer.</t>

<t>Without a layer of framing above TCP, the cleanest abstraction for sending and receiving Messages over TCP is to treat each direction of the stream of bytes as a single Message, terminated by a FIN. That means that if the application can make several Send calls to enqueue subsequent data chunks for the same Message to continue writing, but marking the Message complete corresponds to closing the sending stream. Similarly, when the application receives the final portion of a Message, it knows that the receiving stream has been closed.</t>

</section>
<section anchor="udp" title="UDP">

<t>UDP as a direct transport does not provide any handshake or connectivity state, so the notion of the transport protocol becoming Ready or established is degenerate. Once the system has validated that there is a route on which to send and receive UDP datagrams, the protocol is considered Ready. Similarly, a Close or Abort has no meaning to the on-the-wire protocol, but simply leads to the local state being torn down.</t>

<t>When sending and receiving messages over UDP, each Message should correspond to a single UDP datagram. The Message can contain metadata about the packet, such as the ECN bits applied to the packet.</t>

</section>
<section anchor="sctp" title="SCTP">

<t>To support sender-side stream schedulers (which are implemented on the sender side),
a receiver-side Transport System should
always support message interleaving <xref target="RFC8260"/>.</t>

<t>SCTP messages can be very large. To allow the reception of large messages in pieces, a “partial flag” can be
used to inform a (native SCTP) receiving application that a
message is incomplete. After receiving the “partial flag”, this application would know that the next receive calls will only
deliver remaining parts of the same message (i.e., no messages or partial messages will arrive on other
streams until the message is complete) (see Section 8.1.20 in <xref target="RFC6458"/>). The “partial flag” can therefore
facilitate the implementation of the receiver buffer in the receiving application, at the cost of limiting
multiplexing and temporarily creating head-of-line blocking delay at the receiver.</t>

<t>When a Transport System transfers a Message, it seems natural to map the Message object to SCTP messages in order
to support properties such as “Ordered” or “Lifetime” (which maps onto partially reliable delivery with
a SCTP_PR_SCTP_TTL policy <xref target="RFC6458"/>). However, since multiplexing of
Connections onto SCTP streams may happen, and would be hidden from the application, the
Transport System requires a per-stream receiver buffer anyway, so this potential benefit is lost
and the “partial flag” becomes unnecessary for the system.</t>

<t>The problem of long messages either requiring large receiver-side buffers or getting in the way of
multiplexing is addressed by message interleaving <xref target="RFC8260"/>,
which is yet another reason why a receivers-side transport system supporting SCTP should
implement this mechanism.</t>

</section>
<section anchor="tls" title="TLS">

<t>The mapping of a TLS stream abstraction into the application is equivalent to the contract provided by TCP <xref target="tcp"/>. The Ready state should be determined by the completion of the TLS handshake, which involves potentially several more round trips beyond the TCP handshake. The application should not be notified that the Connection is Ready until TLS is established.</t>

</section>
<section anchor="http" title="HTTP">

<t>HTTP requests and responses map naturally into Messages, since they are delineated chunks of data with metadata that can be sent over a transport. To that end, HTTP can be seen as the most prevalent framing protocol that runs on top of streams like TCP, TLS, etc.</t>

<t>In order to use a transport Connection that provides HTTP Message support, the establishment and closing of the connection can be treated as it would without the framing protocol. Sending and receiving of Messages, however, changes to treat each Message as a well-delineated HTTP request or response, with the content of the Message representing the body, and the Headers being provided in Message metadata.</t>

</section>
<section anchor="quic" title="QUIC">

<t>QUIC provides a multi-streaming interface to an encrypted transport. Each stream can be viewed as equivalent to a TLS stream over TCP, so a natural mapping is to present each QUIC stream as an individual Connection. The protocol for the stream will be considered Ready whenever the underlying QUIC connection is established to the point that this stream’s data can be sent. For streams after the first stream, this will likely be an immediate operation.</t>

<t>Closing a single QUIC stream, presented to application as a Connection, does not imply closing the underlying QUIC connection itself. Rather, the implementation may choose to close the QUIC connection once all streams have been closed (possibly after some timeout), or after an individual stream Connection sends an Abort.</t>

<t>Messages over a direct QUIC stream should be represented similarly to the TCP stream <xref target="tcp"/> (one Message per direction), unless a framing mapping is used on top of QUIC.</t>

</section>
<section anchor="http2-transport" title="HTTP/2 transport">

<t>Similar to QUIC <xref target="quic"/>, HTTP/2 provides a multi-streaming interface. This will generally use HTTP as the unit of Messages over the streams, in which each stream can be represented as a transport Connection. The lifetime of streams and the HTTP/2 connection should be managed as described for QUIC.</t>

<t>It is possible to treat each HTTP/2 stream as a raw byte-stream instead of carrier for HTTP messages, in which case the Messages over the streams can be represented similarly to the TCP stream <xref target="tcp"/> (one Message per direction).</t>

</section>
</section>
<section anchor="rendezvous-and-environment-discovery" title="Rendezvous and Environment Discovery">

<section anchor="ice-and-stun" title="ICE and STUN">

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>RFC-EDITOR: Please remove this section before publication.</t>

<t>This document has no actions for IANA.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="considerations-for-candidate-gathering" title="Considerations for Candidate Gathering">

<t>Implementations should avoid downgrade attacks that allow network interference to cause the implementation to select less secure, or entirely insecure, combinations of paths and protocols.</t>

</section>
<section anchor="considerations-for-candidate-racing" title="Considerations for Candidate Racing">

<t>See <xref target="fastopen"/> for security considerations around racing with 0-RTT data.</t>

<t>An attacker that knows a particular device is racing several options during connection establishment may be able to block packets for the first connection attempt, thus inducing the device to fall back to a secondary attempt. This is a problem if the secondary attempts have worse security properties that enable further attacks. Implementations should ensure that all options have equivalent security properties to avoid incentivizing attacks.</t>

<t>Since results from the network can determine how a connection attempt tree is built, such as when DNS returns a list of resolved endpoints, it is possible for the network to cause an implementation to consume significant on-device resources. Implementations SHOULD limit the maximum amount of state allowed for any given node, including the number of child nodes, especially when the state is based on results from the network.</t>

</section>
</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>This work has received funding from the European Union’s Horizon 2020 research and
innovation programme under grant agreement No. 644334 (NEAT).</t>

<t>This work has been supported by Leibniz Prize project funds of DFG - German
Research Foundation: Gottfried Wilhelm Leibniz-Preis 2011 (FKZ FE 570/4-1).</t>

<t>Thanks to Stuart Cheshire, Josh Graessley, David Schinazi, and Eric Kinnear for their implementation and design efforts, including Happy Eyeballs, that heavily influenced this work.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="I-D.pauly-taps-arch" >
  <front>
    <title>An Architecture for Transport Services</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="I-D.trammell-taps-interface" >
  <front>
    <title>An Abstract Application Layer Interface to Transport Services</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>




<reference anchor="I-D.ietf-taps-minset">
<front>
<title>A Minimal Set of Transport Services for TAPS Systems</title>

<author initials='M' surname='Welzl' fullname='Michael Welzl'>
    <organization />
</author>

<author initials='S' surname='Gjessing' fullname='Stein Gjessing'>
    <organization />
</author>

<date month='February' day='6' year='2018' />

<abstract><t>This draft recommends a minimal set of IETF Transport Services offered by end systems supporting TAPS, and gives guidance on choosing among the available mechanisms and protocols.  It is based on the set of transport features given in the TAPS document draft- ietf-taps-transports-usage-09.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-taps-minset-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-taps-minset-01.txt' />
</reference>



<reference anchor="I-D.ietf-tsvwg-rtcweb-qos">
<front>
<title>DSCP Packet Markings for WebRTC QoS</title>

<author initials='P' surname='Jones' fullname='Paul Jones'>
    <organization />
</author>

<author initials='S' surname='Dhesikan' fullname='Subha Dhesikan'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<author initials='D' surname='Druta' fullname='Dan Druta'>
    <organization />
</author>

<date month='August' day='19' year='2016' />

<abstract><t>Many networks, such as service provider and enterprise networks, can provide different forwarding treatments for individual packets based on Differentiated Services Code Point (DSCP) values on a per-hop basis.  This document provides the recommended DSCP values for web browsers to use for various classes of WebRTC traffic.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tsvwg-rtcweb-qos-18' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-rtcweb-qos-18.txt' />
</reference>



<reference  anchor="RFC8305" target='https://www.rfc-editor.org/info/rfc8305'>
<front>
<title>Happy Eyeballs Version 2: Better Connectivity Using Concurrency</title>
<author initials='D.' surname='Schinazi' fullname='D. Schinazi'><organization /></author>
<author initials='T.' surname='Pauly' fullname='T. Pauly'><organization /></author>
<date year='2017' month='December' />
<abstract><t>Many communication protocols operating over the modern Internet use hostnames.  These often resolve to multiple IP addresses, each of which may have different performance and connectivity characteristics.  Since specific addresses or address families (IPv4 or IPv6) may be blocked, broken, or sub-optimal on a network, clients that attempt multiple connections in parallel have a chance of establishing a connection more quickly.  This document specifies requirements for algorithms that reduce this user-visible delay and provides an example algorithm, referred to as &quot;Happy Eyeballs&quot;.  This document obsoletes the original algorithm description in RFC 6555.</t></abstract>
</front>
<seriesInfo name='RFC' value='8305'/>
<seriesInfo name='DOI' value='10.17487/RFC8305'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC8303" target='https://www.rfc-editor.org/info/rfc8303'>
<front>
<title>On the Usage of Transport Features Provided by IETF Transport Protocols</title>
<author initials='M.' surname='Welzl' fullname='M. Welzl'><organization /></author>
<author initials='M.' surname='Tuexen' fullname='M. Tuexen'><organization /></author>
<author initials='N.' surname='Khademi' fullname='N. Khademi'><organization /></author>
<date year='2018' month='February' />
<abstract><t>This document describes how the transport protocols Transmission Control Protocol (TCP), MultiPath TCP (MPTCP), Stream Control Transmission Protocol (SCTP), User Datagram Protocol (UDP), and Lightweight User Datagram Protocol (UDP-Lite) expose services to applications and how an application can configure and use the features that make up these services.  It also discusses the service provided by the Low Extra Delay Background Transport (LEDBAT) congestion control mechanism.  The description results in a set of transport abstractions that can be exported in a transport services (TAPS) API.</t></abstract>
</front>
<seriesInfo name='RFC' value='8303'/>
<seriesInfo name='DOI' value='10.17487/RFC8303'/>
</reference>



<reference  anchor="RFC7413" target='https://www.rfc-editor.org/info/rfc7413'>
<front>
<title>TCP Fast Open</title>
<author initials='Y.' surname='Cheng' fullname='Y. Cheng'><organization /></author>
<author initials='J.' surname='Chu' fullname='J. Chu'><organization /></author>
<author initials='S.' surname='Radhakrishnan' fullname='S. Radhakrishnan'><organization /></author>
<author initials='A.' surname='Jain' fullname='A. Jain'><organization /></author>
<date year='2014' month='December' />
<abstract><t>This document describes an experimental TCP mechanism called TCP Fast Open (TFO).  TFO allows data to be carried in the SYN and SYN-ACK packets and consumed by the receiving end during the initial connection handshake, and saves up to one full round-trip time (RTT) compared to the standard TCP, which requires a three-way handshake (3WHS) to complete before data can be exchanged.  However, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed to an application in some rare circumstances.  Applications should not use TFO unless they can tolerate this issue, as detailed in the Applicability section.</t></abstract>
</front>
<seriesInfo name='RFC' value='7413'/>
<seriesInfo name='DOI' value='10.17487/RFC7413'/>
</reference>



<reference  anchor="RFC8304" target='https://www.rfc-editor.org/info/rfc8304'>
<front>
<title>Transport Features of the User Datagram Protocol (UDP) and Lightweight UDP (UDP-Lite)</title>
<author initials='G.' surname='Fairhurst' fullname='G. Fairhurst'><organization /></author>
<author initials='T.' surname='Jones' fullname='T. Jones'><organization /></author>
<date year='2018' month='February' />
<abstract><t>This is an informational document that describes the transport protocol interface primitives provided by the User Datagram Protocol (UDP) and the Lightweight User Datagram Protocol (UDP-Lite) transport protocols.  It identifies the datagram services exposed to applications and how an application can configure and use the features offered by the Internet datagram transport service.  RFC 8303 documents the usage of transport features provided by IETF transport protocols, describing the way UDP, UDP-Lite, and other transport protocols expose their services to applications and how an application can configure and use the features that make up these services.  This document provides input to and context for that document, as well as offers a road map to documentation that may help users of the UDP and UDP-Lite protocols.</t></abstract>
</front>
<seriesInfo name='RFC' value='8304'/>
<seriesInfo name='DOI' value='10.17487/RFC8304'/>
</reference>



<reference  anchor="RFC8260" target='https://www.rfc-editor.org/info/rfc8260'>
<front>
<title>Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol</title>
<author initials='R.' surname='Stewart' fullname='R. Stewart'><organization /></author>
<author initials='M.' surname='Tuexen' fullname='M. Tuexen'><organization /></author>
<author initials='S.' surname='Loreto' fullname='S. Loreto'><organization /></author>
<author initials='R.' surname='Seggelmann' fullname='R. Seggelmann'><organization /></author>
<date year='2017' month='November' />
<abstract><t>The Stream Control Transmission Protocol (SCTP) is a message-oriented transport protocol supporting arbitrarily large user messages.  This document adds a new chunk to SCTP for carrying payload data.  This allows a sender to interleave different user messages that would otherwise result in head-of-line blocking at the sender.  The interleaving of user messages is required for WebRTC data channels.</t><t>Whenever an SCTP sender is allowed to send user data, it may choose from multiple outgoing SCTP streams.  Multiple ways for performing this selection, called stream schedulers, are defined in this document.  A stream scheduler can choose to either implement, or not implement, user message interleaving.</t></abstract>
</front>
<seriesInfo name='RFC' value='8260'/>
<seriesInfo name='DOI' value='10.17487/RFC8260'/>
</reference>



<reference  anchor="RFC6458" target='https://www.rfc-editor.org/info/rfc6458'>
<front>
<title>Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)</title>
<author initials='R.' surname='Stewart' fullname='R. Stewart'><organization /></author>
<author initials='M.' surname='Tuexen' fullname='M. Tuexen'><organization /></author>
<author initials='K.' surname='Poon' fullname='K. Poon'><organization /></author>
<author initials='P.' surname='Lei' fullname='P. Lei'><organization /></author>
<author initials='V.' surname='Yasevich' fullname='V. Yasevich'><organization /></author>
<date year='2011' month='December' />
<abstract><t>This document describes a mapping of the Stream Control Transmission Protocol (SCTP) into a sockets API.  The benefits of this mapping include compatibility for TCP applications, access to new SCTP features, and a consolidated error and event notification scheme. This document is not an Internet Standards Track specification; it is published for informational purposes.</t></abstract>
</front>
<seriesInfo name='RFC' value='6458'/>
<seriesInfo name='DOI' value='10.17487/RFC6458'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-quic-transport">
<front>
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>

<author initials='J' surname='Iyengar' fullname='Jana Iyengar'>
    <organization />
</author>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='January' day='28' year='2018' />

<abstract><t>This document defines the core of the QUIC transport protocol.  This document describes connection establishment, packet format, multiplexing and reliability.  Accompanying documents describe the cryptographic handshake and loss detection.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-quic-transport-09' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-quic-transport-09.txt' />
</reference>



<reference anchor="I-D.ietf-tls-tls13">
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.3</title>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<date month='February' day='15' year='2018' />

<abstract><t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-tls13-24' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-tls13-24.txt' />
</reference>


<reference anchor="NEAT-flow-mapping" >
  <front>
    <title>Transparent Flow Mapping for NEAT (in Workshop on Future of Internet Transport (FIT 2017))</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="Trickle" >
  <front>
    <title>Trickle - Rate Limiting YouTube Video Streaming (ATC 2012)</title>
    <author >
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>


    </references>



  </back>

<!-- ##markdown-source:
H4sIAAxllVoAA+192XIb2ZXgO74iW/VQZBuAREkuV9PTPaYoSiWXNouUK9zu
iooEkADTSmTCuZBCyZroj5jHmZiPmT/pL5mz33MzE5JsT0fMwyiqJBLIvMu5
Z9/ubDabtHlbZKfJs+2uyLZZ2eblJnlWtlm9TpdZk7RVclWnZbOr6ja5zOqb
HD6dpItFnd2cJldnry/Dq2mbV+VkVS3LdAtDrup03c4WdVc2bV1tZ226a2Y5
PDwr0jZr2skK/jmdLOHvTVXvT5O8XFeTSb6rT5O27pr2/r17/3Tv/iSts/Q0
rGJyW9XvNnXV7WT+H+B3XPVT/GzyLtvDA6tT3kSZtbPHuI7JpGnTcvVTWlQl
rG0Pm9jlp8kf22o5TRoYts7WDfy03+IPP04maddeV/XpJElm8H8Ci2tOk7N5
8kj3Q5/yTs/KMu19UVcI1WyVt1VNH2TbNC9OkxQenRtMfvMu7eZNFk9yNU9e
p12xdxNcVdvt3n06GL2qN7CMHRwE7Hs5p89ghixrT5NXZSZfvU7rd8kPKY+x
zFuA+Xm3y2o49GqanKdFvq7qMk+Tf/rlvZOH/FTVlS0eztsyb7NVctni2SXV
OjnbZnW+TP3m2h2u8DcpTjZfEiTifV2Um+u0XrV+a9dZnTVp/BVt5+pt8iir
i7yMdvMirZfX8Ev6v/9Xltx/4LZycu+X3/7Kv2Jrf5rV27TcR0vlaX+TA4bM
2262oNfmq95ZfD/77RwQKy/LbFu5VX+f1sXst9V1Wsbf0sLxS8C2FcLsJqsb
WJ2f+h2++yd8d76Rdw/hwW8BWZsYD9xnNFmYgw4F9rHKsjLaKuBZVm/m6WJV
ztPlvHsXz/N6nlzlWZMVbqLX13mR73bJZfTdf/6x7Hjezx3LOZBIhlTvgXNe
waPR5yMAelqkzaa6jdZ+ubyuqgK/Pa+2u45Y4OUyz8pl5vYhbyZPT+4n3/7u
d6PU8T28uhIOIDtaNrvfwP+8qjmsKN7Ji3nyQ1b87GH/Il9ep1nhPh/Zx6um
qKJNvH6VPKreA7S/vZc8AkCsgPm51d97cPJNEt6yhb+s6ts0OoItTn+b/SZf
5/Mur+Yl8OSygpNqYf5TevLZ7PGcSJ15Oh49f5EkIk7OyuQMPgWgLNuuzhLg
K2NyhN/papj2um13zenduzziLp9v8va6W8zz6i4Jkob/mfXmnV+320LGYZbd
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

-->

</rfc>

